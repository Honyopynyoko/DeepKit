"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandApplication = void 0;
const core_1 = require("@deepkit/core");
const service_container_1 = require("./service-container");
const config_1 = require("@oclif/config");
const path_1 = require("path");
const command_1 = require("@oclif/command");
const errors_1 = require("@oclif/errors");
const command_2 = require("./command");
const configuration_1 = require("./configuration");
class CommandApplication {
    constructor(appModule, providers = [], imports = [], serviceContainer = new service_container_1.ServiceContainer(appModule, providers, imports.slice(0))) {
        this.appModule = appModule;
        this.serviceContainer = serviceContainer;
    }
    setup(...args) {
        this.serviceContainer.appModule = this.serviceContainer.appModule.setup(...args);
        return this;
    }
    configure(config) {
        const appConfig = {};
        const moduleConfigs = {};
        const moduleNames = this.serviceContainer.getRootInjectorContext().getModuleNames();
        for (const i in config) {
            let name = i;
            const separator = name.indexOf('_');
            let module = '';
            if (separator > 0) {
                module = name.substr(0, separator);
                name = name.substr(separator + 1);
            }
            if (module) {
                if (!moduleConfigs[module])
                    moduleConfigs[module] = {};
                moduleConfigs[module][name] = config[i];
            }
            else {
                if (moduleNames.includes(name)) {
                    moduleConfigs[name] = config[i];
                }
                else {
                    appConfig[name] = config[i];
                }
            }
        }
        this.serviceContainer.appModule.setConfig(appConfig);
        for (const i in moduleConfigs) {
            const module = this.serviceContainer.getRootInjectorContext().getModule(i);
            module.setConfig(moduleConfigs[i]);
        }
        return this;
    }
    /**
     * Loads a .env file and sets its configuration value.
     *
     * `path` is either an absolute or relative path. For relative paths the first
     * folder with a package.json starting from process.cwd() upwards is picked.
     *
     * So if you use 'local.env' make sure a 'local.env' file is localed beside your 'package.json'.
     *
     * `path` can be an array of paths. First existing path is picked.
     */
    loadConfigFromEnvFile(path) {
        const envConfiguration = new configuration_1.EnvConfiguration();
        const paths = core_1.isArray(path) ? path : [path];
        for (const path of paths) {
            if (envConfiguration.loadEnvFile(path))
                break;
        }
        this.configure(envConfiguration.getAll());
        return this;
    }
    /**
     * Load all environment variables that start with given prefix and try to
     * find matching configuration options and set its value.
     *
     * Example:
     *
     * APP_databaseUrl="mongodb://localhost/mydb"
     *
     * Application.run().loadConfigFromEnvVariables('APP_').run();
     */
    loadConfigFromEnvVariables(prefix = 'APP_') {
        const appConfig = {};
        const moduleConfigs = {};
        for (const i in process.env) {
            if (!i.startsWith(prefix))
                continue;
            let name = i.substr(prefix.length);
            const separator = name.indexOf('_');
            let module = '';
            if (separator > 0) {
                module = name.substr(0, separator);
                name = name.substr(separator + 1);
            }
            if (module) {
                if (!moduleConfigs[module])
                    moduleConfigs[module] = {};
                moduleConfigs[module][name] = process.env[i];
            }
            else {
                appConfig[name] = process.env[i];
            }
        }
        this.serviceContainer.appModule.setConfig(appConfig);
        for (const i in moduleConfigs) {
            const module = this.serviceContainer.getRootInjectorContext().getModule(i);
            module.setConfig(moduleConfigs[i]);
        }
        return this;
    }
    /**
     * Loads a JSON encoded environment variable and applies its content to the configuration.
     *
     * Example:
     *
     * APP_CONFIG={"databaseUrl": "mongodb://localhost/mydb", "moduleA": {"foo": "bar"}}
     *
     * Application.run().loadConfigFromEnvVariable('APP_CONFIG').run();
     */
    loadConfigFromEnvVariable(variableName = 'APP_CONFIG') {
        if (!process.env[variableName])
            return this;
        let config = {};
        try {
            config = JSON.parse(process.env[variableName] || '');
        }
        catch (error) {
            throw new Error(`Invalid JSON in env variable ${variableName}. Parse error: ${error}`);
        }
        this.configure(config);
        return this;
    }
    async run(argv) {
        const exitCode = await this.execute(argv !== null && argv !== void 0 ? argv : process.argv.slice(2));
        if (exitCode > 0)
            process.exit(exitCode);
    }
    get(token) {
        return this.serviceContainer.getRootInjectorContext().getInjector(0).get(token);
    }
    async execute(argv) {
        this.serviceContainer.process();
        let result;
        class MyConfig extends config_1.Config {
            constructor(options) {
                super(options);
                this.commandsMap = {};
                this.root = options.root;
                this.userAgent = 'Node';
                this.name = 'app';
                const bin = path_1.basename(process.argv[0]);
                this.bin = `${bin} ${path_1.relative(process.cwd(), process.argv[1]) || '.'}`;
                this.version = '0.0.1';
                this.pjson = {
                    name: this.name,
                    version: this.version,
                    oclif: {
                        update: {
                            s3: {},
                            node: {}
                        }
                    }
                };
            }
            runHook(event, opts) {
                if (event === 'postrun') {
                    result = opts.result;
                }
                return super.runHook(event, opts);
            }
            findCommand(id, opts) {
                return this.commandsMap[id];
            }
            get commandIDs() {
                return Object.keys(this.commandsMap);
            }
            get commands() {
                return Object.values(this.commandsMap);
            }
        }
        try {
            const config = new MyConfig({ root: __dirname });
            for (const [name, controller] of this.serviceContainer.cliControllers.controllers.entries()) {
                config.commandsMap[name] = command_2.buildOclifCommand(controller, this.serviceContainer.getRootInjectorContext());
            }
            await command_1.Main.run(argv, config);
        }
        catch (e) {
            if (e instanceof errors_1.ExitError) {
                return e.oclif.exit;
            }
            else {
                console.log(e);
            }
            return 12;
        }
        return result;
    }
}
exports.CommandApplication = CommandApplication;
//# sourceMappingURL=application.js.map