/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { createClassDecoratorContext, createPropertyDecoratorContext, getClassSchema, getPropertyXtoClassFunction, jitValidateProperty, jsonSerializer, t, ValidationFailedItem } from '@deepkit/type';
import { Command as OclifCommandBase } from '@oclif/command';
import { flags } from '@oclif/parser';
class ArgDefinitions {
    constructor() {
        this.name = '';
        this.description = '';
        this.args = [];
    }
    getArg(name) {
        for (const arg of this.args)
            if (arg.name === name)
                return arg;
        throw new Error(`No argument with name ${name} found`);
    }
}
class CommandDecorator {
    constructor() {
        this.t = new ArgDefinitions;
    }
    controller(name, options) {
        this.t.name = name;
        if (options) {
            if (options.description)
                this.t.description = options.description;
        }
    }
    addArg(arg) {
        this.t.args.unshift(arg);
    }
}
export const cli = createClassDecoratorContext(CommandDecorator);
class ArgDefinition {
    constructor() {
        this.name = '';
        this.isFlag = false;
        this.multiple = false;
        this.hidden = false;
        this.char = '';
        this.optional = false;
        this.description = '';
    }
}
export class ArgDecorator {
    constructor() {
        this.t = new ArgDefinition;
    }
    onDecorator(classType, property, parameterIndex) {
        var _a;
        if (!property)
            throw new Error('arg|flag needs to be on a method argument or class property, .e.g execute(@arg hostname: string) {}');
        const schema = getClassSchema(classType);
        if (parameterIndex === undefined && !schema.hasProperty(property)) {
            //make sure its known in ClassSchema
            t(classType.prototype, property);
        }
        const propertySchema = parameterIndex !== undefined
            ? getClassSchema(classType).getMethodProperties(property)[parameterIndex]
            : getClassSchema(classType).getProperty(property);
        this.t.name = propertySchema.name;
        this.t.propertySchema = propertySchema;
        if (this.t.optional)
            propertySchema.isOptional = true;
        const aBase = cli._fetch((_a = Object.getPrototypeOf(classType.prototype)) === null || _a === void 0 ? void 0 : _a.constructor);
        if (aBase) {
            const a = cli._fetch(classType);
            if (a) {
                a.args.unshift(...aBase.args);
            }
        }
        cli.addArg(this.t)(classType);
    }
    description(description) {
        this.t.description = description;
    }
    get optional() {
        this.t.optional = true;
        return;
    }
    default(value) {
        this.t.default = value;
        this.t.optional = true;
        return;
    }
    get multiple() {
        this.t.multiple = true;
        return;
    }
    get hidden() {
        this.t.hidden = true;
        return;
    }
    char(char) {
        this.t.char = char;
    }
}
export class ArgFlagDecorator extends ArgDecorator {
    onDecorator(classType, property, parameterIndex) {
        this.t.isFlag = true;
        super.onDecorator(classType, property, parameterIndex);
    }
}
export const arg = createPropertyDecoratorContext(ArgDecorator);
export const flag = createPropertyDecoratorContext(ArgFlagDecorator);
export function isCommand(classType) {
    return !!cli._fetch(classType);
}
export function buildOclifCommand(classType, rootScopedContext) {
    const oclifArgs = [];
    const oclifFlags = {};
    const argDefinitions = cli._fetch(classType);
    if (!argDefinitions)
        throw new Error(`No command name set. use @cli.controller('name')`);
    if (!argDefinitions.name)
        throw new Error(`No command name set. use @cli.controller('name')`);
    let converters = new Map();
    for (const property of argDefinitions.args) {
        converters.set(property.propertySchema, (value) => {
            value = getPropertyXtoClassFunction(property.propertySchema, jsonSerializer)(value);
            const errors = [];
            jitValidateProperty(property.propertySchema)(value, property.propertySchema.name, errors);
            if (errors.length) {
                throw errors[0];
            }
            return value;
        });
    }
    for (const i in argDefinitions.args) {
        if (!argDefinitions.args.hasOwnProperty(i))
            continue;
        const t = argDefinitions.args[i];
        const options = {
            name: t.name,
            description: t.description,
            hidden: t.hidden,
            required: !t.optional,
            multiple: t.multiple,
            default: t.default,
        };
        //todo, add `parse(i)` and make sure type is correct depending on t.propertySchema.type
        if (t.isFlag) {
            oclifFlags[t.name] = t.propertySchema.type === 'boolean' ? flags.boolean(options) : flags.string(options);
        }
        else {
            oclifArgs.push(options);
        }
    }
    return {
        aliases: [], description: argDefinitions.description, args: oclifArgs, flags: oclifFlags, hidden: false, id: argDefinitions.name,
        load() {
            class Clazz extends OclifCommandBase {
                async run() {
                    var _a;
                    const { flags, args } = this.parse(Clazz);
                    const cliScopedContext = rootScopedContext.createChildScope('cli');
                    const instance = cliScopedContext.get(classType);
                    const methodArgs = [];
                    for (const property of argDefinitions.args) {
                        try {
                            const v = converters.get(property.propertySchema)((_a = args[property.name]) !== null && _a !== void 0 ? _a : flags[property.name]);
                            if (property.propertySchema.methodName === 'execute') {
                                methodArgs.push(v);
                            }
                            else if (!property.propertySchema.methodName) {
                                if (v !== undefined) {
                                    instance[property.name] = v;
                                }
                            }
                        }
                        catch (e) {
                            if (e instanceof ValidationFailedItem) {
                                console.log(`Validation error in ${e.path}: ${e.message} [${e.code}]`);
                                return 8;
                            }
                            console.log(e);
                            return 8;
                        }
                    }
                    const exitCode = await instance.execute(...methodArgs);
                    if (typeof exitCode === 'number')
                        return exitCode;
                    return 0;
                }
            }
            Clazz.args = oclifArgs;
            Clazz.flags = oclifFlags;
            return Clazz;
        }
    };
}
//# sourceMappingURL=command.js.map