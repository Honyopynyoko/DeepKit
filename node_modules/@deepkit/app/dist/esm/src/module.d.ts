import { ExtractClassDefinition, JSONPartial, PlainSchemaProps } from '@deepkit/type';
import { ConfigDefinition, InjectorModule, InjectToken, ProviderWithScope } from '@deepkit/injector';
import { ClassType, CustomError } from '@deepkit/core';
import { EventListener } from '@deepkit/event';
import type { WorkflowDefinition } from '@deepkit/workflow';
export declare type DefaultObject<T> = T extends undefined ? {} : T;
export declare type ExtractAppModuleName<T extends AppModule<any, any>> = T extends AppModule<any, infer NAME> ? NAME : never;
export declare type ExtractImportConfigs<T extends Array<AppModule<any, any>> | undefined> = T extends Array<any> ? {
    [M in T[number] as (ExtractAppModuleName<M> & string)]?: ExtractPartialConfigOfDefinition<DefaultObject<ExtractModuleOptions<M>['config']>>;
} : {};
export declare type ExtractConfigOfDefinition<T> = T extends ConfigDefinition<infer C> ? C : {};
export declare type ExtractPartialConfigOfDefinition<T> = T extends ConfigDefinition<infer C> ? JSONPartial<C> : {};
export declare type ExtractModuleOptions<T extends AppModule<any, any>> = T extends AppModule<infer O, any> ? O : never;
export declare type ModuleConfigOfOptions<O extends ModuleOptions> = ExtractImportConfigs<O['imports']> & ExtractPartialConfigOfDefinition<DefaultObject<O['config']>>;
export interface ModuleOptions {
    /**
     * Providers.
     */
    providers?: ProviderWithScope[];
    /**
     * Export providers (its token `provide` value) or modules you imported first.
     */
    exports?: (ClassType | InjectToken | string | AppModule<any, any>)[];
    /**
     * Module bootstrap class.
     */
    bootstrap?: ClassType;
    /**
     * Configuration definition.
     *
     * @example
     * ```typescript
     * import {t} from '@deepkit/type';
     *
     * const myModule = new AppModule({
     *     config: {
     *         debug: t.boolean.default(false),
     *     }
     * });
     * ```
     */
    config?: ConfigDefinition<any>;
    /**
     * CLI controllers.
     */
    controllers?: ClassType[];
    /**
     * Register created workflows. This allows the Framework Debugger to collect
     * debug information and display the graph of your workflow.
     */
    workflows?: WorkflowDefinition<any>[];
    /**
     * Event listeners.
     *
     * @example with simple functions
     * ```typescript
     * {
     *     listeners: [
     *         onEvent.listen((event: MyEvent) => {console.log('event triggered', event);}),
     *     ]
     * }
     * ```
     *
     * @example with services
     * ```typescript
     *
     * class MyListener {
     *     @eventDispatcher.listen(onEvent)
     *     onEvent(event: typeof onEvent['type']) {
     *         console.log('event triggered', event);
     *     }
     * }
     *
     * {
     *     listeners: [
     *         MyListener,
     *     ]
     * }
     * ```
     */
    listeners?: (EventListener<any> | ClassType)[];
    /**
     * Import another module.
     */
    imports?: AppModule<any, any>[];
}
export declare class ConfigurationInvalidError extends CustomError {
}
export declare class AppModuleConfig<T extends PlainSchemaProps> extends ConfigDefinition<ExtractClassDefinition<T>> {
    config: T;
    constructor(config: T);
}
export declare class AppModule<T extends ModuleOptions, NAME extends string = ''> extends InjectorModule<NAME, ExtractConfigOfDefinition<DefaultObject<T['config']>>> {
    options: T;
    /**
     * The lowercase alphanumeric module name. This is used in the configuration system for example.
     * Choose a short unique name for best usability.
     */
    name: NAME;
    configValues: {
        [path: string]: any;
    };
    setups: ((module: AppModule<T, NAME>, config: ExtractConfigOfDefinition<DefaultObject<T['config']>>) => void)[];
    readonly id: number;
    root: boolean;
    parent?: AppModule<any, any>;
    protected configLoaded: boolean;
    constructor(options: T, 
    /**
     * The lowercase alphanumeric module name. This is used in the configuration system for example.
     * Choose a short unique name for best usability.
     */
    name?: NAME, configValues?: {
        [path: string]: any;
    }, setups?: ((module: AppModule<T, NAME>, config: ExtractConfigOfDefinition<DefaultObject<T['config']>>) => void)[], id?: number);
    getImports(): AppModule<ModuleOptions, any>[];
    getExports(): (string | AppModule<any, any> | ClassType<any> | InjectToken)[];
    hasImport(module: AppModule<any, any>): boolean;
    /**
     * Modifies this module and adds a new import, returning the same module.
     */
    addImport(...modules: AppModule<any, any>[]): this;
    addController(...controller: ClassType[]): void;
    addProvider(...provider: ProviderWithScope[]): void;
    addListener(...listener: ClassType[]): void;
    private hasConfigOption;
    private getConfigOption;
    getConfig(): ExtractConfigOfDefinition<DefaultObject<T['config']>>;
    setParent(module: AppModule<any, any>): void;
    clone(): AppModule<T, NAME>;
    getName(): NAME;
    /**
     * Allows to change the module after the configuration has been loaded, right before the application bootstraps (thus loading all services/controllers/etc).
     *
     * Returns a new forked module of this with the changes applied.
     */
    setup(callback: (module: AppModule<T, any>, config: ExtractConfigOfDefinition<DefaultObject<T['config']>>) => void): AppModule<T, NAME>;
    /**
     * Sets configured values that no longer are inherited from the parent.
     * Returns a new forked module of this with the changes applied.
     */
    configure(config: ModuleConfigOfOptions<T>): AppModule<T, NAME>;
    /**
     * Overwrites configuration values of the current module.
     */
    setConfig(config: ModuleConfigOfOptions<T>): void;
    /**
     * Makes all the providers, controllers, etc available at the root module, basically exporting everything.
     * Returns a new forked module of this with root enabled.
     */
    forRoot(): AppModule<T, NAME>;
}
