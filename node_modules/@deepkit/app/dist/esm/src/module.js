/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { jsonSerializer, t, ValidationFailed } from '@deepkit/type';
import { ConfigDefinition, InjectorModule } from '@deepkit/injector';
import { CustomError } from '@deepkit/core';
function cloneOptions(options) {
    var _a, _b, _c, _d, _e, _f;
    const copied = { ...options };
    copied.imports = (_a = copied.imports) === null || _a === void 0 ? void 0 : _a.slice(0);
    copied.exports = (_b = copied.exports) === null || _b === void 0 ? void 0 : _b.slice(0);
    copied.providers = (_c = copied.providers) === null || _c === void 0 ? void 0 : _c.slice(0);
    copied.controllers = (_d = copied.controllers) === null || _d === void 0 ? void 0 : _d.slice(0);
    copied.listeners = (_e = copied.listeners) === null || _e === void 0 ? void 0 : _e.slice(0);
    copied.workflows = (_f = copied.workflows) === null || _f === void 0 ? void 0 : _f.slice(0);
    return copied;
}
export class ConfigurationInvalidError extends CustomError {
}
let moduleId = 0;
export class AppModuleConfig extends ConfigDefinition {
    constructor(config) {
        super(t.schema(config));
        this.config = config;
    }
}
export class AppModule extends InjectorModule {
    constructor(options, 
    /**
     * The lowercase alphanumeric module name. This is used in the configuration system for example.
     * Choose a short unique name for best usability.
     */
    name = '', configValues = {}, setups = [], id = moduleId++) {
        super(name, {});
        this.options = options;
        this.name = name;
        this.configValues = configValues;
        this.setups = setups;
        this.id = id;
        this.root = false;
        this.configLoaded = false;
        if (options.config instanceof ConfigDefinition) {
            options.config.setModule(this);
        }
        if (this.options.imports) {
            for (const module of this.options.imports) {
                module.setParent(this);
            }
        }
    }
    getImports() {
        return this.options.imports || [];
    }
    getExports() {
        return this.options.exports || [];
    }
    hasImport(module) {
        for (const importModule of this.getImports()) {
            if (importModule.id === module.id)
                return true;
        }
        return false;
    }
    /**
     * Modifies this module and adds a new import, returning the same module.
     */
    addImport(...modules) {
        for (const module of modules) {
            module.setParent(this);
            if (!this.options.imports)
                this.options.imports = [];
            this.options.imports.push(module);
        }
        return this;
    }
    addController(...controller) {
        if (!this.options.controllers)
            this.options.controllers = [];
        this.options.controllers.push(...controller);
    }
    addProvider(...provider) {
        if (!this.options.providers)
            this.options.providers = [];
        this.options.providers.push(...provider);
    }
    addListener(...listener) {
        if (!this.options.listeners)
            this.options.listeners = [];
        this.options.listeners.push(...listener);
    }
    hasConfigOption(path) {
        if (path in this.configValues)
            return true;
        if (this.parent && this.parent.hasConfigOption(path))
            return true;
        return false;
    }
    getConfigOption(path) {
        if (path in this.configValues)
            return this.configValues[path];
        if (this.parent && this.parent.hasConfigOption(path))
            return this.parent.getConfigOption(path);
        return;
    }
    getConfig() {
        if (this.configLoaded)
            return this.config;
        const config = {};
        if (!this.options.config)
            return this.config;
        this.configLoaded = true;
        for (const option of this.options.config.schema.getProperties()) {
            const path = this.name ? this.name + '.' + option.name : option.name;
            config[option.name] = this.getConfigOption(path);
        }
        try {
            Object.assign(this.config, jsonSerializer.for(this.options.config.schema).validatedDeserialize(config));
            return this.config;
        }
        catch (e) {
            if (e instanceof ValidationFailed) {
                const errorsMessage = e.errors.map(v => v.toString(this.getName())).join(', ');
                throw new ConfigurationInvalidError(`Configuration for module ${this.getName() || 'root'} is invalid. Make sure the module is correctly configured. Error: ` + errorsMessage);
            }
            throw e;
        }
    }
    setParent(module) {
        this.parent = module;
    }
    clone() {
        const m = new AppModule(cloneOptions(this.options), this.name, { ...this.configValues }, this.setups.slice(0), this.id);
        m.root = this.root;
        m.parent = this.parent;
        m.setupProviderRegistry = this.setupProviderRegistry.clone();
        const imports = m.getImports();
        const exports = m.getExports();
        for (let i = 0; i < imports.length; i++) {
            const old = imports[i];
            imports[i] = old.clone();
            const index = exports.indexOf(old);
            if (index !== -1)
                exports[index] = imports[i];
        }
        return m;
    }
    getName() {
        return this.name;
    }
    /**
     * Allows to change the module after the configuration has been loaded, right before the application bootstraps (thus loading all services/controllers/etc).
     *
     * Returns a new forked module of this with the changes applied.
     */
    setup(callback) {
        const m = this.clone();
        m.setups.push(callback);
        return m;
    }
    /**
     * Sets configured values that no longer are inherited from the parent.
     * Returns a new forked module of this with the changes applied.
     */
    configure(config) {
        const configValues = { ...this.configValues };
        if (this.options.imports) {
            for (const module of this.options.imports) {
                if (!module.getName())
                    continue;
                if (!(module.getName() in config))
                    continue;
                const moduleConfig = config[module.getName()];
                for (const [name, value] of Object.entries(moduleConfig)) {
                    const path = module.getName() ? module.getName() + '.' + name : name;
                    configValues[path] = value;
                }
            }
        }
        if (this.options.config) {
            for (const option of this.options.config.schema.getProperties()) {
                if (!(option.name in config))
                    continue;
                const path = this.name ? this.name + '.' + option.name : option.name;
                configValues[path] = config[option.name];
            }
        }
        const m = this.clone();
        m.configValues = configValues;
        return m;
    }
    /**
     * Overwrites configuration values of the current module.
     */
    setConfig(config) {
        const resolvedConfig = this.getConfig();
        if (this.options.config) {
            const configNormalized = jsonSerializer.for(this.options.config.schema).partialDeserialize(config);
            for (const option of this.options.config.schema.getProperties()) {
                if (!(option.name in config))
                    continue;
                resolvedConfig[option.name] = configNormalized[option.name];
            }
        }
    }
    /**
     * Makes all the providers, controllers, etc available at the root module, basically exporting everything.
     * Returns a new forked module of this with root enabled.
     */
    forRoot() {
        const m = this.clone();
        m.root = true;
        return m;
    }
}
//# sourceMappingURL=module.js.map