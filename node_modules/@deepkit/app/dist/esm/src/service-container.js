/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { arrayRemoveItem, isClass } from '@deepkit/core';
import { EventDispatcher } from '@deepkit/event';
import { AppModule } from './module';
import { ConfiguredProviderRegistry, Context, ContextRegistry, InjectorContext, TagProvider, tokenLabel } from '@deepkit/injector';
import { cli } from './command';
export class CliControllers {
    constructor() {
        this.controllers = new Map();
    }
}
export class WorkflowRegistry {
    constructor(workflows) {
        this.workflows = workflows;
    }
    get(name) {
        for (const w of this.workflows) {
            if (w.name === name)
                return w;
        }
        throw new Error(`Workflow with name ${name} does not exist`);
    }
    add(workflow) {
        this.workflows.push(workflow);
    }
}
export function isProvided(providers, token) {
    return providers.find(v => !(v instanceof TagProvider) ? token === (isClass(v) ? v : v.provide) : false) !== undefined;
}
export class ServiceContainer {
    constructor(appModule, providers = [], imports = []) {
        this.appModule = appModule;
        this.providers = providers;
        this.imports = imports;
        this.cliControllers = new CliControllers;
        this.workflowRegistry = new WorkflowRegistry([]);
        this.currentIndexId = 0;
        this.contextManager = new ContextRegistry();
        this.rootInjectorContext = new InjectorContext(this.contextManager, 'module', new ConfiguredProviderRegistry);
        this.eventListenerContainer = new EventDispatcher(this.rootInjectorContext);
        this.moduleContexts = new Map();
        this.moduleIdContexts = new Map();
    }
    process() {
        if (this.rootContext)
            return;
        this.setupHook(this.appModule);
        this.providers.push({ provide: ServiceContainer, useValue: this });
        this.providers.push({ provide: EventDispatcher, useValue: this.eventListenerContainer });
        this.providers.push({ provide: CliControllers, useValue: this.cliControllers });
        this.providers.push({ provide: InjectorContext, useValue: this.rootInjectorContext });
        this.rootContext = this.processModule(this.appModule, undefined, this.providers, this.imports);
        this.bootstrapModules();
    }
    getRootInjectorContext() {
        this.process();
        return this.rootInjectorContext;
    }
    setupHook(module) {
        const config = module.getConfig();
        for (const setup of module.setups)
            setup(module, config);
        for (const importModule of module.getImports()) {
            this.setupHook(importModule);
        }
        return module;
    }
    bootstrapModules() {
        for (const module of this.moduleContexts.keys()) {
            if (module.options.bootstrap) {
                this.getInjectorFor(module).get(module.options.bootstrap);
            }
        }
    }
    getContextFor(module) {
        this.process();
        const contexts = this.moduleIdContexts.get(module.id) || [];
        if (!contexts.length)
            throw new Error('Module not registered.');
        return contexts[0];
    }
    getInjectorFor(module) {
        this.process();
        const context = this.getContextFor(module);
        return this.rootInjectorContext.getInjector(context.id);
    }
    getRootInjector() {
        this.process();
        if (!this.rootContext)
            throw new Error('No root context set');
        return this.rootInjectorContext.getInjector(this.rootContext.id);
    }
    getContext(id) {
        const context = this.contextManager.get(id);
        if (!context)
            throw new Error(`No context for ${id} found`);
        return context;
    }
    getNewContext(module, parent) {
        const newId = this.currentIndexId++;
        const context = new Context(module, newId, parent);
        this.contextManager.set(newId, context);
        let contexts = this.moduleContexts.get(module);
        if (!contexts) {
            contexts = [];
            this.moduleContexts.set(module, contexts);
            this.moduleIdContexts.set(module.id, contexts);
        }
        contexts.push(context);
        return context;
    }
    processModule(module, parentContext, additionalProviders = [], additionalImports = []) {
        this.rootInjectorContext.modules[module.getName()] = module;
        const exports = module.options.exports ? module.options.exports.slice(0) : [];
        const providers = module.options.providers ? module.options.providers.slice(0) : [];
        const controllers = module.options.controllers ? module.options.controllers.slice(0) : [];
        const imports = module.options.imports ? module.options.imports.slice(0) : [];
        const listeners = module.options.listeners ? module.options.listeners.slice(0) : [];
        providers.push(...additionalProviders);
        imports.unshift(...additionalImports);
        //we add the module to its own providers so it can depend on its module providers.
        //when we would add it to root it would have no access to its internal providers.
        if (module.options.bootstrap)
            providers.push(module.options.bootstrap);
        const forRootContext = module.root;
        if (module.options.workflows) {
            for (const w of module.options.workflows)
                this.workflowRegistry.add(w);
        }
        //we have to call getNewContext() either way to store this module in this.contexts.
        let context = this.getNewContext(module, parentContext);
        if (forRootContext) {
            context = this.getContext(0);
        }
        for (const provider of providers.slice(0)) {
            if (provider instanceof TagProvider) {
                if (!isProvided(providers, provider)) {
                    providers.unshift(provider.provider);
                }
                this.rootInjectorContext.tagRegistry.tags.push(provider);
            }
        }
        for (const token of exports.slice(0)) {
            // if (isModuleToken(token)) {
            if (token instanceof AppModule) {
                //exported modules will be removed from `imports`, so that
                //the target context (root or parent) imports it
                arrayRemoveItem(exports, token);
                //we remove it from imports as well, so we don't have two module instances
                arrayRemoveItem(imports, token);
                //exported a module. We handle it as if the parent would have imported it.
                this.processModule(token, parentContext);
            }
        }
        for (const imp of imports) {
            if (!imp)
                continue;
            this.processModule(imp, context);
        }
        for (const listener of listeners) {
            if (isClass(listener)) {
                providers.unshift({ provide: listener });
                this.eventListenerContainer.registerListener(listener, context);
            }
            else {
                this.eventListenerContainer.add(listener.eventToken, { fn: listener.callback, order: listener.order });
            }
        }
        for (const [provider, calls] of module.getConfiguredProviderRegistry().calls) {
            this.rootInjectorContext.configuredProviderRegistry.add(provider, ...calls);
        }
        for (const controller of controllers) {
            this.setupController(providers, controller, context);
        }
        //if there are exported tokens, their providers will be added to the parent or root context
        //and removed from module providers.
        const exportedProviders = forRootContext ? this.getContext(0).providers : (parentContext ? parentContext.providers : []);
        for (const token of exports) {
            if (token instanceof AppModule)
                throw new Error('Should already be handled');
            const provider = providers.findIndex(v => !(v instanceof TagProvider) ? token === (isClass(v) ? v : v.provide) : false);
            if (provider === -1) {
                throw new Error(`Export ${tokenLabel(token)}, but not provided in providers.`);
            }
            exportedProviders.push(providers[provider]);
            providers.splice(provider, 1);
        }
        context.providers.push(...providers);
        return context;
    }
    setupController(providers, controller, context) {
        const cliConfig = cli._fetch(controller);
        if (cliConfig) {
            if (!isProvided(providers, controller))
                providers.unshift({ provide: controller, scope: 'cli' });
            controller[InjectorContext.contextSymbol] = context;
            this.cliControllers.controllers.set(cliConfig.name, controller);
        }
    }
}
//# sourceMappingURL=service-container.js.map