var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { expect, test } from '@jest/globals';
import 'reflect-metadata';
import { t } from '@deepkit/type';
import { ConfigSlice, inject, injectable, injectorReference } from '@deepkit/injector';
import { ServiceContainer } from '../src/service-container';
import { AppModule, AppModuleConfig } from '../src/module';
const myModuleConfig = new AppModuleConfig({
    param1: t.string.minLength(5),
    param2: t.number.minimum(100)
});
class MyModuleConfigFull extends myModuleConfig.all() {
}
let ModuleService = class ModuleService {
    constructor(config) {
        this.config = config;
    }
};
ModuleService = __decorate([
    injectable(),
    __metadata("design:paramtypes", [MyModuleConfigFull])
], ModuleService);
const MyModule = new AppModule({
    config: myModuleConfig,
    providers: [
        ModuleService
    ],
    exports: [ModuleService]
}, 'myModule');
const appModuleConfig = new AppModuleConfig({
    database: t.string.default('mongodb://localhost/my-app'),
    debug: t.boolean.default(false),
});
class MyServiceConfig extends appModuleConfig.slice(['debug']) {
}
const debugConfigToken = appModuleConfig.token('debug');
expect(Object.getPrototypeOf(Object.getPrototypeOf(MyServiceConfig)) === ConfigSlice).toBe(true);
let MyService = class MyService {
    constructor(config) {
        this.config = config;
    }
    isDebug() {
        return this.config.debug;
    }
};
MyService = __decorate([
    injectable(),
    __metadata("design:paramtypes", [MyServiceConfig])
], MyService);
let MyService2 = class MyService2 {
    constructor(debug) {
        this.debug = debug;
    }
};
MyService2 = __decorate([
    injectable(),
    __param(0, inject(debugConfigToken)),
    __metadata("design:paramtypes", [Boolean])
], MyService2);
const myAppModule = new AppModule({
    providers: [
        MyService,
        MyService2,
    ],
    imports: [
        MyModule,
    ],
    config: appModuleConfig,
});
function getMyServiceFor(module, service) {
    const serviceContainer = new ServiceContainer(module);
    return serviceContainer.getRootInjectorContext().get(service);
}
test('loadConfig', () => {
    // Application.create(AppModule).loadConfigFromEnvFile('.env').run();
    // Application.create(AppModule).loadConfigFromEnvVariables().run();
    // Application.create(AppModule).loadConfigFromEnvVariable('APP_CONFIG').run();
});
test('import', () => {
    // {
    //     expect(() => getMyServiceFor(AppModule, ModuleService)).toThrow(
    //         'Configuration for module myModule is invalid. Make sure the module is correctly configured. Error: myModule.param1(required): Required value is undefined, myModule.param2(required): Required value is undefined'
    //     );
    // }
    {
        expect(() => getMyServiceFor(myAppModule.configure({ myModule: { param1: '23' } }), ModuleService)).toThrow('Configuration for module myModule is invalid. Make sure the module is correctly configured. Error: myModule.param1(minLength): Min length is 5, myModule.param2(required): Required value is undefined');
    }
    {
        expect(() => getMyServiceFor(myAppModule.configure({ myModule: { param1: '12345' } }), ModuleService)).toThrow('Configuration for module myModule is invalid. Make sure the module is correctly configured. Error: myModule.param2(required): Required value is undefined');
    }
    {
        expect(() => getMyServiceFor(myAppModule.configure({ myModule: { param1: '12345', param2: 55 } }), ModuleService)).toThrow('Configuration for module myModule is invalid. Make sure the module is correctly configured. Error: myModule.param2(minimum): Number needs to be greater than or equal to 100');
    }
    {
        expect(() => getMyServiceFor(myAppModule.configure({ myModule: { param1: '12345', param2: '55' } }), ModuleService)).toThrow('Configuration for module myModule is invalid. Make sure the module is correctly configured. Error: myModule.param2(minimum): Number needs to be greater than or equal to 100');
    }
    {
        const myService = getMyServiceFor(myAppModule.configure({ myModule: { param1: '12345', param2: 100 } }), ModuleService);
        expect(myService.config).toEqual({ param1: '12345', param2: 100 });
    }
    {
        //@deepkit/type does automatically soft-type casting
        const myService = getMyServiceFor(myAppModule.configure({ myModule: { param1: '12345', param2: '100' } }), ModuleService);
        expect(myService.config).toEqual({ param1: '12345', param2: 100 });
    }
});
test('basic configured', () => {
    expect(new MyService({ debug: true }).isDebug()).toBe(true);
    expect(new MyService({ debug: false }).isDebug()).toBe(false);
    const myConfiguredApp = myAppModule.configure({ myModule: { param1: '12345', param2: '100' } });
    {
        const myService = getMyServiceFor(myConfiguredApp, MyService);
        expect(myService.isDebug()).toBe(false);
    }
    {
        const myService = getMyServiceFor(myConfiguredApp.configure({
            debug: false
        }), MyService);
        expect(myService.isDebug()).toBe(false);
    }
    {
        const myService = getMyServiceFor(myConfiguredApp.configure({
            debug: true
        }), MyService);
        expect(myService.isDebug()).toBe(true);
    }
    {
        const myService2 = getMyServiceFor(myConfiguredApp.configure({
            debug: false
        }), MyService2);
        expect(myService2.debug).toBe(false);
    }
    {
        const myService2 = getMyServiceFor(myConfiguredApp.configure({
            debug: true
        }), MyService2);
        expect(myService2.debug).toBe(true);
    }
});
test('config inheritance', () => {
    const appModule = new AppModule({
        providers: [
            MyService,
            MyService2,
        ],
        imports: [
            MyModule.configure({ param1: '12345' }),
        ],
        config: appModuleConfig,
    });
    expect(() => appModule.getImports()[0].getConfig()).toThrow('Configuration for module myModule is invalid. Make sure the module is correctly configured. Error: myModule.param2(required): Required value is undefined');
    expect(appModule.configure({ myModule: { param2: 555 } }).getImports()[0].getConfig()).toEqual({ param1: '12345', param2: 555 });
});
test('config inheritance', () => {
    const appModule = new AppModule({
        providers: [
            MyService,
            MyService2,
        ],
        imports: [
            MyModule.configure({ param1: '12345' }),
        ],
        config: appModuleConfig,
    });
    expect(() => appModule.getImports()[0].getConfig()).toThrow('Configuration for module myModule is invalid. Make sure the module is correctly configured. Error: myModule.param2(required): Required value is undefined');
    expect(appModule.configure({ myModule: { param2: 555 } }).getImports()[0].getConfig()).toEqual({ param1: '12345', param2: 555 });
});
test('configured provider', () => {
    class Transporter {
    }
    class Logger {
        constructor() {
            this.transporter = [];
        }
        addTransport(transport) {
            this.transporter.push(transport);
        }
    }
    const appModule = new AppModule({
        providers: [
            Transporter,
            Logger,
        ],
    });
    {
        const fork = appModule.clone();
        fork.setupProvider(Logger).addTransport('first').addTransport('second');
        expect(appModule.getConfiguredProviderRegistry().get(Logger).length).toBe(0);
        expect(fork.getConfiguredProviderRegistry().get(Logger).length).toBe(2);
        const clone = fork.clone();
        expect(clone.getConfiguredProviderRegistry().get(Logger).length).toBe(2);
    }
    {
        const logger = new ServiceContainer(appModule.setup((module) => {
            module.setupProvider(Logger).addTransport('first').addTransport('second');
        })).getInjectorFor(appModule).get(Logger);
        expect(logger.transporter).toEqual(['first', 'second']);
    }
    {
        const logger = new ServiceContainer(appModule.setup((module) => {
            module.setupProvider(Logger).transporter = ['first', 'second', 'third'];
        })).getInjectorFor(appModule).get(Logger);
        expect(logger.transporter).toEqual(['first', 'second', 'third']);
    }
    {
        const logger = new ServiceContainer(appModule.setup((module) => {
            module.setupProvider(Logger).addTransport(new Transporter);
        })).getInjectorFor(appModule).get(Logger);
        expect(logger.transporter[0] instanceof Transporter).toBe(true);
    }
    {
        const logger = new ServiceContainer(appModule.setup((module) => {
            module.setupProvider(Logger).addTransport(injectorReference(Transporter));
        })).getInjectorFor(appModule).get(Logger);
        expect(logger.transporter[0] instanceof Transporter).toBe(true);
    }
    {
        const logger = new ServiceContainer(appModule).getInjectorFor(appModule).get(Logger);
        expect(logger.transporter).toEqual([]);
    }
});
//# sourceMappingURL=module.spec.js.map