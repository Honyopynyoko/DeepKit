"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrokerDirectClient = exports.BrokerClient = exports.BrokerKeyValue = exports.BrokerChannel = void 0;
const bson_1 = require("@deepkit/bson");
const core_1 = require("@deepkit/core");
const core_rxjs_1 = require("@deepkit/core-rxjs");
const rpc_1 = require("@deepkit/rpc");
const type_1 = require("@deepkit/type");
const model_1 = require("./model");
class BrokerChannel {
    constructor(channel, decoratorOrSchema, client) {
        this.channel = channel;
        this.decoratorOrSchema = decoratorOrSchema;
        this.client = client;
        this.listener = 0;
        this.callbacks = [];
        this.wrapped = false;
        const extracted = this.getPubSubMessageSchema(decoratorOrSchema);
        this.wrapped = extracted.wrapped;
        this.schema = extracted.schema;
        this.decoder = bson_1.getBSONDecoder(this.schema);
    }
    getPubSubMessageSchema(decoratorOrSchema) {
        var _a;
        if (type_1.isFieldDecorator(decoratorOrSchema)) {
            const propertySchema = (_a = decoratorOrSchema)._lastPropertySchema || (_a._lastPropertySchema = decoratorOrSchema.buildPropertySchema('v'));
            const schema = propertySchema.type === 'class' ? propertySchema.getResolvedClassSchema() : type_1.t.schema({ v: decoratorOrSchema });
            const wrapped = propertySchema.type !== 'class';
            return { schema, wrapped };
        }
        return { schema: type_1.getClassSchema(decoratorOrSchema), wrapped: false };
    }
    async publish(data) {
        const serializer = bson_1.getBSONSerializer(this.schema);
        const v = this.wrapped ? serializer({ v: data }) : serializer(data);
        await this.client.sendMessage(model_1.BrokerType.Publish, model_1.brokerPublish, { c: this.channel, v: v })
            .ackThenClose();
        return undefined;
    }
    next(data) {
        for (const callback of this.callbacks) {
            callback(data);
        }
    }
    async subscribe(callback) {
        const parsedCallback = (next) => {
            const parsed = this.decoder(next);
            callback(this.wrapped ? parsed.v : parsed);
        };
        this.listener++;
        this.callbacks.push(parsedCallback);
        if (this.listener === 1) {
            await this.client.sendMessage(model_1.BrokerType.Subscribe, model_1.brokerSubscribe, { c: this.channel })
                .ackThenClose();
        }
        return new core_rxjs_1.AsyncSubscription(async () => {
            this.listener--;
            core_1.arrayRemoveItem(this.callbacks, parsedCallback);
            if (this.listener === 0) {
                await this.client.sendMessage(model_1.BrokerType.Unsubscribe, model_1.brokerSubscribe, { c: this.channel })
                    .ackThenClose();
            }
        });
    }
}
exports.BrokerChannel = BrokerChannel;
class BrokerKeyValue {
    constructor(key, schema, client) {
        this.key = key;
        this.schema = schema;
        this.client = client;
        this.serializer = bson_1.getBSONSerializer(schema);
        this.decoder = bson_1.getBSONDecoder(schema);
    }
    async set(data) {
        await this.client.sendMessage(model_1.BrokerType.Set, model_1.brokerSet, { n: this.key, v: this.serializer(data) }).ackThenClose();
        return undefined;
    }
    async get() {
        const v = await this.getOrUndefined();
        if (v !== undefined)
            return v;
        throw new Error(`No value for key ${this.key} found`);
    }
    async delete() {
        await this.client.sendMessage(model_1.BrokerType.Delete, model_1.brokerGet, { n: this.key }).ackThenClose();
        return true;
    }
    async getOrUndefined() {
        const first = await this.client.sendMessage(model_1.BrokerType.Get, model_1.brokerGet, { n: this.key }).firstThenClose(model_1.BrokerType.ResponseGet);
        if (first.buffer && first.buffer.byteLength > first.bodyOffset) {
            return this.decoder(first.buffer, first.bodyOffset);
        }
        return undefined;
    }
}
exports.BrokerKeyValue = BrokerKeyValue;
class BrokerClient extends rpc_1.RpcBaseClient {
    constructor() {
        super(...arguments);
        this.activeChannels = new Map();
        this.knownEntityFields = new Map();
        this.publishedEntityFields = new Map();
        /**
         * On first getEntityFields() call we check if entityFieldsReceived is true. If not
         * we connect and load all available entity-fields from the server and start
         * streaming all changes to the entity-fields directly to our entityFields map.
         */
        this.entityFieldsReceived = false;
    }
    async getEntityFields(classSchema) {
        const entityName = 'string' === typeof classSchema ? classSchema : classSchema.getName();
        if (!this.entityFieldsReceived) {
            this.entityFieldsReceived = true;
            this.entityFieldsPromise = core_1.asyncOperation(async (resolve) => {
                const subject = this.sendMessage(model_1.BrokerType.AllEntityFields);
                const answer = await subject.waitNextMessage();
                subject.release();
                if (answer.type === model_1.BrokerType.AllEntityFields) {
                    for (const body of answer.getBodies()) {
                        const fields = body.parseBody(model_1.brokerEntityFields);
                        this.knownEntityFields.set(fields.name, fields.fields);
                    }
                }
                this.entityFieldsPromise = undefined;
                resolve();
            });
        }
        if (this.entityFieldsPromise) {
            await this.entityFieldsPromise;
        }
        return this.knownEntityFields.get(entityName) || [];
    }
    onMessage(message) {
        if (message.routeType === 1 /* server */) {
            if (message.type === model_1.BrokerType.EntityFields) {
                const fields = message.parseBody(model_1.brokerEntityFields);
                this.knownEntityFields.set(fields.name, fields.fields);
                this.transporter.send(rpc_1.createRpcMessage(message.id, model_1.BrokerType.Ack, undefined, undefined, 1 /* server */));
            }
            else if (message.type === model_1.BrokerType.ResponseSubscribeMessage) {
                const body = message.parseBody(model_1.brokerResponseSubscribeMessage);
                const channel = this.activeChannels.get(body.c);
                if (!channel)
                    return;
                channel.next(body.v);
            }
        }
        else {
            super.onMessage(message);
        }
    }
    async publishEntityFields(classSchema, fields) {
        const entityName = 'string' === typeof classSchema ? classSchema : classSchema.getName();
        let store = this.publishedEntityFields.get(entityName);
        if (!store) {
            store = new Map;
            this.publishedEntityFields.set(entityName, store);
        }
        let changed = false;
        const newFields = [];
        for (const field of fields) {
            const v = store.get(field);
            if (v === undefined) {
                changed = true;
                newFields.push(field);
            }
            ;
            store.set(field, v === undefined ? 1 : v + 1);
        }
        if (changed) {
            const response = await this.sendMessage(model_1.BrokerType.PublishEntityFields, model_1.brokerEntityFields, { name: entityName, fields: newFields }).firstThenClose(model_1.BrokerType.EntityFields, model_1.brokerEntityFields);
            this.knownEntityFields.set(response.name, response.fields);
        }
        return new core_rxjs_1.AsyncSubscription(async () => {
            if (!store)
                return;
            const unsubscribed = [];
            for (const field of fields) {
                let v = store.get(field);
                if (v === undefined)
                    throw new Error(`Someone deleted our field ${field}`);
                v--;
                if (v === 0) {
                    store.delete(field);
                    unsubscribed.push(field);
                    //we can't remove it from knownEntityFields, because we don't know whether another
                    //its still used by another client.
                }
                else {
                    store.set(field, v);
                }
            }
            if (unsubscribed.length) {
                const response = await this.sendMessage(model_1.BrokerType.UnsubscribeEntityFields, model_1.brokerEntityFields, { name: entityName, fields: unsubscribed }).firstThenClose(model_1.BrokerType.EntityFields, model_1.brokerEntityFields);
                this.knownEntityFields.set(response.name, response.fields);
            }
        });
    }
    /**
     * Tries to lock an id on the broker. If the id is already locked, it returns immediately undefined without locking anything
     *
     * ttl (time to life) defines how long the given lock is allowed to stay active. Per default each lock is automatically unlocked
     * after 30 seconds. If you haven't released the lock until then, another lock acquisition is allowed to receive it anyways.
     * ttl of 0 disables ttl and keeps the lock alive until you manually unlock it (or the process dies).
    */
    async tryLock(id, ttl = 30) {
        const subject = this.sendMessage(model_1.BrokerType.TryLock, model_1.brokerLock, { id, ttl });
        const message = await subject.waitNextMessage();
        if (message.type === model_1.BrokerType.ResponseLockFailed) {
            subject.release();
            return undefined;
        }
        if (message.type === model_1.BrokerType.ResponseLock) {
            return new core_rxjs_1.AsyncSubscription(async () => {
                await subject.send(model_1.BrokerType.Unlock).ackThenClose();
            });
        }
        throw new Error(`Invalid message returned. Expected Lock, but got ${message.type}`);
    }
    /**
     * Locks an id on the broker. If the id is already locked, it waits until it is released. If timeout is specified,
     * the lock acquisition should take maximum `timeout` seconds. 0 means it waits without limit.
     *
     * ttl (time to life) defines how long the given lock is allowed to stay active. Per default each lock is automatically unlocked
     * after 30 seconds. If you haven't released the lock until then, another lock acquisition is allowed to receive it anyways.
     * ttl of 0 disables ttl and keeps the lock alive until you manually unlock it (or the process dies).
    */
    async lock(id, ttl = 30, timeout = 0) {
        const subject = this.sendMessage(model_1.BrokerType.Lock, model_1.brokerLock, { id, ttl, timeout });
        await subject.waitNext(model_1.BrokerType.ResponseLock); //or throw error
        return new core_rxjs_1.AsyncSubscription(async () => {
            await subject.send(model_1.BrokerType.Unlock).ackThenClose();
            subject.release();
        });
    }
    async isLocked(id) {
        const subject = this.sendMessage(model_1.BrokerType.IsLocked, model_1.brokerLockId, { id });
        const lock = await subject.firstThenClose(model_1.BrokerType.ResponseIsLock, model_1.brokerResponseIsLock);
        return lock.v;
    }
    channel(channel, decoratorOrSchema) {
        let brokerChannel = this.activeChannels.get(channel);
        if (!brokerChannel) {
            brokerChannel = new BrokerChannel(channel, decoratorOrSchema, this);
            this.activeChannels.set(channel, brokerChannel);
        }
        return brokerChannel;
    }
    async getRawOrUndefined(id) {
        const first = await this.sendMessage(model_1.BrokerType.Get, model_1.brokerGet, { n: id }).firstThenClose(model_1.BrokerType.ResponseGet);
        if (first.buffer && first.buffer.byteLength > first.bodyOffset) {
            return first.buffer.slice(first.bodyOffset);
        }
        return undefined;
    }
    async getRaw(id) {
        const v = await this.getRawOrUndefined(id);
        if (v === undefined)
            throw new Error(`Key ${id} is undefined`);
        return v;
    }
    async setRaw(id, data) {
        await this.sendMessage(model_1.BrokerType.Set, model_1.brokerSet, { n: id, v: data })
            .ackThenClose();
        return undefined;
    }
    key(key, schema) {
        return new BrokerKeyValue(key, type_1.getClassSchema(schema), this);
    }
    async getIncrement(id) {
        const v = await this.getRaw(id);
        const view = new DataView(v.buffer, v.byteOffset, v.byteLength);
        return view.getFloat64(0, true);
    }
    async increment(id, value) {
        const response = await this.sendMessage(model_1.BrokerType.Increment, model_1.brokerIncrement, { n: id, v: value })
            .waitNext(model_1.BrokerType.ResponseIncrement, model_1.brokerResponseIncrement);
        return response.v;
    }
    async delete(id) {
        await this.sendMessage(model_1.BrokerType.Delete, model_1.brokerDelete, { n: id })
            .ackThenClose();
        return undefined;
    }
}
exports.BrokerClient = BrokerClient;
class BrokerDirectClient extends BrokerClient {
    constructor(rpcKernel) {
        super(new rpc_1.RpcDirectClientAdapter(rpcKernel));
    }
}
exports.BrokerDirectClient = BrokerDirectClient;
//# sourceMappingURL=client.js.map