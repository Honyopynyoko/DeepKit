"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrokerKernel = exports.BrokerState = exports.BrokerConnection = void 0;
const core_1 = require("@deepkit/core");
const rpc_1 = require("@deepkit/rpc");
const model_1 = require("./model");
class BrokerConnection extends rpc_1.RpcKernelBaseConnection {
    constructor(transportWriter, connections, state) {
        super(transportWriter, connections);
        this.connections = connections;
        this.state = state;
        this.subscribedChannels = [];
        this.locks = new Map();
        this.replies = new Map();
    }
    close() {
        super.close();
        for (const c of this.subscribedChannels) {
            this.state.unsubscribe(c, this);
        }
        for (const lock of this.locks.values()) {
            lock.unlock();
        }
    }
    async sendEntityFields(name) {
        const fields = this.state.getEntityFields(name);
        const promises = [];
        for (const connection of this.connections.connections) {
            if (connection === this)
                continue;
            promises.push(connection.sendMessage(model_1.BrokerType.EntityFields, model_1.brokerEntityFields, { name, fields }).ackThenClose());
        }
        await Promise.all(promises);
    }
    async onMessage(message, response) {
        switch (message.type) {
            case model_1.BrokerType.PublishEntityFields: {
                const body = message.parseBody(model_1.brokerEntityFields);
                const changed = this.state.publishEntityFields(body.name, body.fields);
                if (changed) {
                    await this.sendEntityFields(body.name);
                }
                response.reply(model_1.BrokerType.EntityFields, model_1.brokerEntityFields, { name: body.name, fields: this.state.getEntityFields(body.name) });
                break;
            }
            case model_1.BrokerType.UnsubscribeEntityFields: {
                const body = message.parseBody(model_1.brokerEntityFields);
                const changed = this.state.unsubscribeEntityFields(body.name, body.fields);
                if (changed) {
                    await this.sendEntityFields(body.name);
                }
                response.reply(model_1.BrokerType.EntityFields, model_1.brokerEntityFields, { name: body.name, fields: this.state.getEntityFields(body.name) });
                break;
            }
            case model_1.BrokerType.AllEntityFields: {
                const composite = response.composite(model_1.BrokerType.AllEntityFields);
                for (const name of this.state.entityFields.keys()) {
                    composite.add(model_1.BrokerType.EntityFields, model_1.brokerEntityFields, { name, fields: this.state.getEntityFields(name) });
                }
                composite.send();
                break;
            }
            case model_1.BrokerType.Lock: {
                const body = message.parseBody(model_1.brokerLock);
                this.state.lock(body.id, body.ttl, body.timeout).then(lock => {
                    this.locks.set(message.id, lock);
                    response.reply(model_1.BrokerType.ResponseLock);
                }, (error) => {
                    response.error(error);
                });
                break;
            }
            case model_1.BrokerType.Unlock: {
                const lock = this.locks.get(message.id);
                if (lock) {
                    this.locks.delete(message.id);
                    lock.unlock();
                    response.ack();
                }
                else {
                    response.error(new Error('Unknown lock for message id ' + message.id));
                }
                break;
            }
            case model_1.BrokerType.IsLocked: {
                const body = message.parseBody(model_1.brokerLockId);
                response.reply(model_1.BrokerType.ResponseIsLock, model_1.brokerResponseIsLock, { v: this.state.isLocked(body.id) });
                break;
            }
            case model_1.BrokerType.TryLock: {
                const body = message.parseBody(model_1.brokerLock);
                this.state.tryLock(body.id, body.ttl).then(lock => {
                    if (lock) {
                        this.locks.set(message.id, lock);
                        response.reply(model_1.BrokerType.ResponseLock);
                    }
                    else {
                        response.reply(model_1.BrokerType.ResponseLockFailed);
                    }
                });
                break;
            }
            case model_1.BrokerType.Subscribe: {
                const body = message.parseBody(model_1.brokerSubscribe);
                this.state.subscribe(body.c, this);
                this.subscribedChannels.push(body.c);
                response.ack();
                break;
            }
            case model_1.BrokerType.Unsubscribe: {
                const body = message.parseBody(model_1.brokerSubscribe);
                this.state.unsubscribe(body.c, this);
                core_1.arrayRemoveItem(this.subscribedChannels, body.c);
                response.ack();
                break;
            }
            case model_1.BrokerType.Publish: {
                const body = message.parseBody(model_1.brokerPublish);
                this.state.publish(body.c, body.v);
                response.ack();
                break;
            }
            case model_1.BrokerType.Set: {
                const body = message.parseBody(model_1.brokerSet);
                this.state.set(body.n, body.v);
                response.ack();
                break;
            }
            case model_1.BrokerType.Increment: {
                const body = message.parseBody(model_1.brokerIncrement);
                const newValue = this.state.increment(body.n, body.v);
                response.reply(model_1.BrokerType.ResponseIncrement, model_1.brokerResponseIncrement, { v: newValue });
                break;
            }
            case model_1.BrokerType.Delete: {
                const body = message.parseBody(model_1.brokerDelete);
                this.state.delete(body.n);
                response.ack();
                break;
            }
            case model_1.BrokerType.Get: {
                const body = message.parseBody(model_1.brokerGet);
                response.reply(model_1.BrokerType.ResponseGet, this.state.get(body.n));
                break;
            }
        }
    }
}
exports.BrokerConnection = BrokerConnection;
class BrokerState {
    constructor() {
        this.setStore = new Map();
        this.subscriptions = new Map();
        this.entityFields = new Map();
        this.locker = new core_1.ProcessLocker();
    }
    getEntityFields(name) {
        var _a;
        return Array.from(((_a = this.entityFields.get(name)) === null || _a === void 0 ? void 0 : _a.keys()) || []);
    }
    publishEntityFields(name, fields) {
        let store = this.entityFields.get(name);
        if (!store) {
            store = new Map();
            this.entityFields.set(name, store);
        }
        let changed = false;
        for (const field of fields) {
            const v = store.get(field);
            if (v === undefined) {
                store.set(field, 1);
                changed = true;
            }
            else {
                store.set(field, v + 1);
            }
        }
        return changed;
    }
    unsubscribeEntityFields(name, fields) {
        let store = this.entityFields.get(name);
        if (!store)
            return;
        let changed = false;
        for (const field of fields) {
            let v = store.get(field);
            if (v === undefined)
                continue;
            v--;
            if (v === 0) {
                store.delete(field);
                changed = true;
                continue;
            }
            store.set(field, v);
        }
        return changed;
    }
    lock(id, ttl, timeout = 0) {
        return this.locker.acquireLock(id, ttl, timeout);
    }
    tryLock(id, ttl = 0) {
        return this.locker.tryLock(id, ttl);
    }
    isLocked(id) {
        return this.locker.isLocked(id);
    }
    unsubscribe(channel, connection) {
        const subscriptions = this.subscriptions.get(channel);
        if (!subscriptions)
            return;
        core_1.arrayRemoveItem(subscriptions, connection);
    }
    subscribe(channel, connection) {
        let subscriptions = this.subscriptions.get(channel);
        if (!subscriptions) {
            subscriptions = [];
            this.subscriptions.set(channel, subscriptions);
        }
        subscriptions.push(connection);
    }
    publish(channel, v) {
        const subscriptions = this.subscriptions.get(channel);
        if (!subscriptions)
            return;
        const message = rpc_1.createRpcMessage(0, model_1.BrokerType.ResponseSubscribeMessage, model_1.brokerResponseSubscribeMessage, { c: channel, v: v }, 1 /* server */);
        for (const connection of subscriptions) {
            connection.writer.write(message);
        }
    }
    set(id, data) {
        this.setStore.set(id, data);
    }
    increment(id, v) {
        const buffer = this.setStore.get(id);
        const float64 = buffer ? new Float64Array(buffer.buffer, buffer.byteOffset) : new Float64Array(1);
        float64[0] += v || 1;
        if (!buffer)
            this.setStore.set(id, new Uint8Array(float64.buffer));
        return float64[0];
    }
    get(id) {
        return this.setStore.get(id);
    }
    delete(id) {
        this.setStore.delete(id);
    }
}
exports.BrokerState = BrokerState;
class BrokerKernel extends rpc_1.RpcKernel {
    constructor() {
        super(...arguments);
        this.state = new BrokerState;
        this.connections = new rpc_1.RpcKernelConnections();
    }
    createConnection(writer) {
        return new BrokerConnection(writer, this.connections, this.state);
    }
}
exports.BrokerKernel = BrokerKernel;
//# sourceMappingURL=kernel.js.map