import { BSONDecoder, BSONSerializer } from '@deepkit/bson';
import { ClassType } from '@deepkit/core';
import { AsyncSubscription } from '@deepkit/core-rxjs';
import { RpcBaseClient, RpcMessage } from '@deepkit/rpc';
import { ClassSchema, FieldDecoratorResult } from '@deepkit/type';
import { BrokerKernel } from './kernel';
export declare class BrokerChannel<T> {
    channel: string;
    protected decoratorOrSchema: FieldDecoratorResult<T> | ClassSchema<T> | ClassType<T>;
    protected client: BrokerClient;
    protected listener: number;
    protected callbacks: ((next: Uint8Array) => void)[];
    protected wrapped: boolean;
    protected schema: ClassSchema;
    protected decoder: (bson: Uint8Array) => any;
    constructor(channel: string, decoratorOrSchema: FieldDecoratorResult<T> | ClassSchema<T> | ClassType<T>, client: BrokerClient);
    protected getPubSubMessageSchema<T>(decoratorOrSchema: FieldDecoratorResult<T> | ClassSchema<T> | ClassType<T>): {
        schema: ClassSchema;
        wrapped: boolean;
    };
    publish(data: T): Promise<undefined>;
    next(data: Uint8Array): void;
    subscribe(callback: (next: T) => void): Promise<AsyncSubscription>;
}
export declare class BrokerKeyValue<T> {
    protected key: string;
    protected schema: ClassSchema<T>;
    protected client: BrokerClient;
    protected serializer: BSONSerializer;
    protected decoder: BSONDecoder<T>;
    constructor(key: string, schema: ClassSchema<T>, client: BrokerClient);
    set(data: T): Promise<undefined>;
    get(): Promise<T>;
    delete(): Promise<boolean>;
    getOrUndefined(): Promise<T | undefined>;
}
export declare class BrokerClient extends RpcBaseClient {
    protected activeChannels: Map<string, BrokerChannel<any>>;
    protected knownEntityFields: Map<string, string[]>;
    protected publishedEntityFields: Map<string, Map<string, number>>;
    /**
     * On first getEntityFields() call we check if entityFieldsReceived is true. If not
     * we connect and load all available entity-fields from the server and start
     * streaming all changes to the entity-fields directly to our entityFields map.
     */
    protected entityFieldsReceived: boolean;
    protected entityFieldsPromise?: Promise<void>;
    getEntityFields(classSchema: ClassSchema | string): Promise<string[]>;
    protected onMessage(message: RpcMessage): void;
    publishEntityFields<T>(classSchema: ClassSchema | string, fields: string[]): Promise<AsyncSubscription>;
    /**
     * Tries to lock an id on the broker. If the id is already locked, it returns immediately undefined without locking anything
     *
     * ttl (time to life) defines how long the given lock is allowed to stay active. Per default each lock is automatically unlocked
     * after 30 seconds. If you haven't released the lock until then, another lock acquisition is allowed to receive it anyways.
     * ttl of 0 disables ttl and keeps the lock alive until you manually unlock it (or the process dies).
    */
    tryLock(id: string, ttl?: number): Promise<AsyncSubscription | undefined>;
    /**
     * Locks an id on the broker. If the id is already locked, it waits until it is released. If timeout is specified,
     * the lock acquisition should take maximum `timeout` seconds. 0 means it waits without limit.
     *
     * ttl (time to life) defines how long the given lock is allowed to stay active. Per default each lock is automatically unlocked
     * after 30 seconds. If you haven't released the lock until then, another lock acquisition is allowed to receive it anyways.
     * ttl of 0 disables ttl and keeps the lock alive until you manually unlock it (or the process dies).
    */
    lock(id: string, ttl?: number, timeout?: number): Promise<AsyncSubscription>;
    isLocked(id: string): Promise<boolean>;
    channel<T>(channel: string, decoratorOrSchema: FieldDecoratorResult<T> | ClassSchema<T> | ClassType<T>): BrokerChannel<T>;
    getRawOrUndefined<T>(id: string): Promise<Uint8Array | undefined>;
    getRaw<T>(id: string): Promise<Uint8Array>;
    setRaw<T>(id: string, data: Uint8Array): Promise<undefined>;
    key<T>(key: string, schema: ClassSchema<T> | ClassType<T>): BrokerKeyValue<T>;
    getIncrement<T>(id: string): Promise<number>;
    increment<T>(id: string, value?: number): Promise<number>;
    delete<T>(id: string): Promise<undefined>;
}
export declare class BrokerDirectClient extends BrokerClient {
    constructor(rpcKernel: BrokerKernel);
}
