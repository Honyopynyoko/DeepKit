"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserialize = exports.parseArray = exports.parseObject = exports.ParserV3 = exports.ParserV2 = exports.BaseParser = exports.decodeUTF8Parser = void 0;
const utils_1 = require("./utils");
const strings_1 = require("./strings");
const type_1 = require("@deepkit/type");
const model_1 = require("./model");
/**
 * This creates a JS string from a utf8 byte buffer. This is the fastest way possible to create
 * small strings (< 14chars). Everything else should be cached or created by Buffer.toString('utf8').
 */
function decodeUTF8Parser(parser, size = parser.size - parser.offset) {
    const end = parser.offset + size;
    let s = strings_1.decodeUTF8(parser.buffer, parser.offset, end - 1);
    parser.offset = end;
    return s;
}
exports.decodeUTF8Parser = decodeUTF8Parser;
/**
 * This is the (slowest) base parser which parses all property names as utf8.
 */
class BaseParser {
    constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
        this.size = buffer.byteLength;
        this.dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    peek(elementType, property) {
        const offset = this.offset;
        const v = this.parse(elementType, property);
        this.offset = offset;
        return v;
    }
    parse(elementType, property) {
        switch (elementType) {
            case 2 /* STRING */:
                return this.parseString();
            case 1 /* NUMBER */:
                return this.parseNumber();
            case 7 /* OID */:
                return this.parseOid();
            case 16 /* INT */:
                return this.parseInt();
            case 9 /* DATE */:
                return this.parseDate();
            case 18 /* LONG */:
            case 17 /* TIMESTAMP */:
                return this.parseLong();
            case 8 /* BOOLEAN */:
                return this.parseBoolean();
            case 10 /* NULL */:
                return null;
            case 6 /* UNDEFINED */:
                return undefined;
            case 5 /* BINARY */:
                return this.parseBinary(property);
            case 11 /* REGEXP */:
                const source = this.eatString(this.stringSize());
                const options = this.eatString(this.stringSize());
                return new RegExp(source, options.replace('s', 'g'));
            case 3 /* OBJECT */:
                return parseObject(this);
            case 4 /* ARRAY */:
                return parseArray(this);
            default:
                throw new Error('Unsupported BSON type ' + elementType);
        }
    }
    parseBoolean() {
        return this.eatByte() === 1;
    }
    parseLong() {
        const lowBits = this.eatUInt32();
        const highBits = this.eatUInt32();
        return BigInt(highBits) * BigInt(utils_1.TWO_PWR_32_DBL_N) + (BigInt(lowBits >>> 0));
    }
    parseString() {
        return this.eatString(this.eatUInt32());
    }
    parseBinary(property) {
        let size = this.eatUInt32();
        const subType = this.eatByte();
        if (subType === utils_1.BSON_BINARY_SUBTYPE_UUID) {
            const nextPosition = this.offset + size;
            const v = this.parseUUID();
            this.offset = nextPosition;
            return v;
        }
        if (subType === utils_1.BSON_BINARY_SUBTYPE_BIGINT) {
            const nextPosition = this.offset + size;
            const v = this.parseBigInt(size);
            this.offset = nextPosition;
            return v;
        }
        if (subType === utils_1.BSON_BINARY_SUBTYPE_BYTE_ARRAY) {
            size = this.eatUInt32();
        }
        const b = this.buffer.slice(this.offset, this.offset + size);
        this.seek(size);
        if (property && property.type === 'arrayBuffer') {
            return type_1.nodeBufferToArrayBuffer(b);
        }
        if (property && property.isTypedArray) {
            const type = type_1.typedArrayNamesMap.get(property.type);
            return new type(type_1.nodeBufferToArrayBuffer(b));
        }
        return b;
    }
    parseNumber() {
        return this.eatDouble();
    }
    parseOid() {
        const offset = this.offset, b = this.buffer;
        let o = model_1.hexTable[b[offset]]
            + model_1.hexTable[b[offset + 1]]
            + model_1.hexTable[b[offset + 2]]
            + model_1.hexTable[b[offset + 3]]
            + model_1.hexTable[b[offset + 4]]
            + model_1.hexTable[b[offset + 5]]
            + model_1.hexTable[b[offset + 6]]
            + model_1.hexTable[b[offset + 7]]
            + model_1.hexTable[b[offset + 8]]
            + model_1.hexTable[b[offset + 9]]
            + model_1.hexTable[b[offset + 10]]
            + model_1.hexTable[b[offset + 11]];
        this.seek(12);
        return o;
    }
    parseBigInt(size) {
        let s = '';
        for (let i = 0; i < size; i++) {
            s += model_1.hexTable[this.buffer[this.offset + i]];
        }
        return BigInt('0x' + s);
    }
    parseUUID() {
        //e.g. bef8de96-41fe-442f-b70c-c3a150f8c96c
        //         4      2    2    2       6
        const offset = this.offset, b = this.buffer;
        let o = model_1.hexTable[b[offset]]
            + model_1.hexTable[b[offset + 1]]
            + model_1.hexTable[b[offset + 2]]
            + model_1.hexTable[b[offset + 3]]
            + '-'
            + model_1.hexTable[b[offset + 4]]
            + model_1.hexTable[b[offset + 5]]
            + '-'
            + model_1.hexTable[b[offset + 6]]
            + model_1.hexTable[b[offset + 7]]
            + '-'
            + model_1.hexTable[b[offset + 8]]
            + model_1.hexTable[b[offset + 9]]
            + '-'
            + model_1.hexTable[b[offset + 10]]
            + model_1.hexTable[b[offset + 11]]
            + model_1.hexTable[b[offset + 12]]
            + model_1.hexTable[b[offset + 13]]
            + model_1.hexTable[b[offset + 14]]
            + model_1.hexTable[b[offset + 15]];
        this.seek(16);
        return o;
    }
    parseInt() {
        return this.eatInt32();
    }
    parseDate() {
        const lowBits = this.eatUInt32();
        const highBits = this.eatUInt32();
        return new Date(highBits * utils_1.TWO_PWR_32_DBL_N + (lowBits >>> 0));
    }
    peekUInt32() {
        return this.dataView.getUint32(this.offset, true);
    }
    /**
     * Returns the size including \0.
     */
    stringSize() {
        let end = this.offset;
        while (this.buffer[end] !== 0)
            end++;
        end++; //null
        return end - this.offset;
    }
    eatObjectPropertyName() {
        let end = this.offset;
        while (this.buffer[end] !== 0)
            end++;
        const s = strings_1.decodeUTF8(this.buffer, this.offset, end);
        this.offset = end + 1;
        return s;
    }
    seek(size) {
        this.offset += size;
    }
    eatByte() {
        return this.buffer[this.offset++];
    }
    eatInt32() {
        this.offset += 4;
        return this.dataView.getInt32(this.offset - 4, true);
    }
    eatUInt32() {
        this.offset += 4;
        return this.dataView.getUint32(this.offset - 4, true);
    }
    eatDouble() {
        this.offset += 8;
        return this.dataView.getFloat64(this.offset - 8, true);
    }
    /**
     * Size includes the \0. If not existend, increase by 1.
     */
    eatString(size) {
        this.offset += size;
        return strings_1.decodeUTF8(this.buffer, this.offset - size, this.offset - 1);
    }
}
exports.BaseParser = BaseParser;
const stringParser = strings_1.buildStringDecoder(32);
/**
 * This is a general purpose Parser assuming ascii names as property names.
 * It falls back automatically to UTF8 when a UTF8 byte was found.
 * This is way faster than BaseParser when property names are mainly ascii (which is usually the case).
 */
class ParserV2 extends BaseParser {
    eatObjectPropertyName() {
        let end = this.offset;
        let simple = true;
        let string = '';
        while (this.buffer[end] !== 0) {
            if (this.buffer[end] > 127) {
                simple = false;
            }
            if (simple) {
                string += String.fromCharCode(this.buffer[end]);
            }
            end++;
        }
        if (simple) {
            //do simple ascii
            this.offset = end + 1;
            return string;
        }
        const s = stringParser(this.buffer, this.offset, end);
        this.offset = end + 1;
        return s;
    }
    eatString(size) {
        // const s = stringParser(this.buffer, this.offset, this.offset + size);
        let s = '';
        if (size > 64 && 'undefined' !== typeof Buffer && 'function' === typeof Buffer.from) {
            s = Buffer.from(this.buffer.buffer, this.buffer.byteOffset + this.offset, size - 1).toString('utf8');
        }
        else {
            s = stringParser(this.buffer, this.offset, this.offset + size);
        }
        this.offset += size;
        return s;
    }
}
exports.ParserV2 = ParserV2;
const decoder = new TextDecoder('utf8');
class ParserV3 extends BaseParser {
    eatObjectPropertyName() {
        let end = this.offset;
        let simple = true;
        while (this.buffer[end] !== 0) {
            if (this.buffer[end] > 127)
                simple = false;
            end++;
        }
        if (simple) {
            //do simple ascii
            const s = String.fromCharCode.apply(String, this.buffer.slice(this.offset, end));
            this.offset = end + 1;
            return s;
        }
        const s = decoder.decode(this.buffer.slice(this.offset, end));
        this.offset = end + 1;
        return s;
    }
    eatString(size) {
        const end = this.offset + size;
        let s = decoder.decode(this.buffer.slice(this.offset, end - 1));
        this.offset = end;
        return s;
    }
}
exports.ParserV3 = ParserV3;
function parseObject(parser) {
    const result = {};
    const end = parser.eatUInt32() + parser.offset;
    while (parser.offset < end) {
        const elementType = parser.eatByte();
        if (elementType === 0)
            break;
        const name = parser.eatObjectPropertyName();
        result[name] = parser.parse(elementType);
    }
    return result;
}
exports.parseObject = parseObject;
function parseArray(parser) {
    const result = [];
    const end = parser.eatUInt32() + parser.offset;
    for (let i = 0; parser.offset < end; i++) {
        const elementType = parser.eatByte();
        if (elementType === 0)
            break;
        //arrays are represented as objects, so we skip the key name, since we have `i`
        parser.seek(utils_1.digitByteSize(i));
        result.push(parser.parse(elementType));
    }
    return result;
}
exports.parseArray = parseArray;
function deserialize(buffer, offset = 0) {
    return parseObject(new ParserV2(buffer, offset));
}
exports.deserialize = deserialize;
//# sourceMappingURL=bson-parser.js.map