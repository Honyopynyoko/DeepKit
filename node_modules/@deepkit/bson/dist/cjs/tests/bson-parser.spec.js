"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
require("reflect-metadata");
const bson_1 = __importDefault(require("bson"));
const bson_parser_1 = require("../src/bson-parser");
const type_1 = require("@deepkit/type");
const bson_jit_parser_1 = require("../src/bson-jit-parser");
const bson_serialize_1 = require("../src/bson-serialize");
const continuation_1 = require("../src/continuation");
const { deserialize, serialize } = bson_1.default;
globals_1.test('basic', () => {
    const obj = {
        id: 123,
        name: 'Peter 1',
        tags: ['a', 'b', 'c'],
        priority: 0
    };
    const bson = serialize(obj);
    const items = bson_parser_1.parseObject(new bson_parser_1.ParserV2(bson));
    globals_1.expect(items).toEqual(obj);
    globals_1.expect(continuation_1.findValueInObject(new bson_parser_1.ParserV2(bson), (elementType, name) => {
        return name === 'id';
    })).toBe(123);
    globals_1.expect(continuation_1.findValueInObject(new bson_parser_1.ParserV2(bson), (elementType, name) => {
        return elementType === 16 /* INT */;
    })).toBe(123);
    globals_1.expect(continuation_1.findValueInObject(new bson_parser_1.ParserV2(bson), (elementType, name) => {
        return elementType === 2 /* STRING */;
    })).toBe('Peter 1');
    globals_1.expect(continuation_1.findValueInObject(new bson_parser_1.ParserV2(bson), (elementType, name) => {
        return elementType === 2 /* STRING */;
    })).toBe('Peter 1');
});
globals_1.test('createBSONParser', () => {
    const obj = {
        number: 13,
        cursor: {
            firstBatch: [{ name: 'Peter' }, { name: 'Marc' }, { name: 'Bar' }],
            test: ['a', 'b', 'c']
        },
        ok: 1,
    };
    const schema = type_1.t.schema({
        number: type_1.t.number,
        cursor: type_1.t.type({
            firstBatch: type_1.t.array({
                name: type_1.t.string
            }),
            test: type_1.t.array(type_1.t.string),
        }),
        ok: type_1.t.number,
    });
    const bson = serialize(obj);
    const parsed = bson_jit_parser_1.getBSONDecoder(schema)(bson);
    globals_1.expect(parsed).toEqual(obj);
});
globals_1.test('invalidation', () => {
    const schema = type_1.t.schema({
        username: type_1.t.string
    });
    {
        globals_1.expect(bson_jit_parser_1.getBSONDecoder(schema)(serialize({ username: 'Peter', foo: 'bar' }))).toEqual({ username: 'Peter' });
    }
    {
        schema.addProperty('foo', type_1.t.string);
        const obj = { username: 'Peter', foo: 'bar' };
        globals_1.expect(bson_jit_parser_1.getBSONDecoder(schema)(serialize(obj))).toEqual(obj);
    }
});
globals_1.test('undefined array', () => {
    const schema = type_1.t.schema({
        username: type_1.t.string,
        organisations: type_1.t.array(type_1.t.string)
    });
    {
        const bson = serialize({ username: 'Peter' });
        //organisations stays undefined
        globals_1.expect(bson_jit_parser_1.getBSONDecoder(schema)(bson)).toEqual({ username: 'Peter' });
    }
    {
        const bson = serialize({ username: 'Peter', organisations: [] });
        //organisations stays undefined
        globals_1.expect(bson_jit_parser_1.getBSONDecoder(schema)(bson)).toEqual({ username: 'Peter', organisations: [] });
    }
});
globals_1.test('constructor vars', () => {
    let UserBase = class UserBase {
        constructor(name) {
            this.name = name;
            this.id = 'abc';
            this.version = 1;
        }
    };
    __decorate([
        type_1.t,
        __metadata("design:type", String)
    ], UserBase.prototype, "id", void 0);
    __decorate([
        type_1.t,
        __metadata("design:type", Number)
    ], UserBase.prototype, "version", void 0);
    UserBase = __decorate([
        __param(0, type_1.t),
        __metadata("design:paramtypes", [String])
    ], UserBase);
    class User extends UserBase {
        constructor() {
            super(...arguments);
            this.connections = 10;
        }
    }
    __decorate([
        type_1.t,
        __metadata("design:type", Number)
    ], User.prototype, "connections", void 0);
    globals_1.expect(type_1.getClassSchema(UserBase).getProperty('name').methodName).toBe('constructor');
    globals_1.expect(type_1.getClassSchema(User).getProperty('name').methodName).toBe('constructor');
    globals_1.expect(type_1.getClassSchema(User).getMethodProperties('constructor').includes(type_1.getClassSchema(User).getProperty('name'))).toBe(true);
    const bson = bson_serialize_1.getBSONSerializer(User)(new User('peter'));
    const json = deserialize(Buffer.from(bson));
    globals_1.expect(json.name).toBe('peter');
    const back = bson_jit_parser_1.getBSONDecoder(User)(bson);
    globals_1.expect(back.name).toBe('peter');
});
//# sourceMappingURL=bson-parser.spec.js.map