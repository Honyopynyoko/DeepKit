"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompilerContext = void 0;
class CompilerContext {
    constructor() {
        this.context = new Map();
        this.maxReservedVariable = 10000;
        /**
         * Code that is executed in the context, but before the actual function is generated.
         * This helps for example to initialize dynamically some context variables.
         */
        this.preCode = '';
    }
    reserveVariable(name = 'var', value) {
        for (let i = 0; i < this.maxReservedVariable; i++) {
            const candidate = name + '_' + i;
            if (!this.context.has(candidate)) {
                this.context.set(candidate, value);
                return candidate;
            }
        }
        throw new Error(`Too many context variables (max ${this.maxReservedVariable})`);
    }
    raw(functionCode) {
        return new Function(...this.context.keys(), functionCode)(...this.context.values());
    }
    build(functionCode, ...args) {
        functionCode = `
            ${this.preCode}
            return function self(${args.join(', ')}){ 
                ${functionCode}
            };
        `;
        try {
            return new Function(...this.context.keys(), functionCode)(...this.context.values());
        }
        catch (error) {
            throw new Error('Could not build function: ' + error + functionCode);
        }
    }
    buildAsync(functionCode, ...args) {
        functionCode = `
            ${this.preCode}
            return async function self(${args.join(', ')}){ 
                ${functionCode}
            };
        `;
        try {
            return new Function(...this.context.keys(), functionCode)(...this.context.values());
        }
        catch (error) {
            throw new Error('Could not build function: ' + error + functionCode);
        }
    }
}
exports.CompilerContext = CompilerContext;
//# sourceMappingURL=compiler.js.map