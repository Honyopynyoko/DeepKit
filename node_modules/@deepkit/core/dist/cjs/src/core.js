"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.inDebugMode = exports.isPrototypeOfBase = exports.isConstructable = exports.getObjectKeysSize = exports.humanBytes = exports.deletePathValue = exports.setPathValue = exports.getPathValue = exports.time = exports.collectForMicrotask = exports.mergeStack = exports.createStack = exports.mergePromiseStack = exports.asyncOperation = exports.appendObject = exports.prependObjectKeys = exports.average = exports.arrayRemoveItem = exports.arrayClear = exports.last = exports.first = exports.lastKey = exports.firstKey = exports.size = exports.empty = exports.copy = exports.sleep = exports.indexOf = exports.arrayHasItem = exports.isString = exports.isNumber = exports.isSet = exports.isUndefined = exports.isNull = exports.isArray = exports.isObject = exports.isClass = exports.isPromise = exports.isFunction = exports.prettyPrintObject = exports.changeClass = exports.stringifyValueWithType = exports.isClassInstance = exports.getClassTypeFromInstance = exports.isPlainObject = exports.typeOf = exports.applyDefaults = exports.getClassPropertyName = exports.getClassName = exports.CustomError = void 0;
const dot_prop_1 = __importDefault(require("dot-prop"));
const iterators_1 = require("./iterators");
/**
 * Makes sure the error once printed using console.log contains the actual class name.
 *
 * @example
 * ```
 * class MyApiError extends CustomerError {}
 *
 * throw MyApiError() // prints MyApiError instead of simply "Error".
 * ```
 *
 * @public
 */
class CustomError extends Error {
    constructor(message = '') {
        super(message);
        this.message = message;
        this.name = this.constructor.name;
    }
}
exports.CustomError = CustomError;
/**
 * Returns the class name either of the class definition or of the class of an instance.
 *
 * Note when code is minimized/uglified this output will change. You should disable in your compile the
 * className modification.
 *
 * @example
 * ```typescript
 * class User {}
 *
 * expect(getClassName(User)).toBe('User');
 * expect(getClassName(new User())).toBe('User');
 * ```
 *
 * @public
 */
function getClassName(classTypeOrInstance) {
    if (!classTypeOrInstance)
        return 'undefined';
    const proto = classTypeOrInstance['prototype'] ? classTypeOrInstance['prototype'] : classTypeOrInstance;
    return proto.constructor.name;
}
exports.getClassName = getClassName;
/**
 * Same as getClassName but appends the propertyName.
 * @public
 */
function getClassPropertyName(classType, propertyName) {
    const name = getClassName(classType);
    return `${name}::${propertyName}`;
}
exports.getClassPropertyName = getClassPropertyName;
/**
 * @public
 */
function applyDefaults(classType, target) {
    const classInstance = new classType();
    for (const [i, v] of iterators_1.eachPair(target)) {
        classInstance[i] = v;
    }
    return classInstance;
}
exports.applyDefaults = applyDefaults;
/**
 * Tries to identify the object by normalised result of Object.toString(obj).
 */
function typeOf(obj) {
    return ((({}).toString.call(obj).match(/\s([a-zA-Z]+)/) || [])[1] || '').toLowerCase();
}
exports.typeOf = typeOf;
/**
 * Returns true if the given obj is a plain object, and no class instance.
 *
 * isPlainObject(\{\}) === true
 * isPlainObject(new ClassXY) === false
 *
 * @public
 */
function isPlainObject(obj) {
    return Boolean(obj && typeof obj === 'object' && obj.constructor instanceof obj.constructor);
}
exports.isPlainObject = isPlainObject;
/**
 * Returns the ClassType for a given instance.
 */
function getClassTypeFromInstance(target) {
    if (!isClassInstance(target)) {
        throw new Error(`Value is not a class instance. Got ${stringifyValueWithType(target)}`);
    }
    return target['constructor'];
}
exports.getClassTypeFromInstance = getClassTypeFromInstance;
/**
 * Returns true when target is a class instance.
 */
function isClassInstance(target) {
    return target !== undefined && target !== null
        && target['constructor']
        && Object.getPrototypeOf(target) === target['constructor'].prototype
        && !isPlainObject(target)
        && isObject(target);
}
exports.isClassInstance = isClassInstance;
/**
 * Returns a human readable string representation from the given value.
*/
function stringifyValueWithType(value) {
    if ('string' === typeof value)
        return `String(${value})`;
    if ('number' === typeof value)
        return `Number(${value})`;
    if ('boolean' === typeof value)
        return `Boolean(${value})`;
    if ('function' === typeof value)
        return `Function ${value.name}`;
    if (isPlainObject(value))
        return `Object ${prettyPrintObject(value)}`;
    if (isObject(value))
        return `${getClassName(getClassTypeFromInstance(value))} ${prettyPrintObject(value)}`;
    if (null === value)
        return `null`;
    return 'undefined';
}
exports.stringifyValueWithType = stringifyValueWithType;
/**
 * Changes the class of a given instance and returns the new object.
 *
 * @example
 * ```typescript
 *
 *  class Model1 {
 *    id: number = 0;
 *  }
 *
 *  class Model2 {
 *    id: number = 0;
 *  }
 *
 *  const model1 = new Model1();
 *  const model2 = changeClass(model1, Model2);
 *  model2 instanceof Model2; //true
 * ```
 */
function changeClass(value, newClass) {
    return Object.assign(Object.create(newClass.prototype), value);
}
exports.changeClass = changeClass;
function prettyPrintObject(object) {
    let res = [];
    for (const i in object) {
        res.push(i + ': ' + stringifyValueWithType(object[i]));
    }
    return '{' + res.join(',') + '}';
}
exports.prettyPrintObject = prettyPrintObject;
/**
 * Returns true if given obj is a function.
 *
 * @public
 */
function isFunction(obj) {
    if ('function' === typeof obj) {
        return !obj.toString().startsWith('class ');
    }
    return false;
}
exports.isFunction = isFunction;
/**
 * Returns true if given obj is a promise like object.
 *
 * Note: There's not way to check if it's actually a Promise using instanceof since
 * there are a lot of different implementations around.
 *
 * @public
 */
function isPromise(obj) {
    return obj !== null && typeof obj === "object" && typeof obj.then === "function"
        && typeof obj.catch === "function" && typeof obj.finally === "function";
}
exports.isPromise = isPromise;
/**
 * Returns true if given obj is a ES6 class (ES5 fake classes are not supported).
 *
 * @public
 */
function isClass(obj) {
    if ('function' === typeof obj) {
        return obj.toString().startsWith('class ') || obj.toString().startsWith('class{');
    }
    return false;
}
exports.isClass = isClass;
/**
 * Returns true for real objects: object literals ({}) or class instances (new MyClass).
 *
 * @public
 */
function isObject(obj) {
    if (obj === null) {
        return false;
    }
    return (typeof obj === 'object' && !isArray(obj));
}
exports.isObject = isObject;
/**
 * @public
 */
function isArray(obj) {
    return !!(obj && 'number' === typeof obj.length && 'function' === typeof obj.reduce);
}
exports.isArray = isArray;
/**
 * @public
 */
function isNull(obj) {
    return null === obj;
}
exports.isNull = isNull;
/**
 * @public
 */
function isUndefined(obj) {
    return undefined === obj;
}
exports.isUndefined = isUndefined;
/**
 * Checks if obj is not null and not undefined.
 *
 * @public
 */
function isSet(obj) {
    return !isNull(obj) && !isUndefined(obj);
}
exports.isSet = isSet;
/**
 * @public
 */
function isNumber(obj) {
    return 'number' === typeOf(obj);
}
exports.isNumber = isNumber;
/**
 * @public
 */
function isString(obj) {
    return 'string' === typeOf(obj);
}
exports.isString = isString;
/**
 * @public
 */
function arrayHasItem(array, item) {
    return -1 !== array.indexOf(item);
}
exports.arrayHasItem = arrayHasItem;
/**
 * @public
 */
function indexOf(array, item) {
    if (!array) {
        return -1;
    }
    return array.indexOf(item);
}
exports.indexOf = indexOf;
/**
 * @public
 */
async function sleep(seconds) {
    return new Promise(resolve => setTimeout(resolve, seconds * 1000));
}
exports.sleep = sleep;
/**
 * Creates a shallow copy of given array.
 *
 * @public
 */
function copy(v) {
    if (isArray(v)) {
        return v.slice(0);
    }
    return v;
}
exports.copy = copy;
/**
 * Checks whether given array or object is empty (no keys). If given object is falsy, returns false.
 *
 * @public
 */
function empty(value) {
    if (!value)
        return true;
    if (isArray(value)) {
        return value.length === 0;
    }
    else {
        for (const i in value)
            if (value.hasOwnProperty(i))
                return false;
        return true;
    }
}
exports.empty = empty;
/**
 * Returns the size of given array or object.
 *
 * @public
 */
function size(array) {
    if (!array) {
        return 0;
    }
    if (isArray(array)) {
        return array.length;
    }
    else {
        return getObjectKeysSize(array);
    }
}
exports.size = size;
/**
 * Returns the first key of a given object.
 *
 * @public
 */
function firstKey(v) {
    return Object.keys(v)[0];
}
exports.firstKey = firstKey;
/**
 * Returns the last key of a given object.
 *
 * @public
 */
function lastKey(v) {
    const keys = Object.keys(v);
    if (keys.length) {
        return;
    }
    return keys[keys.length - 1];
}
exports.lastKey = lastKey;
/**
 * Returns the first value of given array or object.
 *
 * @public
 */
function first(v) {
    if (isArray(v)) {
        return v[0];
    }
    const key = firstKey(v);
    if (key) {
        return v[key];
    }
    return;
}
exports.first = first;
/**
 * Returns the last value of given array or object.
 *
 * @public
 */
function last(v) {
    if (isArray(v)) {
        if (v.length > 0) {
            return v[v.length - 1];
        }
        return;
    }
    const key = firstKey(v);
    if (key) {
        return v[key];
    }
    return;
}
exports.last = last;
/**
 * Clears the array so its empty. Returns the amount of removed items.
 *
 * @public
 */
function arrayClear(array) {
    return array.splice(0, array.length).length;
}
exports.arrayClear = arrayClear;
/**
 * Removes on particular item by reference of an array.
 *
 * @public
 */
function arrayRemoveItem(array, item) {
    const index = array.indexOf(item);
    if (-1 !== index) {
        array.splice(index, 1);
        return true;
    }
    return false;
}
exports.arrayRemoveItem = arrayRemoveItem;
/**
 * Returns the average of a number array.
 *
 * @public
 */
function average(array) {
    let sum = 0;
    for (const n of array) {
        sum += n;
    }
    return sum / array.length;
}
exports.average = average;
/**
 * @public
 */
function prependObjectKeys(o, prependText) {
    const converted = {};
    for (const i in o) {
        if (!o.hasOwnProperty(i))
            continue;
        converted[prependText + i] = o[i];
    }
    return converted;
}
exports.prependObjectKeys = prependObjectKeys;
/**
 * @public
 */
function appendObject(origin, extend, prependKeyName = '') {
    const no = prependObjectKeys(extend, prependKeyName);
    for (const [i, v] of iterators_1.eachPair(no)) {
        origin[i] = v;
    }
}
exports.appendObject = appendObject;
/**
 * A better alternative to "new Promise()" that supports error handling and maintains the stack trace for Error.stack.
 *
 * When you use `new Promise()` you need to wrap your code inside a try-catch to call `reject` on error.
 * asyncOperation() does this automatically.
 *
 * When you use `new Promise()` you will lose the stack trace when `reject(new Error())` is called.
 * asyncOperation() makes sure the error stack trace is the correct one.
 *
 * @example
 * ```typescript
 * await asyncOperation(async (resolve, reject) => {
 *     await doSomething(); //if this fails, reject() will automatically be called
 *     stream.on('data', (data) => {
 *         resolve(data); //at some point you MUST call resolve(data)
 *     });
 * });
 * ```
 *
 * @public
 */
async function asyncOperation(executor) {
    let error, async;
    try {
        async = await new Promise(async (resolve, reject) => {
            try {
                await executor(resolve, reject);
            }
            catch (e) {
                reject(e);
            }
        });
    }
    catch (e) {
        error = e;
    }
    if (error) {
        mergeStack(error, createStack());
        throw error;
    }
    return async;
}
exports.asyncOperation = asyncOperation;
/**
 * @public
 */
function mergePromiseStack(promise, stack) {
    stack = stack || createStack();
    promise.then(() => {
    }, (error) => {
        mergeStack(error, stack || '');
    });
    return promise;
}
exports.mergePromiseStack = mergePromiseStack;
/**
 * @beta
 */
function createStack(removeCallee = true) {
    if (Error.stackTraceLimit === 10)
        Error.stackTraceLimit = 100;
    let stack = new Error().stack || '';
    /*
    at createStack (/file/path)
    at promiseToObservable (/file/path)
    at userLandCode1 (/file/path)
    at userLandCode2 (/file/path)
     */
    //remove "at createStack"
    stack = stack.slice(stack.indexOf('   at ') + 6);
    stack = stack.slice(stack.indexOf('   at ') - 1);
    if (removeCallee) {
        //remove callee
        stack = stack.slice(stack.indexOf('   at ') + 6);
        stack = stack.slice(stack.indexOf('   at ') - 1);
    }
    return stack;
}
exports.createStack = createStack;
/**
 * @beta
 */
function mergeStack(error, stack) {
    if (error instanceof Error && error.stack) {
        error.stack += '\n' + stack;
    }
}
exports.mergeStack = mergeStack;
function collectForMicrotask(callback) {
    let items = [];
    let taskScheduled = false;
    return (arg) => {
        items.push(arg);
        if (!taskScheduled) {
            taskScheduled = true;
            queueMicrotask(() => {
                taskScheduled = false;
                callback(items);
                items.length = 0;
            });
        }
    };
}
exports.collectForMicrotask = collectForMicrotask;
/**
 * Returns the current time as seconds.
 *
 * @public
 */
function time() {
    return Date.now() / 1000;
}
exports.time = time;
/**
 * @public
 */
function getPathValue(bag, parameterPath, defaultValue) {
    if (isSet(bag[parameterPath])) {
        return bag[parameterPath];
    }
    const result = dot_prop_1.default.get(bag, parameterPath);
    return isSet(result) ? result : defaultValue;
}
exports.getPathValue = getPathValue;
/**
 * @public
 */
function setPathValue(bag, parameterPath, value) {
    dot_prop_1.default.set(bag, parameterPath, value);
}
exports.setPathValue = setPathValue;
/**
 * @public
 */
function deletePathValue(bag, parameterPath) {
    dot_prop_1.default.delete(bag, parameterPath);
}
exports.deletePathValue = deletePathValue;
/**
 * Returns the human readable byte representation.
 *
 * @public
 */
function humanBytes(bytes, si = false) {
    const thresh = si ? 1000 : 1024;
    if (Math.abs(bytes) < thresh) {
        return bytes + ' B';
    }
    const units = si
        ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
        : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
    let u = -1;
    do {
        bytes /= thresh;
        ++u;
    } while (Math.abs(bytes) >= thresh && u < units.length - 1);
    return bytes.toFixed(2) + ' ' + units[u];
}
exports.humanBytes = humanBytes;
/**
 * Returns the number of properties on `obj`. This is 20x faster than Object.keys(obj).length.
 */
function getObjectKeysSize(obj) {
    let size = 0;
    for (let i in obj)
        if (obj.hasOwnProperty(i))
            size++;
    return size;
}
exports.getObjectKeysSize = getObjectKeysSize;
function isConstructable(fn) {
    try {
        new new Proxy(fn, { construct: () => ({}) });
        return true;
    }
    catch (err) {
        return false;
    }
}
exports.isConstructable = isConstructable;
;
function isPrototypeOfBase(prototype, base) {
    if (!prototype)
        return false;
    if (prototype === base)
        return true;
    let currentProto = Object.getPrototypeOf(prototype);
    while (currentProto && currentProto !== Object.prototype) {
        if (currentProto === base)
            return true;
        currentProto = Object.getPrototypeOf(currentProto);
    }
    return false;
}
exports.isPrototypeOfBase = isPrototypeOfBase;
function inDebugMode() {
    return typeof v8debug === 'object' || /--debug|--inspect/.test(process.execArgv.join(' '));
}
exports.inDebugMode = inDebugMode;
//# sourceMappingURL=core.js.map