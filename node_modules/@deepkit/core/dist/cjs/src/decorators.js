"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.singleStack = exports.stack = exports.log = void 0;
const core_1 = require("./core");
const perf_1 = require("./perf");
/**
 * Logs every call to this method on stdout.
 *
 * @public
 */
function log() {
    return function (target, propertyKey, descriptor) {
        const orig = descriptor.value;
        descriptor.value = function (...args) {
            const a = args.map(v => typeof v).join(',');
            console.info(core_1.getClassName(target) + '::' + String(propertyKey) + '(' + a + ')');
            return orig.apply(this, args);
        };
        return descriptor;
    };
}
exports.log = log;
/**
 * Makes sure that calls to this async method are stacked up and are called one after another and not parallel.
 *
 * @public
 */
function stack() {
    return function (target, propertyKey, descriptor) {
        const orig = descriptor.value;
        // console.log('sync patch', propertyKey, constructor.prototype[propertyKey]);
        descriptor.value = async function (...args) {
            const name = '__c_' + propertyKey;
            if (this[name] === undefined) {
                this[name] = null;
                perf_1.toFastProperties(this);
            }
            while (this[name]) {
                await this[name];
            }
            this[name] = orig.apply(this, args);
            try {
                return await this[name];
            }
            finally {
                this[name] = null;
            }
        };
    };
}
exports.stack = stack;
/**
 * Makes sure that this async method is only running once at a time. When this method is running and it is tried
 * to call it another times, that call is "dropped" and it returns simply the result of the previous running call (waiting for it to complete first).
 *
 * @public
 */
function singleStack() {
    return function (target, propertyKey, descriptor) {
        const orig = descriptor.value;
        descriptor.value = async function (...args) {
            const name = '__sc_' + propertyKey;
            if (this[name] === undefined) {
                this[name] = null;
                perf_1.toFastProperties(this);
            }
            if (this[name]) {
                return await this[name];
            }
            this[name] = orig.apply(this, args);
            try {
                return await this[name];
            }
            finally {
                this[name] = null;
            }
        };
    };
}
exports.singleStack = singleStack;
//# sourceMappingURL=decorators.js.map