"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const process_locker_1 = require("../src/process-locker");
globals_1.jest.setTimeout(20000);
let locker;
globals_1.beforeAll(async () => {
    locker = new process_locker_1.ProcessLocker();
});
globals_1.test('test lock competing', async () => {
    const started = +new Date;
    const lock1 = await locker.acquireLock('test-lock1', 2);
    const lock2 = await locker.acquireLock('test-lock1', 1);
    globals_1.expect(+new Date - started).toBeGreaterThanOrEqual(2000);
});
globals_1.test('test lock early release', async () => {
    const started = +new Date;
    const lock1 = await locker.acquireLock('test-early-lock1', 2);
    setTimeout(async () => {
        await lock1.unlock();
    }, 500);
    const lock2 = await locker.acquireLock('test-early-lock1', 1);
    globals_1.expect(+new Date - started).toBeLessThan(1000);
    globals_1.expect(+new Date - started).toBeGreaterThan(499);
});
globals_1.test('test lock timeout', async () => {
    const started = +new Date;
    const lock1 = await locker.acquireLock('test-early-lock2', 2);
    setTimeout(async () => {
        await lock1.unlock();
    }, 500);
    const lock2 = await locker.acquireLock('test-early-lock2', 1);
    globals_1.expect(+new Date - started).toBeLessThan(1000);
    globals_1.expect(+new Date - started).toBeGreaterThan(499);
});
globals_1.test('test lock timeout accum', async () => {
    const start = Date.now();
    const lock1 = await locker.acquireLock('test-timeout-lock1', 1);
    // console.log('took', (Date.now() - start));
    const lock2 = await locker.acquireLock('test-timeout-lock1', 1);
    console.log('took', (Date.now() - start));
    globals_1.expect((Date.now() - start) / 1000).toBeGreaterThan(0.9);
    const lock3 = await locker.acquireLock('test-timeout-lock1', 1);
    console.log('took', (Date.now() - start));
    globals_1.expect((Date.now() - start) / 1000).toBeGreaterThan(1.9);
});
// test('test performance', async () => {
//     const start = performance.now();
//
//     const count = 2000;
//     for (let i = 0; i < count; i++) {
//         const lock1 = await locker.acquireLock('test-perf');
//         await lock1.unlock();
//     }
//
//     console.log(count, 'locks took', performance.now() - start, (performance.now() - start) / count);
//
//     // expect(performance.now() - start).toBeLessThan(100);
// });
globals_1.test('test tryLock', async () => {
    const lock1 = await locker.acquireLock('trylock', 1);
    globals_1.expect(lock1).toBeInstanceOf(process_locker_1.ProcessLock);
    const lock2 = await locker.tryLock('trylock', 1);
    globals_1.expect(lock2).toBeUndefined();
    globals_1.expect(await locker.isLocked('trylock')).toBe(true);
    await new Promise((resolve) => {
        setTimeout(async () => {
            globals_1.expect(await locker.isLocked('trylock')).toBe(false);
            const lock3 = await locker.tryLock('trylock', 1);
            globals_1.expect(lock3).toBeInstanceOf(process_locker_1.ProcessLock);
            globals_1.expect(await locker.isLocked('trylock')).toBe(true);
            setTimeout(async () => {
                globals_1.expect(await locker.isLocked('trylock')).toBe(true);
                const lock4 = await locker.tryLock('trylock', 1);
                globals_1.expect(lock4).toBeUndefined();
                globals_1.expect(await locker.isLocked('trylock')).toBe(true);
            }, 200);
            setTimeout(async () => {
                globals_1.expect(await locker.isLocked('trylock')).toBe(false);
                const lock5 = await locker.acquireLock('trylock', 1);
                globals_1.expect(lock5).toBeInstanceOf(process_locker_1.ProcessLock);
                globals_1.expect(await locker.isLocked('trylock')).toBe(true);
                await lock5.unlock();
                resolve(undefined);
            }, 1000);
        }, 1000);
    });
});
globals_1.test('mutex 1', async () => {
    const mutex1 = new process_locker_1.Mutex;
    let i = 0;
    const promises = [];
    promises.push(mutex1.lock().then(() => {
        globals_1.expect(i).toBe(0);
        i++;
        mutex1.unlock();
    }));
    promises.push(mutex1.lock().then(() => {
        globals_1.expect(i).toBe(1);
        i++;
        mutex1.unlock();
    }));
    promises.push(mutex1.lock().then(() => {
        globals_1.expect(i).toBe(2);
        i++;
        mutex1.unlock();
    }));
    await Promise.all(promises);
    globals_1.expect(i).toBe(3);
});
//# sourceMappingURL=lock.spec.js.map