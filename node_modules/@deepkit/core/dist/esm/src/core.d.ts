/**
 * Makes sure the error once printed using console.log contains the actual class name.
 *
 * @example
 * ```
 * class MyApiError extends CustomerError {}
 *
 * throw MyApiError() // prints MyApiError instead of simply "Error".
 * ```
 *
 * @public
 */
export declare class CustomError extends Error {
    message: string;
    name: string;
    stack?: string;
    constructor(message?: string);
}
/**
 * @public
 */
export interface ClassType<T = any> {
    new (...args: any[]): T;
}
/**
 * @public
 */
export declare type AbstractClassType<T = any> = abstract new (...args: any[]) => T;
export declare type ExtractClassType<T> = T extends ClassType<infer K> ? K : never;
declare const __forward: unique symbol;
/**
 * This type maintains the actual type, but erases the decoratorMetadata, which is requires in a circular reference for ECMAScript modules.
 * Basically fixes like "ReferenceError: Cannot access 'MyClass' before initialization"
 */
export declare type Forward<T> = T & {
    [__forward]?: true;
};
/**
 * Returns the class name either of the class definition or of the class of an instance.
 *
 * Note when code is minimized/uglified this output will change. You should disable in your compile the
 * className modification.
 *
 * @example
 * ```typescript
 * class User {}
 *
 * expect(getClassName(User)).toBe('User');
 * expect(getClassName(new User())).toBe('User');
 * ```
 *
 * @public
 */
export declare function getClassName<T>(classTypeOrInstance: ClassType<T> | Object): string;
/**
 * Same as getClassName but appends the propertyName.
 * @public
 */
export declare function getClassPropertyName<T>(classType: ClassType<T> | Object, propertyName: string): string;
/**
 * @public
 */
export declare function applyDefaults<T>(classType: ClassType<T>, target: {
    [k: string]: any;
}): T;
/**
 * Tries to identify the object by normalised result of Object.toString(obj).
 */
export declare function typeOf(obj: any): string;
/**
 * Returns true if the given obj is a plain object, and no class instance.
 *
 * isPlainObject(\{\}) === true
 * isPlainObject(new ClassXY) === false
 *
 * @public
 */
export declare function isPlainObject(obj: any): obj is object;
/**
 * Returns the ClassType for a given instance.
 */
export declare function getClassTypeFromInstance<T>(target: T): ClassType<T>;
/**
 * Returns true when target is a class instance.
 */
export declare function isClassInstance(target: any): boolean;
/**
 * Returns a human readable string representation from the given value.
*/
export declare function stringifyValueWithType(value: any): string;
/**
 * Changes the class of a given instance and returns the new object.
 *
 * @example
 * ```typescript
 *
 *  class Model1 {
 *    id: number = 0;
 *  }
 *
 *  class Model2 {
 *    id: number = 0;
 *  }
 *
 *  const model1 = new Model1();
 *  const model2 = changeClass(model1, Model2);
 *  model2 instanceof Model2; //true
 * ```
 */
export declare function changeClass<T>(value: any, newClass: ClassType<T>): T;
export declare function prettyPrintObject(object: object): string;
/**
 * Returns true if given obj is a function.
 *
 * @public
 */
export declare function isFunction(obj: any): obj is Function;
/**
 * Returns true if given obj is a promise like object.
 *
 * Note: There's not way to check if it's actually a Promise using instanceof since
 * there are a lot of different implementations around.
 *
 * @public
 */
export declare function isPromise<T>(obj: any | Promise<T>): obj is Promise<T>;
/**
 * Returns true if given obj is a ES6 class (ES5 fake classes are not supported).
 *
 * @public
 */
export declare function isClass(obj: any): obj is ClassType;
/**
 * Returns true for real objects: object literals ({}) or class instances (new MyClass).
 *
 * @public
 */
export declare function isObject(obj: any): obj is {
    [key: string]: any;
};
/**
 * @public
 */
export declare function isArray(obj: any): obj is any[];
/**
 * @public
 */
export declare function isNull(obj: any): obj is null;
/**
 * @public
 */
export declare function isUndefined(obj: any): obj is undefined;
/**
 * Checks if obj is not null and not undefined.
 *
 * @public
 */
export declare function isSet(obj: any): boolean;
/**
 * @public
 */
export declare function isNumber(obj: any): obj is number;
/**
 * @public
 */
export declare function isString(obj: any): obj is string;
/**
 * @public
 */
export declare function arrayHasItem<T>(array: T[], item: T): boolean;
/**
 * @public
 */
export declare function indexOf<T>(array: T[], item: T): number;
/**
 * @public
 */
export declare function sleep(seconds: number): Promise<void>;
/**
 * Creates a shallow copy of given array.
 *
 * @public
 */
export declare function copy<T>(v: T[]): T[];
/**
 * Checks whether given array or object is empty (no keys). If given object is falsy, returns false.
 *
 * @public
 */
export declare function empty<T>(value?: T[] | object | {}): boolean;
/**
 * Returns the size of given array or object.
 *
 * @public
 */
export declare function size<T>(array: T[] | {
    [key: string]: T;
}): number;
/**
 * Returns the first key of a given object.
 *
 * @public
 */
export declare function firstKey(v: {
    [key: string]: any;
} | object): string | undefined;
/**
 * Returns the last key of a given object.
 *
 * @public
 */
export declare function lastKey(v: {
    [key: string]: any;
} | object): string | undefined;
/**
 * Returns the first value of given array or object.
 *
 * @public
 */
export declare function first<T>(v: {
    [key: string]: T;
} | T[]): T | undefined;
/**
 * Returns the last value of given array or object.
 *
 * @public
 */
export declare function last<T>(v: {
    [key: string]: T;
} | T[]): T | undefined;
/**
 * Clears the array so its empty. Returns the amount of removed items.
 *
 * @public
 */
export declare function arrayClear<T>(array: T[]): number;
/**
 * Removes on particular item by reference of an array.
 *
 * @public
 */
export declare function arrayRemoveItem<T>(array: T[], item: T): boolean;
/**
 * Returns the average of a number array.
 *
 * @public
 */
export declare function average(array: number[]): number;
/**
 * @public
 */
export declare function prependObjectKeys(o: {
    [k: string]: any;
}, prependText: string): {
    [k: string]: any;
};
/**
 * @public
 */
export declare function appendObject(origin: {
    [k: string]: any;
}, extend: {
    [k: string]: any;
}, prependKeyName?: string): void;
/**
 * A better alternative to "new Promise()" that supports error handling and maintains the stack trace for Error.stack.
 *
 * When you use `new Promise()` you need to wrap your code inside a try-catch to call `reject` on error.
 * asyncOperation() does this automatically.
 *
 * When you use `new Promise()` you will lose the stack trace when `reject(new Error())` is called.
 * asyncOperation() makes sure the error stack trace is the correct one.
 *
 * @example
 * ```typescript
 * await asyncOperation(async (resolve, reject) => {
 *     await doSomething(); //if this fails, reject() will automatically be called
 *     stream.on('data', (data) => {
 *         resolve(data); //at some point you MUST call resolve(data)
 *     });
 * });
 * ```
 *
 * @public
 */
export declare function asyncOperation<T>(executor: (resolve: (value: T) => void, reject: (error: any) => void) => void | Promise<void>): Promise<T>;
/**
 * @public
 */
export declare function mergePromiseStack<T>(promise: Promise<T>, stack?: string): Promise<T>;
/**
 * @beta
 */
export declare function createStack(removeCallee?: boolean): string;
/**
 * @beta
 */
export declare function mergeStack(error: Error, stack: string): void;
export declare function collectForMicrotask<T>(callback: (args: T[]) => void): (arg: T) => void;
/**
 * Returns the current time as seconds.
 *
 * @public
 */
export declare function time(): number;
/**
 * @public
 */
export declare function getPathValue(bag: {
    [field: string]: any;
}, parameterPath: string, defaultValue?: any): any;
/**
 * @public
 */
export declare function setPathValue(bag: object, parameterPath: string, value: any): void;
/**
 * @public
 */
export declare function deletePathValue(bag: object, parameterPath: string): void;
/**
 * Returns the human readable byte representation.
 *
 * @public
 */
export declare function humanBytes(bytes: number, si?: boolean): string;
/**
 * Returns the number of properties on `obj`. This is 20x faster than Object.keys(obj).length.
 */
export declare function getObjectKeysSize(obj: object): number;
export declare function isConstructable(fn: any): boolean;
export declare function isPrototypeOfBase(prototype: ClassType | undefined, base: ClassType): boolean;
export declare function inDebugMode(): boolean;
export {};
