/**
 * This lock mechanism works only for one process (worker).
 *
 * live-mutex: has horrible API and doesn't allow to check if an key is currently locked.
 * proper-filelock: No way to do a correct mutex locking with event-driven blocking acquire() method.
 * redislock: Very bad performance on high-load (when multiple locks on the same key `wait`, since it loops)
 * mongodb lock: even worse performance than redis. Jesus.
 */
export declare class ProcessLock {
    readonly id: string;
    private holding;
    protected ttlTimeout: any;
    constructor(id: string);
    acquire(ttl?: number, timeout?: number): Promise<void>;
    isLocked(): boolean;
    tryLock(ttl?: number): boolean;
    unlock(): void;
}
export declare class ProcessLocker {
    /**
     *
     * @param id
     * @param ttl optional defines when the times automatically unlocks.
     * @param timeout if after `timeout` seconds the lock isn't acquired, it throws an error.
     */
    acquireLock(id: string, ttl?: number, timeout?: number): Promise<ProcessLock>;
    tryLock(id: string, ttl?: number): Promise<ProcessLock | undefined>;
    isLocked(id: string): boolean;
}
export declare class Mutex {
    protected promise?: Promise<void>;
    protected resolver?: Function;
    unlock(): void;
    lock(): Promise<void>;
}
