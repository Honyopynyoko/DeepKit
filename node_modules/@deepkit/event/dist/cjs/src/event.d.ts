import { ClassType } from '@deepkit/core';
import { Context, InjectorContext } from '@deepkit/injector';
export declare type EventListenerCallback<T> = (event: T) => void | Promise<void>;
export interface EventListener<T> {
    eventToken: EventToken<any>;
    callback: EventListenerCallback<T>;
    order: number;
}
export declare type EventOfEventToken<T> = T extends EventToken<infer E> ? E : unknown;
export declare class EventToken<T extends BaseEvent> {
    readonly id: string;
    /**
     * This is only to get easy the event-type. In reality this property is undefined.
     * e.g. `onHttpRequest(event: typeof onHttpRequest.event) {`
     */
    readonly event: T;
    constructor(id: string, event: ClassType<T>);
    listen(callback: (event: T) => void, order?: number): EventListener<T>;
}
export declare class BaseEvent {
    stopped: boolean;
    stopPropagation(): void;
    isStopped(): boolean;
}
export declare class DataEvent<T> extends BaseEvent {
    data: T;
    constructor(data: T);
}
declare class EventStore {
    token?: EventToken<any>;
    order: number;
}
declare class EventClassStore {
    listeners: {
        eventToken: EventToken<any>;
        methodName: string;
        order: number;
    }[];
}
export declare const eventClass: import("@deepkit/type").ClassDecoratorResult<{
    new (): {
        t: EventClassStore;
        addListener(eventToken: EventToken<any>, methodName: string, order: number): void;
    };
}>;
export declare const eventDispatcher: import("@deepkit/type").PropertyDecoratorResult<{
    new (): {
        t: EventStore;
        onDecorator(target: ClassType, property?: string | undefined): void;
        /**
         * Register a new event listener for given token.
         *
         * order: The lower the order, the sooner the listener is called.
         */
        listen(eventToken: EventToken<any>, order?: number): void;
    };
}>;
export declare type EventListenerContainerEntryCallback = {
    order: number;
    fn: EventListenerCallback<any>;
};
export declare type EventListenerContainerEntryService = {
    context?: Context;
    order: number;
    classType: ClassType;
    methodName: string;
};
export declare type EventListenerContainerEntry = EventListenerContainerEntryCallback | EventListenerContainerEntryService;
export declare function isEventListenerContainerEntryCallback(obj: any): obj is EventListenerContainerEntryCallback;
export declare function isEventListenerContainerEntryService(obj: any): obj is EventListenerContainerEntryService;
interface EventDispatcherFn {
    (instances: any[], scopedContext: InjectorContext, eventToken: EventToken<any>, event: BaseEvent): Promise<void>;
}
export declare class EventDispatcher {
    scopedContext: InjectorContext;
    protected listenerMap: Map<EventToken<any>, EventListenerContainerEntry[]>;
    protected instances: any[];
    protected registeredClassTypes: Set<ClassType<any>>;
    constructor(scopedContext?: InjectorContext);
    registerListener(listener: ClassType, context?: Context): void;
    registerCallback<E extends BaseEvent>(eventToken: EventToken<E>, callback: (event: E) => Promise<void> | void, order?: number): void;
    add(eventToken: EventToken<any>, listener: EventListenerContainerEntry): void;
    getTokens(): EventToken<any>[];
    hasListeners(eventToken: EventToken<any>): boolean;
    getListeners(eventToken: EventToken<any>): EventListenerContainerEntry[];
    protected build(): EventDispatcherFn;
    protected symbol: symbol;
    protected buildFor(eventToken: EventToken<any>): Function;
    dispatch<T extends EventToken<any>>(eventToken: T, event: EventOfEventToken<T>): Promise<void>;
}
export {};
