/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { CompilerContext, isClass, isFunction } from '@deepkit/core';
import { InjectorContext } from '@deepkit/injector';
import { createClassDecoratorContext, createPropertyDecoratorContext } from '@deepkit/type';
export class EventToken {
    constructor(id, event) {
        this.id = id;
    }
    listen(callback, order = 0) {
        return { eventToken: this, callback, order: order };
    }
}
export class BaseEvent {
    constructor() {
        this.stopped = false;
    }
    stopPropagation() {
        this.stopped = true;
    }
    isStopped() {
        return this.stopped;
    }
}
export class DataEvent extends BaseEvent {
    constructor(data) {
        super();
        this.data = data;
    }
}
class EventStore {
    constructor() {
        this.order = 0;
    }
}
class EventClassStore {
    constructor() {
        this.listeners = [];
    }
}
export const eventClass = createClassDecoratorContext(class {
    constructor() {
        this.t = new EventClassStore;
    }
    addListener(eventToken, methodName, order) {
        this.t.listeners.push({ eventToken, methodName, order: order });
    }
});
export const eventDispatcher = createPropertyDecoratorContext(class {
    constructor() {
        this.t = new EventStore;
    }
    onDecorator(target, property) {
        if (!this.t.token)
            throw new Error('@eventDispatcher.listen(eventToken) is the correct syntax.');
        if (!property)
            throw new Error('@eventDispatcher.listen(eventToken) works only on class properties.');
        eventClass.addListener(this.t.token, property, this.t.order)(target);
    }
    /**
     * Register a new event listener for given token.
     *
     * order: The lower the order, the sooner the listener is called.
     */
    listen(eventToken, order = 0) {
        if (!eventToken)
            new Error('@eventDispatcher.listen() No event token given');
        this.t.token = eventToken;
        this.t.order = order;
    }
});
export function isEventListenerContainerEntryCallback(obj) {
    return obj && isFunction(obj.fn);
}
export function isEventListenerContainerEntryService(obj) {
    return obj && isClass(obj.classType);
}
export class EventDispatcher {
    constructor(scopedContext = InjectorContext.forProviders([])) {
        this.scopedContext = scopedContext;
        this.listenerMap = new Map();
        this.instances = [];
        this.registeredClassTypes = new Set();
        this.symbol = Symbol('eventDispatcher');
    }
    registerListener(listener, context) {
        if (this.registeredClassTypes.has(listener))
            return;
        this.registeredClassTypes.add(listener);
        const config = eventClass._fetch(listener);
        if (!config)
            return;
        for (const entry of config.listeners) {
            this.add(entry.eventToken, { context, classType: listener, methodName: entry.methodName, order: entry.order });
        }
    }
    registerCallback(eventToken, callback, order = 0) {
        this.add(eventToken, { fn: callback, order: order });
    }
    add(eventToken, listener) {
        this.getListeners(eventToken).push(listener);
        eventToken[this.symbol] = this.buildFor(eventToken);
    }
    getTokens() {
        return [...this.listenerMap.keys()];
    }
    hasListeners(eventToken) {
        return this.listenerMap.has(eventToken);
    }
    getListeners(eventToken) {
        let listeners = this.listenerMap.get(eventToken);
        if (!listeners) {
            listeners = [];
            this.listenerMap.set(eventToken, listeners);
        }
        return listeners;
    }
    build() {
        const compiler = new CompilerContext();
        const code = [];
        for (const [eventToken, listeners] of this.listenerMap.entries()) {
            listeners.sort((a, b) => {
                if (a.order > b.order)
                    return +1;
                if (a.order < b.order)
                    return -1;
                return 0;
            });
            const lines = [];
            for (const listener of listeners) {
                if (isEventListenerContainerEntryCallback(listener)) {
                    const fnVar = compiler.reserveVariable('fn', listener.fn);
                    lines.push(`
                        r = await ${fnVar}(event);
                        if (event.isStopped()) return;
                    `);
                }
                else if (isEventListenerContainerEntryService(listener)) {
                    const classTypeVar = compiler.reserveVariable('classType', listener.classType);
                    lines.push(`
                        await scopedContext.get(${classTypeVar}).${listener.methodName}(event);
                    `);
                }
            }
            const eventTokenVar = compiler.reserveVariable('eventToken', eventToken);
            code.push(`
            //${eventToken.id}
            case: ${eventTokenVar}: {
                ${lines.join('\n')}
                return;
            }
            `);
        }
        return compiler.buildAsync(`
        switch (eventToken) {
            ${code.join('\n')}
        }
        `, 'instances', 'scopedContext', 'eventToken', 'event');
    }
    buildFor(eventToken) {
        const compiler = new CompilerContext();
        const lines = [];
        for (const listener of this.listenerMap.get(eventToken) || []) {
            if (isEventListenerContainerEntryCallback(listener)) {
                const fnVar = compiler.reserveVariable('fn', listener.fn);
                lines.push(`
                    r = await ${fnVar}(event);
                    if (event.isStopped()) return;
                `);
            }
            else if (isEventListenerContainerEntryService(listener)) {
                const classTypeVar = compiler.reserveVariable('classType', listener.classType);
                lines.push(`
                    await scopedContext.get(${classTypeVar}).${listener.methodName}(event);
                `);
            }
        }
        return compiler.buildAsync(lines.join('\n'), 'scopedContext', 'event');
    }
    dispatch(eventToken, event) {
        let fn = eventToken[this.symbol];
        //no fn means for this token does no listener exist
        return fn ? fn(this.scopedContext, event) : undefined;
    }
}
//# sourceMappingURL=event.js.map