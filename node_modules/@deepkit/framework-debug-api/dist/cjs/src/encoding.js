"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeFrames = exports.decodeFrameData = exports.encodeFrameData = exports.categorySchemas = exports.encodeFrames = void 0;
const bson_1 = require("@deepkit/bson");
const stopwatch_1 = require("@deepkit/stopwatch");
const type_1 = require("@deepkit/type");
function encodeFrames(frames) {
    //<id uint32><worker uint8><type uint8><timestamp uint64><context uint32><category uint8><labelSize uint8><label utf8string>.
    let size = 0;
    for (const frame of frames) {
        size += frame.type === stopwatch_1.FrameType.end ? (32 + 8 + 8 + 64) / 8 : (((32 + 8 + 8 + 64 + 32 + 8 + 8) / 8) + Math.min(255, bson_1.stringByteLength(frame.label)));
    }
    const buffer = Buffer.allocUnsafe(size);
    const writer = new bson_1.Writer(buffer);
    for (const frame of frames) {
        writer.writeUint32(frame.id);
        writer.writeByte(frame.worker);
        writer.writeByte(frame.type);
        //up to 2⁵³=9,007,199,254,740,992 the representable numbers are exactly the integers
        //so we have no precision loss when using timestamp=Math.floor(performance.timeOrigin * 1_000 + performance.now() * 1_000)
        //timestamp current output vs max precise integers:
        //1613654358960142
        //9007199254740992
        writer.writeDouble(frame.timestamp);
        if (frame.type === stopwatch_1.FrameType.start) {
            writer.writeUint32(frame.context);
            writer.writeByte(frame.category);
            let size = bson_1.stringByteLength(frame.label);
            for (let i = 0; size > 255; i++) {
                frame.label = frame.label.substr(0, 255 - i);
                size = bson_1.stringByteLength(frame.label);
            }
            writer.writeByte(size);
            writer.writeString(frame.label);
        }
    }
    return buffer;
}
exports.encodeFrames = encodeFrames;
exports.categorySchemas = {
    [stopwatch_1.FrameCategory.http]: type_1.t.schema({
        url: type_1.t.string.optional,
        method: type_1.t.string.optional,
        clientIp: type_1.t.string.optional,
        responseStatus: type_1.t.number.optional,
    })
};
function encodeFrameData(dataItems) {
    //<id uint32><worker uint8><bson document>
    let size = 0;
    for (const data of dataItems) {
        const schema = exports.categorySchemas[data.category];
        if (!schema)
            throw new Error(`Frame category ${stopwatch_1.FrameCategory[data.category]} has no schema declared.`);
        size += ((32 + 8) / 8) + bson_1.getBSONSizer(schema)(data.data);
    }
    const buffer = Buffer.allocUnsafe(size);
    const writer = new bson_1.Writer(buffer);
    for (const data of dataItems) {
        writer.writeUint32(data.id);
        writer.writeByte(data.worker);
        const schema = exports.categorySchemas[data.category];
        bson_1.getBSONSerializer(schema)(data.data, writer);
    }
    return buffer;
}
exports.encodeFrameData = encodeFrameData;
function decodeFrameData(buffer) {
    const parser = new bson_1.ParserV2(buffer);
    const data = [];
    while (parser.offset < buffer.byteLength) {
        const id = parser.eatUInt32();
        const worker = parser.eatByte();
        const end = parser.peekUInt32() + parser.offset;
        data.push({ id, worker, bson: parser.buffer.slice(parser.offset, end) });
        parser.offset = end;
    }
    return data;
}
exports.decodeFrameData = decodeFrameData;
function decodeFrames(buffer) {
    const parser = new bson_1.ParserV2(buffer);
    const frames = [];
    while (parser.offset < buffer.byteLength) {
        const id = parser.eatUInt32();
        const worker = parser.eatByte();
        const type = parser.eatByte();
        const timestamp = parser.eatDouble();
        if (type === stopwatch_1.FrameType.start) {
            const context = parser.eatUInt32();
            const category = parser.eatByte();
            const stringSize = parser.eatByte();
            const label = parser.eatString(stringSize);
            frames.push({ id, worker, type: stopwatch_1.FrameType.start, timestamp, context, category, label });
        }
        else {
            frames.push({ id, worker, type: stopwatch_1.FrameType.end, timestamp });
        }
    }
    return frames;
}
exports.decodeFrames = decodeFrames;
//# sourceMappingURL=encoding.js.map