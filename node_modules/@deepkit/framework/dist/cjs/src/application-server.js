"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryApplicationServer = exports.ApplicationServer = exports.ApplicationServerListener = exports.onServerMainShutdown = exports.ServerShutdownEvent = exports.onServerWorkerBootstrap = exports.onServerMainBootstrapDone = exports.onServerMainBootstrap = exports.ServerBootstrapEvent = void 0;
const core_1 = require("@deepkit/core");
const rpc_1 = require("@deepkit/rpc");
const cluster_1 = __importDefault(require("cluster"));
const http_1 = require("@deepkit/http");
const event_1 = require("@deepkit/event");
const injector_1 = require("@deepkit/injector");
const kernel_config_1 = require("./kernel.config");
const logger_1 = require("@deepkit/logger");
const application_service_container_1 = require("./application-service-container");
const worker_1 = require("./worker");
class ServerBootstrapEvent extends event_1.BaseEvent {
}
exports.ServerBootstrapEvent = ServerBootstrapEvent;
/**
 * Called only once for application server bootstrap (in the cluster main process)
 * as soon as the application server starts.
 */
exports.onServerMainBootstrap = new event_1.EventToken('server.main.bootstrap', ServerBootstrapEvent);
/**
 * Called only once for application server bootstrap (in the cluster main process)
 * as soon as the application server has started.
 */
exports.onServerMainBootstrapDone = new event_1.EventToken('server.main.bootstrapDone', ServerBootstrapEvent);
/**
 * Called for each worker as soon as the worker bootstraps.
 */
exports.onServerWorkerBootstrap = new event_1.EventToken('server.worker.bootstrap', ServerBootstrapEvent);
class ServerShutdownEvent extends event_1.BaseEvent {
}
exports.ServerShutdownEvent = ServerShutdownEvent;
/**
 * Called when application server shuts down in the main process.
 */
exports.onServerMainShutdown = new event_1.EventToken('server.main.shutdown', ServerBootstrapEvent);
class ApplicationServerConfig extends kernel_config_1.kernelConfig.slice(['server', 'port', 'host', 'httpsPort',
    'ssl', 'sslKey', 'sslCertificate', 'sslCa', 'sslCrl',
    'varPath', 'selfSigned', 'keepAliveTimeout', 'workers']) {
}
let ApplicationServerListener = class ApplicationServerListener {
    constructor(logger, rpcControllers, httpControllers, config) {
        this.logger = logger;
        this.rpcControllers = rpcControllers;
        this.httpControllers = httpControllers;
        this.config = config;
    }
    onBootstrapDone() {
        for (const [name, controller] of this.rpcControllers.controllers.entries()) {
            this.logger.log('RPC', `<yellow>${core_1.getClassName(controller)}</yellow>`, `<grey>${name}</grey>`);
        }
        for (const controller of this.httpControllers.controllers.values()) {
            const httpConfig = http_1.httpClass._fetch(controller);
            this.logger.log('HTTP', `<yellow>${core_1.getClassName(controller)}</yellow>`);
            for (const action of httpConfig.getActions()) {
                this.logger.log(`    ${action.httpMethod} ${httpConfig.getUrl(action)} <grey>${action.methodName}</grey>`);
            }
        }
        if (this.config.server) {
            this.logger.log(`Server up and running`);
        }
        else {
            if (this.config.ssl) {
                this.logger.log(`HTTPS listening at https://${this.config.host}:${this.config.httpsPort || this.config.port}/`);
            }
            if (!this.config.ssl || (this.config.ssl && this.config.httpsPort)) {
                this.logger.log(`HTTP listening at http://${this.config.host}:${this.config.port}/`);
            }
        }
    }
};
__decorate([
    event_1.eventDispatcher.listen(exports.onServerMainBootstrapDone),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ApplicationServerListener.prototype, "onBootstrapDone", null);
ApplicationServerListener = __decorate([
    injector_1.injectable(),
    __metadata("design:paramtypes", [logger_1.Logger,
        application_service_container_1.RpcControllers,
        http_1.HttpControllers,
        ApplicationServerConfig])
], ApplicationServerListener);
exports.ApplicationServerListener = ApplicationServerListener;
let ApplicationServer = class ApplicationServer {
    constructor(logger, webWorkerFactory, eventDispatcher, rootScopedContext, config) {
        this.logger = logger;
        this.webWorkerFactory = webWorkerFactory;
        this.eventDispatcher = eventDispatcher;
        this.rootScopedContext = rootScopedContext;
        this.config = config;
        this.started = false;
    }
    async close() {
        if (this.config.workers > 1) {
            for (const worker of core_1.each(cluster_1.default.workers)) {
                if (worker) {
                    worker.kill();
                }
            }
            await this.shutdown();
        }
        else {
            await this.shutdown();
            if (this.worker) {
                this.worker.close();
            }
        }
    }
    async shutdown() {
        await this.eventDispatcher.dispatch(exports.onServerMainShutdown, new ServerShutdownEvent());
    }
    async bootstrap() {
        await this.eventDispatcher.dispatch(exports.onServerMainBootstrap, new ServerBootstrapEvent());
    }
    async bootstrapDone() {
        await this.eventDispatcher.dispatch(exports.onServerMainBootstrapDone, new ServerBootstrapEvent());
    }
    async start() {
        if (this.started)
            throw new Error('ApplicationServer already started');
        this.started = true;
        //listening to this signal is required to make ts-node-dev working with its reload feature.
        process.on('SIGTERM', () => {
            console.log('Received SIGTERM.');
            process.exit(0);
        });
        if (cluster_1.default.isMaster) {
            this.logger.log(`Start HTTP server, using ${this.config.workers} workers.`);
        }
        if (this.config.workers > 1) {
            if (cluster_1.default.isMaster) {
                await this.bootstrap();
                for (let i = 0; i < this.config.workers; i++) {
                    cluster_1.default.fork();
                }
                await this.bootstrapDone();
            }
            else {
                await this.eventDispatcher.dispatch(exports.onServerWorkerBootstrap, new ServerBootstrapEvent());
                this.worker = this.webWorkerFactory.create(cluster_1.default.worker.id, this.config);
                this.worker.start();
                cluster_1.default.on('exit', (w) => {
                    this.logger.warning(`Worker ${w.id} died.`);
                    cluster_1.default.fork();
                });
            }
        }
        else {
            await this.bootstrap();
            await this.eventDispatcher.dispatch(exports.onServerWorkerBootstrap, new ServerBootstrapEvent());
            this.worker = this.webWorkerFactory.create(1, this.config);
            this.worker.start();
            await this.bootstrapDone();
        }
    }
    getWorker() {
        if (!this.worker)
            throw new Error('No WebWorker registered yet. Did you start()?');
        return this.worker;
    }
    createClient() {
        const worker = this.getWorker();
        const context = this.rootScopedContext;
        const kernel = worker.rpcKernel;
        return new rpc_1.RpcClient({
            connect(connection) {
                const kernelConnection = worker_1.createRpcConnection(context, kernel, {
                    write: (buffer) => connection.onData(buffer),
                    close: () => connection.onClose(),
                });
                connection.onConnected({
                    close() {
                        kernelConnection.close();
                    },
                    send(message) {
                        queueMicrotask(() => {
                            kernelConnection.feed(message);
                        });
                    }
                });
            }
        });
    }
};
ApplicationServer = __decorate([
    injector_1.injectable(),
    __metadata("design:paramtypes", [logger_1.Logger,
        worker_1.WebWorkerFactory,
        event_1.EventDispatcher,
        injector_1.InjectorContext,
        ApplicationServerConfig])
], ApplicationServer);
exports.ApplicationServer = ApplicationServer;
class InMemoryApplicationServer extends ApplicationServer {
}
exports.InMemoryApplicationServer = InMemoryApplicationServer;
//# sourceMappingURL=application-server.js.map