import { AsyncEventSubscription, ClassType } from '@deepkit/core';
import { AsyncSubscription } from '@deepkit/core-rxjs';
import { BaseQuery, Database, DatabaseQueryModel, DatabaseRegistry, FilterQuery, Sort } from '@deepkit/orm';
import { Collection, CollectionSort, EntitySubject, IdVersionInterface, RpcKernelBaseConnection } from '@deepkit/rpc';
import { ClassSchema } from '@deepkit/type';
import { Observable } from 'rxjs';
import { Broker } from '../broker/broker';
interface SentState {
    lastSentVersion?: number;
    listeners: number;
}
declare class SubscriptionHandler {
    protected connection: RpcKernelBaseConnection;
    protected classSchema: ClassSchema;
    protected database: Database;
    protected broker: Broker;
    protected sentEntities: {
        [id: string]: SentState;
    };
    protected entitySubscription?: Promise<AsyncSubscription>;
    constructor(connection: RpcKernelBaseConnection, classSchema: ClassSchema, database: Database, broker: Broker);
    protected hasSentState(id: string | number): boolean;
    /**
     * Necessary when the whole state of `id` should be deleted from memory, so it wont sync to client anymore.
     */
    protected rmSentState<T>(id: string | number): void;
    protected getSentState(id: string | number): SentState;
    setSent(id: string | number, version?: number): void;
    needsToBeSend(id: string | number, version: number): boolean;
    decreaseUsage(id: string | number): void;
    increaseUsage(id: string | number): void;
    subscribeEntity(): void;
}
declare class SubscriptionHandlers {
    protected connection: RpcKernelBaseConnection;
    protected databases: DatabaseRegistry;
    protected broker: Broker;
    protected handler: Map<ClassSchema<any>, SubscriptionHandler>;
    constructor(connection: RpcKernelBaseConnection, databases: DatabaseRegistry, broker: Broker);
    get(classSchema: ClassSchema): SubscriptionHandler;
}
declare class LiveDatabaseQueryModel<T> extends DatabaseQueryModel<T, FilterQuery<T>, Sort<T, any>> {
    disableEntityChangeFeed: boolean;
    isChangeFeedActive(): boolean;
    getCollectionSort(): CollectionSort[];
}
export declare class LiveQuery<T extends IdVersionInterface> extends BaseQuery<T> {
    classSchema: ClassSchema<T>;
    protected connection: RpcKernelBaseConnection;
    protected database: Database;
    protected broker: Broker;
    protected subscriptionHandler: SubscriptionHandler;
    model: LiveDatabaseQueryModel<T>;
    constructor(classSchema: ClassSchema<T>, connection: RpcKernelBaseConnection, database: Database, broker: Broker, subscriptionHandler: SubscriptionHandler);
    clone(): this;
    disableEntityChangeFeed(): this;
    protected createModel<T>(): LiveDatabaseQueryModel<T>;
    findOneOrUndefined(): Promise<EntitySubject<T> | undefined>;
    findOne(): Promise<EntitySubject<T>>;
    count<T extends IdVersionInterface>(): Observable<number>;
    find(): Promise<Collection<T>>;
    /**
     * Returns a new Observable that resolves the id as soon as an item in the database of given filter criteria is found.
     */
    onCreation<T extends IdVersionInterface>(initialCheck?: boolean, stopOnFind?: boolean): Observable<string | number>;
}
export declare class LiveDatabase {
    protected databases: DatabaseRegistry;
    protected broker: Broker;
    protected connection: RpcKernelBaseConnection;
    protected subscriptionHandler: SubscriptionHandlers;
    protected entitySubscriptions: Map<ClassSchema<any>, AsyncEventSubscription[]>;
    constructor(databases: DatabaseRegistry, broker: Broker, connection: RpcKernelBaseConnection);
    disableChangeFeed<T extends IdVersionInterface>(classType: ClassType<T> | ClassSchema<T>): void;
    enableChangeFeed(...classTypes: (ClassType<IdVersionInterface> | ClassSchema<IdVersionInterface>)[]): void;
    getSubscriptionHandler(classType: ClassType): SubscriptionHandler;
    protected setupListeners(classType: ClassType | ClassSchema): void;
    query<T extends IdVersionInterface>(classType: ClassType<T> | ClassSchema<T>): LiveQuery<T>;
}
export {};
