"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStopwatchStore = void 0;
const stopwatch_1 = require("@deepkit/stopwatch");
const fs_1 = require("fs");
const path_1 = require("path");
const framework_debug_api_1 = require("@deepkit/framework-debug-api");
const core_1 = require("@deepkit/core");
const broker_1 = require("../../broker/broker");
const kernel_config_1 = require("../../kernel.config");
const injector_1 = require("@deepkit/injector");
const type_1 = require("@deepkit/type");
const zone_1 = require("../../zone");
const cluster_1 = __importDefault(require("cluster"));
const perf_hooks_1 = require("perf_hooks");
class Config extends kernel_config_1.kernelConfig.slice(['varPath', 'debugStorePath']) {
}
let FileStopwatchStore = class FileStopwatchStore extends stopwatch_1.StopwatchStore {
    constructor(config, broker) {
        super();
        this.config = config;
        this.broker = broker;
        this.syncMutex = new core_1.Mutex;
        this.lastId = -1;
        this.lastContext = -1;
        this.frameChannel = this.broker.channel('_debug/frames', type_1.t.type(Uint8Array));
    }
    run(data, cb) {
        return zone_1.Zone.run(data, cb);
    }
    getZone() {
        return zone_1.Zone.current();
    }
    add(frame) {
        frame.worker = cluster_1.default.isWorker ? cluster_1.default.worker.id : 0;
        frame.timestamp = Math.floor(perf_hooks_1.performance.timeOrigin * 1000 + perf_hooks_1.performance.now() * 1000);
        super.add(frame);
        return frame.worker;
    }
    async loadLastNumberRange() {
        if (this.lastId >= 0)
            return;
        if (!this.frameFileHandle)
            this.frameFileHandle = fs_1.openSync(path_1.join(this.config.varPath, this.config.debugStorePath, 'frames.bin'), 'a+');
        if (!this.frameDataFileHandle)
            this.frameDataFileHandle = fs_1.openSync(path_1.join(this.config.varPath, this.config.debugStorePath, 'frames-data.bin'), 'a');
        const data = fs_1.readFileSync(this.frameFileHandle);
        if (data.byteLength === 0) {
            this.lastId = 0;
            this.lastContext = 0;
            return;
        }
        const frames = framework_debug_api_1.decodeFrames(data);
        for (let i = frames.length - 1; i >= 0; i--) {
            const frame = frames[i];
            if (frame.type === stopwatch_1.FrameType.start) {
                this.lastId = frame.id;
                this.lastContext = frame.context;
                return;
            }
        }
    }
    sync() {
        if (this.lastSync)
            return;
        this.lastSync = setTimeout(() => this.syncNow(), 250);
    }
    async syncNow() {
        await this.syncMutex.lock();
        try {
            this.lastSync = undefined;
            await this.loadLastNumberRange();
            if (!this.frameFileHandle)
                throw new Error('No frame file handle');
            if (!this.frameDataFileHandle)
                throw new Error('No frame data file handle');
            const frames = this.frameQueue.slice();
            const frameData = this.dataQueue.slice();
            this.frameQueue = [];
            this.dataQueue = [];
            for (const frame of frames) {
                frame.id += this.lastId;
                if (frame.type === stopwatch_1.FrameType.start)
                    frame.context += this.lastContext;
            }
            for (const frame of frameData) {
                frame.id += this.lastId;
            }
            await core_1.asyncOperation((resolve, reject) => {
                const frameBytes = framework_debug_api_1.encodeFrames(frames);
                fs_1.write(this.frameFileHandle, frameBytes, (error) => {
                    this.frameChannel.publish(frameBytes);
                    if (error)
                        reject(error);
                    else
                        resolve(undefined);
                });
            });
            await core_1.asyncOperation((resolve, reject) => {
                fs_1.write(this.frameDataFileHandle, framework_debug_api_1.encodeFrameData(frameData), (error) => {
                    if (error)
                        reject(error);
                    else
                        resolve(undefined);
                });
            });
        }
        finally {
            this.syncMutex.unlock();
        }
    }
};
FileStopwatchStore = __decorate([
    injector_1.injectable(),
    __metadata("design:paramtypes", [Config,
        broker_1.Broker])
], FileStopwatchStore);
exports.FileStopwatchStore = FileStopwatchStore;
//# sourceMappingURL=store.js.map