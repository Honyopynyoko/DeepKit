"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTestingApp = exports.BrokerMemoryServer = exports.TestingFacade = exports.TestHttpResponse = void 0;
const broker_1 = require("@deepkit/broker");
const logger_1 = require("@deepkit/logger");
const orm_1 = require("@deepkit/orm");
const application_1 = require("./application");
const application_server_1 = require("./application-server");
const broker_2 = require("./broker/broker");
const injector_1 = require("@deepkit/injector");
const app_1 = require("@deepkit/app");
const worker_1 = require("./worker");
const http_1 = require("@deepkit/http");
class TestHttpResponse extends http_1.HttpResponse {
    constructor() {
        super(...arguments);
        this.body = Buffer.alloc(0);
    }
    write(chunk, encoding, callback) {
        if (typeof encoding === 'function') {
            callback = encoding;
            encoding = null;
        }
        if (chunk) {
            if ('string' === typeof chunk) {
                chunk = Buffer.from(chunk, encoding || 'utf8');
            }
            this.body = Buffer.concat([this.body, chunk]);
        }
        if (callback)
            callback();
        return true;
    }
    end(chunk, encoding, callback) {
        if (typeof chunk === 'function') {
            callback = chunk;
            chunk = null;
            encoding = null;
        }
        else if (typeof encoding === 'function') {
            callback = encoding;
            encoding = null;
        }
        if (chunk) {
            if ('string' === typeof chunk) {
                chunk = Buffer.from(chunk, encoding || 'utf8');
            }
            this.body = Buffer.concat([this.body, chunk]);
        }
        if (callback)
            callback();
    }
}
exports.TestHttpResponse = TestHttpResponse;
class TestingFacade {
    constructor(app) {
        this.app = app;
    }
    async startServer() {
        await this.app.get(application_server_1.ApplicationServer).start();
    }
    async stopServer() {
        await this.app.get(application_server_1.ApplicationServer).close();
    }
    async request(requestBuilder) {
        const request = requestBuilder.build();
        const response = new TestHttpResponse(request);
        await this.app.get(http_1.HttpKernel).handleRequest(request, response);
        return response;
    }
    createRpcClient() {
        return this.app.get(application_server_1.ApplicationServer).createClient();
    }
}
exports.TestingFacade = TestingFacade;
class BrokerMemoryServer extends broker_2.BrokerServer {
    constructor() {
        super(...arguments);
        this.kernel = new broker_1.BrokerKernel();
    }
    async start() {
    }
    async stop() {
    }
}
exports.BrokerMemoryServer = BrokerMemoryServer;
/**
 * Creates a new Application instance, but with kernel services in place that work in memory.
 * For example RPC/Broker/HTTP communication without TCP stack. Logger uses MemoryLogger.
 */
function createTestingApp(optionsOrModule, entities) {
    const module = optionsOrModule instanceof app_1.AppModule ? optionsOrModule : new app_1.AppModule(optionsOrModule);
    module.setupProvider(logger_1.Logger).removeTransport(injector_1.injectorReference(logger_1.ConsoleTransport));
    module.setupProvider(logger_1.Logger).addTransport(injector_1.injectorReference(logger_1.MemoryLoggerTransport));
    const providers = [
        { provide: worker_1.WebWorkerFactory, useClass: worker_1.WebMemoryWorkerFactory },
        { provide: broker_2.BrokerServer, useClass: BrokerMemoryServer },
        logger_1.MemoryLoggerTransport,
        {
            provide: broker_2.Broker, deps: [broker_2.BrokerServer], useFactory: (server) => {
                return new broker_2.DirectBroker(server.kernel);
            }
        },
    ];
    if (entities) {
        providers.push({ provide: orm_1.Database, useValue: new orm_1.Database(new orm_1.MemoryDatabaseAdapter, entities) });
        module.setupProvider(orm_1.DatabaseRegistry).addDatabase(orm_1.Database);
    }
    return new TestingFacade(new application_1.Application(module, providers));
}
exports.createTestingApp = createTestingApp;
//# sourceMappingURL=testing.js.map