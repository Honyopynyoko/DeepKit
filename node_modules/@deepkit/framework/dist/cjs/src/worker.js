"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebMemoryWorker = exports.WebWorker = exports.createRpcConnection = exports.WebMemoryWorkerFactory = exports.WebWorkerFactory = void 0;
const rpc_1 = require("@deepkit/rpc");
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const ws_1 = __importDefault(require("ws"));
const http_2 = require("@deepkit/http");
const injector_1 = require("@deepkit/injector");
const rpc_2 = require("./rpc");
const application_service_container_1 = require("./application-service-container");
// @ts-ignore
const selfsigned_1 = __importDefault(require("selfsigned"));
const path_1 = require("path");
const fs_1 = require("fs");
const logger_1 = require("@deepkit/logger");
let WebWorkerFactory = class WebWorkerFactory {
    constructor(httpKernel, logger, rpcControllers, rootScopedContext) {
        this.httpKernel = httpKernel;
        this.logger = logger;
        this.rpcControllers = rpcControllers;
        this.rootScopedContext = rootScopedContext;
    }
    create(id, options) {
        return new WebWorker(id, this.logger, this.httpKernel, this.createRpcKernel(), this.rootScopedContext, options);
    }
    createRpcKernel() {
        const security = this.rootScopedContext.get(rpc_1.RpcKernelSecurity);
        const kernel = new rpc_1.RpcKernel(this.rootScopedContext, security, this.logger.scoped('rpc'));
        for (const [name, controller] of this.rpcControllers.controllers.entries()) {
            kernel.registerController(name, controller, false);
        }
        return kernel;
    }
};
WebWorkerFactory = __decorate([
    injector_1.injectable(),
    __metadata("design:paramtypes", [http_2.HttpKernel,
        logger_1.Logger,
        application_service_container_1.RpcControllers,
        injector_1.InjectorContext])
], WebWorkerFactory);
exports.WebWorkerFactory = WebWorkerFactory;
class WebMemoryWorkerFactory extends WebWorkerFactory {
    create(id, options) {
        return new WebMemoryWorker(id, this.logger, this.httpKernel, this.createRpcKernel(), this.rootScopedContext, options);
    }
}
exports.WebMemoryWorkerFactory = WebMemoryWorkerFactory;
function createRpcConnection(rootScopedContext, rpcKernel, writer, request) {
    let rpcScopedContext;
    let connection;
    const providers = [
        { provide: http_2.HttpRequest, useValue: request },
        { provide: rpc_2.RpcInjectorContext, useFactory: () => rpcScopedContext },
        { provide: rpc_1.SessionState, useFactory: () => connection.sessionState },
        { provide: rpc_1.RpcKernelConnection, useFactory: () => connection },
        { provide: rpc_1.RpcKernelBaseConnection, useFactory: () => connection },
        { provide: rpc_1.ConnectionWriter, useValue: writer },
    ];
    const additionalInjector = new injector_1.Injector(providers);
    rpcScopedContext = rootScopedContext.createChildScope('rpc', additionalInjector);
    connection = rpcKernel.createConnection(writer, rpcScopedContext);
    return connection;
}
exports.createRpcConnection = createRpcConnection;
let WebWorker = class WebWorker {
    constructor(id, logger, httpKernel, rpcKernel, rootScopedContext, options) {
        this.id = id;
        this.logger = logger;
        this.httpKernel = httpKernel;
        this.rpcKernel = rpcKernel;
        this.rootScopedContext = rootScopedContext;
        this.options = options;
    }
    start() {
        if (this.options.server) {
            this.server = this.options.server;
            this.server.on('request', this.httpKernel.handleRequest.bind(this.httpKernel));
            this.wsServer = new ws_1.default.Server({ server: this.server });
            this.wsServer.on('connection', this.onWsConnection.bind(this));
        }
        else {
            if (this.options.ssl) {
                const options = this.options.sslOptions || {};
                if (this.options.selfSigned) {
                    const keyPath = path_1.join(this.options.varPath, `self-signed-${this.options.host}.key`);
                    const certificatePath = path_1.join(this.options.varPath, `self-signed-${this.options.host}.cert`);
                    if (fs_1.existsSync(keyPath) && fs_1.existsSync(certificatePath)) {
                        options.key = fs_1.readFileSync(keyPath, 'utf8');
                        options.cert = fs_1.readFileSync(certificatePath, 'utf8');
                    }
                    else {
                        const attrs = [{ name: 'commonName', value: this.options.host }];
                        const pems = selfsigned_1.default.generate(attrs, { days: 365 });
                        options.cert = pems.cert;
                        options.key = pems.private;
                        fs_1.writeFileSync(keyPath, pems.private, 'utf8');
                        fs_1.writeFileSync(certificatePath, pems.cert, 'utf8');
                        this.logger.log(`Self signed certificate for ${this.options.host} created at ${certificatePath}`);
                        this.logger.log(`Tip: If you want to open this server via chrome for localhost, use chrome://flags/#allow-insecure-localhost`);
                    }
                }
                if (!options.key && this.options.sslKey)
                    options.key = fs_1.readFileSync(this.options.sslKey, 'utf8');
                if (!options.ca && this.options.sslCa)
                    options.key = fs_1.readFileSync(this.options.sslCa, 'utf8');
                if (!options.cert && this.options.sslCertificate)
                    options.cert = fs_1.readFileSync(this.options.sslCertificate, 'utf8');
                if (!options.crl && this.options.sslCrl)
                    options.cert = fs_1.readFileSync(this.options.sslCrl, 'utf8');
                this.servers = new https_1.default.Server(Object.assign({ IncomingMessage: http_2.HttpRequest, ServerResponse: http_2.HttpResponse, }, options), this.httpKernel.handleRequest.bind(this.httpKernel) //as any necessary since http.Server is not typed correctly
                );
                this.servers.listen(this.options.httpsPort || this.options.port, this.options.host);
                if (this.options.keepAliveTimeout)
                    this.servers.keepAliveTimeout = this.options.keepAliveTimeout;
                this.wssServer = new ws_1.default.Server({ server: this.servers });
                this.wssServer.on('connection', this.onWsConnection.bind(this));
            }
            const startHttpServer = !this.servers || (this.servers && this.options.httpsPort);
            if (startHttpServer) {
                this.server = new http_1.default.Server({ IncomingMessage: http_2.HttpRequest, ServerResponse: http_2.HttpResponse }, this.httpKernel.handleRequest.bind(this.httpKernel) //as any necessary since http.Server is not typed correctly
                );
                if (this.options.keepAliveTimeout)
                    this.server.keepAliveTimeout = this.options.keepAliveTimeout;
                this.server.listen(this.options.port, this.options.host);
                this.wsServer = new ws_1.default.Server({ server: this.server });
                this.wsServer.on('connection', this.onWsConnection.bind(this));
            }
        }
    }
    onWsConnection(ws, req) {
        const connection = createRpcConnection(this.rootScopedContext, this.rpcKernel, {
            write(b) {
                ws.send(b);
            },
            close() {
                ws.close();
            },
            bufferedAmount() {
                return ws.bufferedAmount;
            },
            clientAddress() {
                return req.getRemoteAddress();
            }
        }, req);
        ws.on('message', async (message) => {
            connection.feed(message);
        });
        ws.on('close', async () => {
            connection.close();
        });
    }
    close() {
        if (this.server)
            this.server.close();
        if (this.servers)
            this.servers.close();
    }
};
WebWorker = __decorate([
    injector_1.injectable(),
    __metadata("design:paramtypes", [Number, logger_1.Logger,
        http_2.HttpKernel,
        rpc_1.RpcKernel,
        injector_1.InjectorContext, Object])
], WebWorker);
exports.WebWorker = WebWorker;
class WebMemoryWorker extends WebWorker {
    start() { }
}
exports.WebMemoryWorker = WebMemoryWorker;
//# sourceMappingURL=worker.js.map