/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { injectable } from '@deepkit/injector';
import { Broker } from './broker';
export class AppLock {
    constructor(subscription) {
        this.subscription = subscription;
    }
    async release() {
        await this.subscription.unsubscribe();
    }
}
/**
 * An global application lock (across workers, processes, and nodes).
 * It provides a way to acquire locks on the central broker process atomically.
*/
let AppLocker = class AppLocker {
    constructor(broker) {
        this.broker = broker;
    }
    /**
     * Locks the given id. If the lock is already aquired by someone else, it waits max `timeout` seconds.
     *
     * Make sure the call `release` on the result AppLock to get a dead-lock.
     *
     * @param id
     * @param ttl time to live in seconds. The lock automatically releases when ttl is reached. 0 for no limit.
     * @param timeout in seconds. When the lock is already aquired the times defines when to give up aquisiting the lock. 0 for no limit.
     *
     * @example
     * ```typescript
     *
     * class MyController {
     *   constructor(protected appLocker: AppLocker) {
     *   }
     *
     *   async doSomething() {
     *     const lock = this.appLocker.acquireLock('myId);
     *     try {
     *         //do you stuff here
     *     } finally {
     *       //important to have it in finally to not accidantely keep the lock alive forever.
     *       lock.release();
     *     }
     *   }
     * }
     *
     * ```
     */
    async acquireLock(id, ttl = 0, timeout = 0) {
        return new AppLock(await this.broker.lock(id, ttl, timeout));
    }
    /**
     * Tries to acquire the lock and give immediately up when already locked by someone else.
     *
     * @param id
     * @param ttl time to live in seconds. The lock automatically releases when ttl is reached. 0 for no limit.
     */
    async tryLock(id, ttl = 0) {
        const subscription = await this.broker.tryLock(id, ttl);
        if (!subscription)
            return subscription;
        return new AppLock(subscription);
    }
    /**
     * Returns true if the lock is already aquired by someone.
    */
    async isLocked(id) {
        return this.broker.isLocked(id);
    }
};
AppLocker = __decorate([
    injectable(),
    __metadata("design:paramtypes", [Broker])
], AppLocker);
export { AppLocker };
//# sourceMappingURL=app-locker.js.map