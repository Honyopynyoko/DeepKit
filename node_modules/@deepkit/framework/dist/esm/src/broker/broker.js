/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { BrokerChannel, BrokerClient, BrokerKernel } from '@deepkit/broker';
import { RpcDirectClientAdapter } from '@deepkit/rpc';
import { getClassSchema, t } from '@deepkit/type';
import { inject, injectable } from '@deepkit/injector';
import { brokerConfig } from './broker.config';
import { NetTcpRpcClientAdapter, NetTcpRpcServer, TcpRpcClientAdapter, TcpRpcServer } from '@deepkit/rpc-tcp';
export var EntityChannelMessageType;
(function (EntityChannelMessageType) {
    EntityChannelMessageType[EntityChannelMessageType["remove"] = 0] = "remove";
    EntityChannelMessageType[EntityChannelMessageType["patch"] = 1] = "patch";
    EntityChannelMessageType[EntityChannelMessageType["add"] = 2] = "add";
})(EntityChannelMessageType || (EntityChannelMessageType = {}));
const entityChannelMessageAdd = t.schema({
    type: t.literal(EntityChannelMessageType.add).discriminant,
    id: t.union(t.string, t.number),
}, { name: 'EntityChannelMessageAdd' });
const entityChannelMessageRemove = t.schema({
    type: t.literal(EntityChannelMessageType.remove).discriminant,
    ids: t.array(t.union(t.string, t.number, t.uuid, t.mongoId)),
}, { name: 'EntityChannelMessageRemove' });
const entityPatch = t.schema({
    $set: t.map(t.any).optional,
    $unset: t.map(t.number).optional,
    $inc: t.map(t.number).optional,
});
const entityChannelMessagePatch = t.schema({
    type: t.literal(EntityChannelMessageType.patch).discriminant,
    id: t.union(t.string, t.number),
    version: t.number,
    patch: t.type(entityPatch)
}, { name: 'EntityChannelMessagePatch' });
export class EntityBrokerChannel extends BrokerChannel {
    publishAdd(item) {
        return this.publish({ type: EntityChannelMessageType.add, id: item.id, item });
    }
    publishRemove(ids) {
        return this.publish({ type: EntityChannelMessageType.remove, ids });
    }
    publishPatch(id, version, patch, item) {
        return this.publish({ type: EntityChannelMessageType.patch, id, version, patch, item });
    }
}
export class BaseBroker extends BrokerClient {
    getEntityChannelMessageSchema(schema) {
        const jit = schema.jit;
        if (!jit.entityChannelMessage) {
            jit.entityChannelMessage = t.union(entityChannelMessageRemove, entityChannelMessagePatch.extend({ item: t.partial(schema) }), entityChannelMessageAdd.extend({ item: schema }));
        }
        return jit.entityChannelMessage;
    }
    entityChannel(schemaOrType) {
        const schema = getClassSchema(schemaOrType);
        const channelName = 'dk/e/' + schema.getName();
        let channel = this.activeChannels.get(channelName);
        if (channel)
            return channel;
        const decorator = this.getEntityChannelMessageSchema(schema);
        channel = new EntityBrokerChannel(channelName, decorator, this);
        this.activeChannels.set(channel.channel, channel);
        return channel;
    }
}
let Broker = class Broker extends BaseBroker {
    constructor(url) {
        super(new TcpRpcClientAdapter(url));
        this.url = url;
    }
};
Broker = __decorate([
    __param(0, inject(brokerConfig.token('host'))),
    __metadata("design:paramtypes", [String])
], Broker);
export { Broker };
let NetBroker = class NetBroker extends BaseBroker {
    constructor(url) {
        super(new NetTcpRpcClientAdapter(url));
        this.url = url;
    }
};
NetBroker = __decorate([
    __param(0, inject(brokerConfig.token('host'))),
    __metadata("design:paramtypes", [String])
], NetBroker);
export { NetBroker };
export class DirectBroker extends BaseBroker {
    constructor(rpcKernel) {
        super(new RpcDirectClientAdapter(rpcKernel));
    }
}
let BrokerServer = class BrokerServer extends TcpRpcServer {
    constructor(listen) {
        super(new BrokerKernel, listen);
        this.kernel = new BrokerKernel;
    }
};
BrokerServer = __decorate([
    injectable(),
    __param(0, inject(brokerConfig.token('listen'))),
    __metadata("design:paramtypes", [String])
], BrokerServer);
export { BrokerServer };
let NetBrokerServer = class NetBrokerServer extends NetTcpRpcServer {
    constructor(listen) {
        super(new BrokerKernel, listen);
        this.kernel = new BrokerKernel;
    }
};
NetBrokerServer = __decorate([
    injectable(),
    __param(0, inject(brokerConfig.token('listen'))),
    __metadata("design:paramtypes", [String])
], NetBrokerServer);
export { NetBrokerServer };
//# sourceMappingURL=broker.js.map