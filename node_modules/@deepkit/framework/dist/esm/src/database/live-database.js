/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { asyncOperation } from '@deepkit/core';
import { BaseQuery, DatabaseQueryModel, DatabaseRegistry, exportQueryFilterFieldNames, replaceQueryFilterParameter } from '@deepkit/orm';
import { Collection, EntitySubject, rpcEntityPatch, rpcEntityRemove, RpcKernelBaseConnection, RpcTypes } from '@deepkit/rpc';
import { getClassSchema, resolveClassTypeOrForward } from '@deepkit/type';
import { Observable } from 'rxjs';
import { Broker, EntityChannelMessageType } from '../broker/broker';
import { injectable } from '@deepkit/injector';
import { findQuerySatisfied } from '../utils';
class SubscriptionHandler {
    constructor(connection, classSchema, database, broker) {
        this.connection = connection;
        this.classSchema = classSchema;
        this.database = database;
        this.broker = broker;
        this.sentEntities = {};
    }
    hasSentState(id) {
        return !!this.sentEntities[id];
    }
    /**
     * Necessary when the whole state of `id` should be deleted from memory, so it wont sync to client anymore.
     */
    rmSentState(id) {
        delete this.sentEntities[id];
        if (Object.keys(this.sentEntities).length === 0) {
            if (this.entitySubscription) {
                this.entitySubscription.then(v => v.unsubscribe());
                this.entitySubscription = undefined;
            }
        }
    }
    getSentState(id) {
        if (!this.sentEntities[id]) {
            this.sentEntities[id] = {
                lastSentVersion: 0,
                listeners: 0,
            };
        }
        return this.sentEntities[id];
    }
    setSent(id, version) {
        this.getSentState(id).lastSentVersion = version;
    }
    needsToBeSend(id, version) {
        if (!this.hasSentState(id))
            return false;
        const state = this.getSentState(id);
        return state.listeners > 0 && (state.lastSentVersion === undefined || (version === 0 || version > state.lastSentVersion));
    }
    decreaseUsage(id) {
        const state = this.getSentState(id);
        state.listeners--;
        if (state.listeners <= 0) {
            this.rmSentState(id);
        }
    }
    increaseUsage(id) {
        const state = this.getSentState(id);
        state.listeners++;
        this.subscribeEntity();
    }
    subscribeEntity() {
        if (this.entitySubscription) {
            //already subscribed, nothing to do here
            return;
        }
        const entityName = this.classSchema.getName();
        this.entitySubscription = this.broker.entityChannel(this.classSchema).subscribe((message) => {
            if (message.type === EntityChannelMessageType.remove) {
                for (const id of message.ids) {
                    this.rmSentState(id);
                }
                this.connection.createMessageBuilder()
                    .composite(RpcTypes.Entity)
                    .add(RpcTypes.EntityRemove, rpcEntityRemove, {
                    entityName: entityName,
                    ids: message.ids,
                }).send();
                return;
            }
            if (message.type === EntityChannelMessageType.patch && this.needsToBeSend(message.id, message.version)) {
                this.setSent(message.id, message.version);
                this.connection.createMessageBuilder()
                    .composite(RpcTypes.Entity)
                    .add(RpcTypes.EntityPatch, rpcEntityPatch, {
                    entityName: entityName,
                    id: message.id,
                    version: message.version,
                    patch: message.patch
                }).send();
            }
            //nothing to do for ADD, because that's handled by Collection
        });
    }
}
class SubscriptionHandlers {
    constructor(connection, databases, broker) {
        this.connection = connection;
        this.databases = databases;
        this.broker = broker;
        this.handler = new Map();
    }
    get(classSchema) {
        let handler = this.handler.get(classSchema);
        if (!handler) {
            handler = new SubscriptionHandler(this.connection, classSchema, this.databases.getDatabaseForEntity(classSchema), this.broker);
            this.handler.set(classSchema, handler);
        }
        return handler;
    }
}
class LiveDatabaseQueryModel extends DatabaseQueryModel {
    constructor() {
        super(...arguments);
        this.disableEntityChangeFeed = false;
    }
    isChangeFeedActive() {
        return !this.disableEntityChangeFeed;
    }
    getCollectionSort() {
        const sort = [];
        if (!this.sort)
            return sort;
        for (const [name, direction] of Object.entries(this.sort)) {
            sort.push({ field: name, direction: direction });
        }
        return sort;
    }
}
function extractModelData(classSchema, model, result) {
    result.push({
        classSchema,
        filter: model.filter || {},
        fields: model.filter ? exportQueryFilterFieldNames(classSchema, model.filter) : [],
    });
    extractJoinedClassSchemaInfos(model, result);
}
function extractJoinedClassSchemaInfos(model, result) {
    for (const join of model.joins) {
        if (join.propertySchema.backReference && join.propertySchema.backReference.via) {
            const schema = getClassSchema(resolveClassTypeOrForward(join.propertySchema.backReference.via));
            result.push({
                classSchema: schema,
                filter: {},
                fields: [],
            });
        }
        extractModelData(join.query.classSchema, join.query.model, result);
    }
}
class LiveCollection {
    constructor(collection, model, broker, database, subscriptionHandler, connection) {
        this.collection = collection;
        this.model = model;
        this.broker = broker;
        this.database = database;
        this.subscriptionHandler = subscriptionHandler;
        this.connection = connection;
        this.joinedClassSchemas = [];
        this.rootFields = [];
        this.knownIDs = new Set();
        this.classSchema = getClassSchema(this.collection.classType);
        this.rootFields = exportQueryFilterFieldNames(this.classSchema, model.filter || {});
        // figure out what entities are involved (by going through all joins)
        extractJoinedClassSchemaInfos(this.model, this.joinedClassSchemas);
    }
    async publishUseEntityFields() {
        const promises = [];
        if (this.rootFields.length)
            promises.push(this.broker.publishEntityFields(this.classSchema, this.rootFields).then(v => this.rootUsedEntityFieldsSubscription = v));
        for (const info of this.joinedClassSchemas) {
            if (!info.fields.length)
                continue;
            promises.push(this.broker.publishEntityFields(info.classSchema, info.fields).then(sub => {
                info.usedEntityFieldsSubscription = sub;
            }));
        }
        await Promise.all(promises);
    }
    async stopSync() {
        if (this.entitySubscription)
            this.entitySubscription.unsubscribe();
        const promises = [];
        for (const [, info] of this.joinedClassSchemas.entries()) {
            if (info.usedEntityFieldsSubscription)
                promises.push(info.usedEntityFieldsSubscription.unsubscribe());
            if (info.entitySubscription)
                info.entitySubscription.unsubscribe();
        }
        if (this.rootUsedEntityFieldsSubscription)
            promises.push(this.rootUsedEntityFieldsSubscription.unsubscribe());
        await Promise.all(promises);
        this.joinedClassSchemas = [];
        for (const id of this.knownIDs.values()) {
            if (this.model.isChangeFeedActive())
                this.subscriptionHandler.decreaseUsage(id);
        }
    }
    async updateCollection(databaseChanged = false) {
        if (this.lastUpdatePromise)
            return this.lastUpdatePromise;
        this.lastUpdatePromise = asyncOperation((resolve) => {
            // this.lastUpdatePromiseResolver = resolve;
            setTimeout(async () => {
                await this._updateCollection(databaseChanged);
                this.lastUpdatePromise = undefined;
                resolve(undefined);
            }, 100);
        });
        return this.lastUpdatePromise;
    }
    async _updateCollection(databaseChanged = false) {
        if (!this.entitySubscription)
            return;
        // let pagingHash = '';
        // let parametersHash = '';
        // //when database is changed during entityFeed events, we don't check that stuff
        // if (databaseChanged) {
        //     pagingHash = this.collection.pagination.getPagingHash();
        //     parametersHash = this.collection.pagination.getParametersHash();
        // } else {
        //     const newPagingHash = this.collection.pagination.getPagingHash();
        //     const newParametersHash = this.collection.pagination.getParametersHash();
        //     let needUpdate = false;
        //
        //     if (pagingHash !== newPagingHash) {
        //         pagingHash = newPagingHash;
        //         needUpdate = true;
        //     }
        //
        //     if (parametersHash !== newParametersHash) {
        //         parametersHash = newParametersHash;
        //         // if (reactiveQuery.haveParametersChanged()) {
        //         //     needUpdate = true;
        //         // }
        //     }
        //
        //     if (!needUpdate) {
        //         return;
        //     }
        // }
        //- query the database and put all items in our list
        const query = this.database.query(this.classSchema);
        query.model = this.model.clone(query);
        query.model.limit = undefined;
        query.model.skip = undefined;
        const total = await query.count();
        query.model = this.model;
        const items = await query.find();
        const copiedKnownIds = new Set(this.knownIDs.values());
        for (const item of items) {
            copiedKnownIds.delete(item.id);
            if (!this.knownIDs.has(item.id)) {
                this.knownIDs.add(item.id);
                if (this.model.isChangeFeedActive())
                    this.subscriptionHandler.increaseUsage(item.id);
                this.collection.add(item);
            }
        }
        //items left in copiedKnownIds have been deleted or filter doesn't match anymore.
        for (const id of copiedKnownIds.values()) {
            this.knownIDs.delete(id);
            if (this.model.isChangeFeedActive())
                this.subscriptionHandler.decreaseUsage(id);
        }
        const idsToRemove = [...copiedKnownIds.values()];
        if (idsToRemove.length > 0)
            this.collection.removeMany(idsToRemove);
        //todo, call it only when really changed
        this.collection.setSort(items.map(v => v.id));
        if (this.collection.state.total !== total) {
            this.collection.state.total = total;
            this.collection.setState(this.collection.state);
        }
    }
    async getItem(id) {
        const query = this.database.query(this.classSchema);
        query.model = this.model.clone(query);
        query.filter({ id: id });
        return query.findOneOrUndefined();
    }
    async startSync() {
        if (this.entitySubscription)
            throw new Error('Collection sync already started');
        await this.publishUseEntityFields();
        for (const info of this.joinedClassSchemas) {
            if (info.entitySubscription)
                continue;
            //if its part of our join filter, we reload the collection
            info.entitySubscription = await this.broker.entityChannel(info.classSchema).subscribe((message) => {
                //todo: check if item belongs to the join criteria
                this.updateCollection(true);
            });
        }
        let currentQuery = replaceQueryFilterParameter(this.classSchema, this.model.filter || {}, this.model.parameters);
        function requiresFullUpdate(collection) {
            return collection.model.hasPaging() || collection.model.hasSort();
        }
        // const scopedSerializer = jsonSerializer.for(this.classSchema);
        this.entitySubscription = await this.broker.entityChannel(this.classSchema).subscribe(async (message) => {
            if (message.type === EntityChannelMessageType.remove) {
                if (requiresFullUpdate(this.collection)) {
                    await this.updateCollection(true);
                    return;
                }
                for (const id of message.ids) {
                    this.knownIDs.delete(id);
                    if (this.model.isChangeFeedActive())
                        this.subscriptionHandler.decreaseUsage(id);
                }
                this.collection.removeMany(message.ids);
            }
            if (message.type === EntityChannelMessageType.add) {
                if (this.knownIDs.has(message.id) || !findQuerySatisfied(message.item, currentQuery)) {
                    return;
                }
                if (requiresFullUpdate(this.collection)) {
                    await this.updateCollection(true);
                    return;
                }
                this.knownIDs.add(message.id);
                if (this.model.isChangeFeedActive())
                    this.subscriptionHandler.increaseUsage(message.id);
                this.collection.add(message.item);
            }
            if (message.type === EntityChannelMessageType.patch) {
                const querySatisfied = findQuerySatisfied(message.item, currentQuery);
                if (this.knownIDs.has(message.id) && !querySatisfied) {
                    if (requiresFullUpdate(this.collection)) {
                        await this.updateCollection(true);
                    }
                    else {
                        //got invalid after updates?
                        this.knownIDs.delete(message.id);
                        if (this.model.isChangeFeedActive())
                            this.subscriptionHandler.decreaseUsage(message.id);
                        this.collection.remove(message.id);
                    }
                }
                else if (!this.knownIDs.has(message.id) && querySatisfied) {
                    if (requiresFullUpdate(this.collection)) {
                        await this.updateCollection(true);
                    }
                    else {
                        //got valid after updates?
                        this.knownIDs.add(message.id);
                        if (this.model.isChangeFeedActive())
                            this.subscriptionHandler.increaseUsage(message.id);
                        const item = await this.getItem(message.id);
                        if (item) {
                            this.collection.add(item);
                        }
                        else {
                            await this.updateCollection(true);
                        }
                    }
                }
            }
        });
        this.model.change.subscribe(() => {
            this.updateCollection().catch(console.error);
        });
        this.collection.model.change.subscribe(() => {
            this.model.limit = this.collection.model.limit;
            this.model.skip = this.collection.model.skip;
            this.model.itemsPerPage = this.collection.model.itemsPerPage;
            this.model.sort = this.collection.model.sort;
            if (this.collection.model.filter)
                this.model.filter = this.collection.model.filter;
            this.model.setParameters(this.collection.model.parameters);
            this.updateCollection().catch(console.error);
        });
        // this.collection.pagination.event.subscribe(async (event) => {
        //     if (event.type === 'client:apply' || event.type === 'apply') {
        //         //its important to not reassign a new object ref to this.model.parameters, since the ref
        //         //is stored in joined query models as well.
        //         const newParameters = this.collection.pagination.getParameters();
        //         for (const [i, value] of eachPair(newParameters)) {
        //             this.model.parameters[i] = value;
        //         }
        //         currentQuery = replaceQueryFilterParameter(this.classSchema, this.model.filter || {}, this.model.parameters);
        //         await this.updateCollection();
        //         if (event.type === 'client:apply') this.collection.pagination.event.next({type: 'server:apply/finished'});
        //         if (event.type === 'apply') this.collection.pagination._applyFinished();
        //     }
        // });
        const query = this.database.query(this.classSchema);
        query.model = this.model.clone(query);
        query.model.limit = undefined;
        query.model.skip = undefined;
        const total = await query.count();
        this.collection.state.total = total;
        query.model = this.model;
        const items = await query.find();
        for (const item of items) {
            this.knownIDs.add(item.id);
            if (this.model.isChangeFeedActive())
                this.subscriptionHandler.increaseUsage(item.id);
        }
        this.collection.set(items);
    }
}
export class LiveQuery extends BaseQuery {
    constructor(classSchema, connection, database, broker, subscriptionHandler) {
        super(classSchema);
        this.classSchema = classSchema;
        this.connection = connection;
        this.database = database;
        this.broker = broker;
        this.subscriptionHandler = subscriptionHandler;
        this.model = this.createModel();
    }
    clone() {
        const cloned = new this['constructor'](this.classSchema, this.connection, this.database, this.broker, this.subscriptionHandler);
        cloned.model = this.model.clone(cloned);
        return cloned;
    }
    disableEntityChangeFeed() {
        this.model.disableEntityChangeFeed = true;
        return this;
    }
    createModel() {
        return new LiveDatabaseQueryModel();
    }
    async findOneOrUndefined() {
        const item = await this.database.query(this.classSchema).filter(this.model.filter).findOneOrUndefined();
        if (!item)
            return;
        const foundId = item.id;
        this.subscriptionHandler.increaseUsage(foundId);
        //we must start with version 0, since exchange issues from 0
        //we don't care about the item.version
        this.subscriptionHandler.setSent(item.id, 0);
        this.subscriptionHandler.subscribeEntity();
        return new EntitySubject(item, () => {
            this.subscriptionHandler.decreaseUsage(foundId);
        });
    }
    async findOne() {
        const item = await this.database.query(this.classSchema).filter(this.model.filter).findOne();
        const foundId = item.id;
        this.subscriptionHandler.increaseUsage(foundId);
        //we must start with version 0, since exchange issues from 0
        //we don't care about the item.version
        this.subscriptionHandler.setSent(item.id, 0);
        this.subscriptionHandler.subscribeEntity();
        return new EntitySubject(item, () => {
            this.subscriptionHandler.decreaseUsage(foundId);
        });
    }
    count() {
        const rootFields = exportQueryFilterFieldNames(this.classSchema, this.model.filter || {});
        let currentQuery = replaceQueryFilterParameter(this.classSchema, this.model.filter || {}, this.model.parameters);
        const joinedClassSchemas = [];
        extractJoinedClassSchemaInfos(this.model, joinedClassSchemas);
        return new Observable((observer) => {
            let rootEntitySub;
            let usedEntityFieldsSub;
            (async () => {
                usedEntityFieldsSub = await this.broker.publishEntityFields(this.classSchema, rootFields);
                const knownIDs = new Set();
                let counter = 0;
                rootEntitySub = await this.broker.entityChannel(this.classSchema).subscribe((message) => {
                    if (message.type === EntityChannelMessageType.add) {
                        if (!knownIDs.has(message.id) && findQuerySatisfied(message.item, currentQuery)) {
                            counter++;
                            knownIDs.add(message.id);
                            observer.next(counter);
                        }
                    }
                    if (message.type === EntityChannelMessageType.patch) {
                        if (knownIDs.has(message.id) && !findQuerySatisfied(message.item, currentQuery)) {
                            counter--;
                            knownIDs.delete(message.id);
                            observer.next(counter);
                        }
                        else if (!knownIDs.has(message.id) && findQuerySatisfied(message.item, currentQuery)) {
                            counter++;
                            knownIDs.add(message.id);
                            observer.next(counter);
                        }
                    }
                    if (message.type === EntityChannelMessageType.remove) {
                        for (const id of message.ids) {
                            if (knownIDs.has(id)) {
                                counter--;
                                knownIDs.delete(id);
                                observer.next(counter);
                            }
                        }
                    }
                });
                const updateAll = async () => {
                    const query = this.database.query(this.classSchema);
                    query.model = this.model.clone(query);
                    const items = await query.select('id').find();
                    knownIDs.clear();
                    counter = items.length;
                    for (const item of items)
                        knownIDs.add(item.id);
                    observer.next(counter);
                };
                for (const info of joinedClassSchemas) {
                    if (info.entitySubscription)
                        continue;
                    //if its part of our join filter, we reload the collection
                    info.entitySubscription = await this.broker.entityChannel(info.classSchema).subscribe((message) => {
                        //todo: check if item belongs to the join criteria
                        updateAll();
                    });
                }
                await updateAll();
            })();
            return {
                unsubscribe: async () => {
                    rootEntitySub.unsubscribe();
                    await usedEntityFieldsSub.unsubscribe();
                    for (const info of joinedClassSchemas) {
                        if (info.entitySubscription)
                            info.entitySubscription.unsubscribe();
                    }
                }
            };
        });
    }
    async find() {
        const collection = new Collection(this.classSchema.classType);
        collection.model.set(this.model);
        const liveCollection = new LiveCollection(collection, this.model, this.broker, this.database, this.subscriptionHandler, this.connection);
        collection.addTeardown(async () => {
            await liveCollection.stopSync();
        });
        await liveCollection.startSync();
        return collection;
    }
    /**
     * Returns a new Observable that resolves the id as soon as an item in the database of given filter criteria is found.
     */
    onCreation(initialCheck = true, stopOnFind = true) {
        return new Observable((observer) => {
            let sub;
            const filter = this.model.filter || {};
            (async () => {
                sub = await this.broker.entityChannel(this.classSchema).subscribe((message) => {
                    if (message.type === EntityChannelMessageType.add && findQuerySatisfied(message.item, filter)) {
                        observer.next(message.id);
                        if (stopOnFind && sub)
                            sub.unsubscribe();
                    }
                });
                if (initialCheck) {
                    const item = await this.database.query(this.classSchema).select('id').filter(filter).findOneOrUndefined();
                    if (item) {
                        observer.next(item.id);
                        if (stopOnFind)
                            sub.unsubscribe();
                    }
                }
            })();
            return {
                unsubscribe() {
                    if (sub)
                        sub.unsubscribe();
                }
            };
        });
    }
}
let LiveDatabase = class LiveDatabase {
    constructor(databases, broker, connection) {
        this.databases = databases;
        this.broker = broker;
        this.connection = connection;
        this.subscriptionHandler = new SubscriptionHandlers(this.connection, this.databases, this.broker);
        this.entitySubscriptions = new Map();
    }
    disableChangeFeed(classType) {
        const schema = getClassSchema(classType);
        const subscriptions = this.entitySubscriptions.get(schema);
        if (!subscriptions)
            return;
        for (const sub of subscriptions)
            sub.unsubscribe();
        this.entitySubscriptions.delete(schema);
    }
    enableChangeFeed(...classTypes) {
        for (const classType of classTypes) {
            this.setupListeners(classType);
        }
    }
    getSubscriptionHandler(classType) {
        return this.subscriptionHandler.get(getClassSchema(classType));
    }
    setupListeners(classType) {
        const database = this.databases.getDatabaseForEntity(classType);
        const schema = getClassSchema(classType);
        if (this.entitySubscriptions.has(schema))
            return;
        const subscriptions = [];
        subscriptions.push(database.unitOfWorkEvents.onInsertPost.subscribe((event) => {
            if (schema !== event.classSchema)
                return;
            for (const item of event.items) {
                this.broker.entityChannel(event.classSchema).publishAdd(item).catch(() => {
                    console.warn('Failed publishing add event', schema.getClassName(), item);
                });
            }
        }));
        subscriptions.push(database.unitOfWorkEvents.onUpdatePre.subscribe((event) => {
            if (schema !== event.classSchema)
                return;
            for (const changeSet of event.changeSets) {
                changeSet.changes.increase('version', 1);
            }
        }));
        subscriptions.push(database.unitOfWorkEvents.onUpdatePost.subscribe(async (event) => {
            if (schema !== event.classSchema)
                return;
            // const serialized = jsonSerializer.for(event.classSchema);
            for (const changeSet of event.changeSets) {
                const jsonPatch = {
                    $set: changeSet.changes.$set,
                    $inc: changeSet.changes.$inc,
                    $unset: changeSet.changes.$unset,
                };
                const fields = {};
                for (const field of await this.broker.getEntityFields(event.classSchema)) {
                    fields[field] = changeSet.item[field];
                }
                this.broker.entityChannel(event.classSchema).publishPatch(changeSet.item.id, changeSet.item.version, jsonPatch, fields);
            }
        }));
        subscriptions.push(database.unitOfWorkEvents.onDeletePost.subscribe((event) => {
            if (schema !== event.classSchema)
                return;
            const ids = [];
            for (const item of event.items)
                ids.push(item.id);
            this.broker.entityChannel(event.classSchema).publishRemove(ids).catch(() => {
                console.warn('Failed publishing remove event', schema.getClassName(), ids);
            });
            ;
        }));
        subscriptions.push(database.queryEvents.onDeletePost.subscribe((event) => {
            if (schema !== event.classSchema)
                return;
            this.broker.entityChannel(event.classSchema).publishRemove(event.deleteResult.primaryKeys).catch(() => {
                console.warn('Failed publishing remove event', schema.getClassName(), event.deleteResult.primaryKeys);
            });
        }));
        subscriptions.push(database.queryEvents.onPatchPre.subscribe(async (event) => {
            if (schema !== event.classSchema)
                return;
            event.patch.increase('version', 1);
            event.returning.push('version');
            for (const field of await this.broker.getEntityFields(event.classSchema)) {
                if (!event.returning.includes(field))
                    event.returning.push(field);
            }
        }));
        subscriptions.push(database.queryEvents.onPatchPost.subscribe(async (event) => {
            if (schema !== event.classSchema)
                return;
            const jsonPatch = {
                $set: event.patch.$set,
                $inc: event.patch.$inc,
                $unset: event.patch.$unset,
            };
            for (let i = 0; i < event.patchResult.primaryKeys.length; i++) {
                const fields = {};
                for (const field of await this.broker.getEntityFields(event.classSchema)) {
                    if (!event.patchResult.returning[field])
                        continue;
                    fields[field] = event.patchResult.returning[field][i];
                }
                this.broker.entityChannel(event.classSchema).publishPatch(event.patchResult.primaryKeys[i], event.patchResult.returning['version'][i], jsonPatch, fields);
            }
        }));
        this.entitySubscriptions.set(schema, subscriptions);
    }
    query(classType) {
        return new LiveQuery(getClassSchema(classType), this.connection, this.databases.getDatabaseForEntity(classType), this.broker, this.subscriptionHandler.get(getClassSchema(classType)));
    }
};
LiveDatabase = __decorate([
    injectable(),
    __metadata("design:paramtypes", [DatabaseRegistry,
        Broker,
        RpcKernelBaseConnection])
], LiveDatabase);
export { LiveDatabase };
//# sourceMappingURL=live-database.js.map