var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { FrameType, StopwatchStore } from '@deepkit/stopwatch';
import { openSync, readFileSync, write } from 'fs';
import { join } from 'path';
import { decodeFrames, encodeFrameData, encodeFrames } from '@deepkit/framework-debug-api';
import { asyncOperation, Mutex } from '@deepkit/core';
import { Broker } from '../../broker/broker';
import { kernelConfig } from '../../kernel.config';
import { injectable } from '@deepkit/injector';
import { t } from '@deepkit/type';
import { Zone } from '../../zone';
import cluster from 'cluster';
import { performance } from 'perf_hooks';
class Config extends kernelConfig.slice(['varPath', 'debugStorePath']) {
}
let FileStopwatchStore = class FileStopwatchStore extends StopwatchStore {
    constructor(config, broker) {
        super();
        this.config = config;
        this.broker = broker;
        this.syncMutex = new Mutex;
        this.lastId = -1;
        this.lastContext = -1;
        this.frameChannel = this.broker.channel('_debug/frames', t.type(Uint8Array));
    }
    run(data, cb) {
        return Zone.run(data, cb);
    }
    getZone() {
        return Zone.current();
    }
    add(frame) {
        frame.worker = cluster.isWorker ? cluster.worker.id : 0;
        frame.timestamp = Math.floor(performance.timeOrigin * 1000 + performance.now() * 1000);
        super.add(frame);
        return frame.worker;
    }
    async loadLastNumberRange() {
        if (this.lastId >= 0)
            return;
        if (!this.frameFileHandle)
            this.frameFileHandle = openSync(join(this.config.varPath, this.config.debugStorePath, 'frames.bin'), 'a+');
        if (!this.frameDataFileHandle)
            this.frameDataFileHandle = openSync(join(this.config.varPath, this.config.debugStorePath, 'frames-data.bin'), 'a');
        const data = readFileSync(this.frameFileHandle);
        if (data.byteLength === 0) {
            this.lastId = 0;
            this.lastContext = 0;
            return;
        }
        const frames = decodeFrames(data);
        for (let i = frames.length - 1; i >= 0; i--) {
            const frame = frames[i];
            if (frame.type === FrameType.start) {
                this.lastId = frame.id;
                this.lastContext = frame.context;
                return;
            }
        }
    }
    sync() {
        if (this.lastSync)
            return;
        this.lastSync = setTimeout(() => this.syncNow(), 250);
    }
    async syncNow() {
        await this.syncMutex.lock();
        try {
            this.lastSync = undefined;
            await this.loadLastNumberRange();
            if (!this.frameFileHandle)
                throw new Error('No frame file handle');
            if (!this.frameDataFileHandle)
                throw new Error('No frame data file handle');
            const frames = this.frameQueue.slice();
            const frameData = this.dataQueue.slice();
            this.frameQueue = [];
            this.dataQueue = [];
            for (const frame of frames) {
                frame.id += this.lastId;
                if (frame.type === FrameType.start)
                    frame.context += this.lastContext;
            }
            for (const frame of frameData) {
                frame.id += this.lastId;
            }
            await asyncOperation((resolve, reject) => {
                const frameBytes = encodeFrames(frames);
                write(this.frameFileHandle, frameBytes, (error) => {
                    this.frameChannel.publish(frameBytes);
                    if (error)
                        reject(error);
                    else
                        resolve(undefined);
                });
            });
            await asyncOperation((resolve, reject) => {
                write(this.frameDataFileHandle, encodeFrameData(frameData), (error) => {
                    if (error)
                        reject(error);
                    else
                        resolve(undefined);
                });
            });
        }
        finally {
            this.syncMutex.unlock();
        }
    }
};
FileStopwatchStore = __decorate([
    injectable(),
    __metadata("design:paramtypes", [Config,
        Broker])
], FileStopwatchStore);
export { FileStopwatchStore };
//# sourceMappingURL=store.js.map