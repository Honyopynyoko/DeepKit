/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { ConnectionWriter, RpcKernel, RpcKernelBaseConnection, RpcKernelConnection, RpcKernelSecurity, SessionState } from '@deepkit/rpc';
import http from 'http';
import https from 'https';
import WebSocket from 'ws';
import { HttpKernel, HttpRequest, HttpResponse } from '@deepkit/http';
import { injectable, Injector, InjectorContext } from '@deepkit/injector';
import { RpcInjectorContext } from './rpc';
import { RpcControllers } from './application-service-container';
// @ts-ignore
import selfsigned from 'selfsigned';
import { join } from 'path';
import { existsSync, readFileSync, writeFileSync } from 'fs';
import { Logger } from '@deepkit/logger';
let WebWorkerFactory = class WebWorkerFactory {
    constructor(httpKernel, logger, rpcControllers, rootScopedContext) {
        this.httpKernel = httpKernel;
        this.logger = logger;
        this.rpcControllers = rpcControllers;
        this.rootScopedContext = rootScopedContext;
    }
    create(id, options) {
        return new WebWorker(id, this.logger, this.httpKernel, this.createRpcKernel(), this.rootScopedContext, options);
    }
    createRpcKernel() {
        const security = this.rootScopedContext.get(RpcKernelSecurity);
        const kernel = new RpcKernel(this.rootScopedContext, security, this.logger.scoped('rpc'));
        for (const [name, controller] of this.rpcControllers.controllers.entries()) {
            kernel.registerController(name, controller, false);
        }
        return kernel;
    }
};
WebWorkerFactory = __decorate([
    injectable(),
    __metadata("design:paramtypes", [HttpKernel,
        Logger,
        RpcControllers,
        InjectorContext])
], WebWorkerFactory);
export { WebWorkerFactory };
export class WebMemoryWorkerFactory extends WebWorkerFactory {
    create(id, options) {
        return new WebMemoryWorker(id, this.logger, this.httpKernel, this.createRpcKernel(), this.rootScopedContext, options);
    }
}
export function createRpcConnection(rootScopedContext, rpcKernel, writer, request) {
    let rpcScopedContext;
    let connection;
    const providers = [
        { provide: HttpRequest, useValue: request },
        { provide: RpcInjectorContext, useFactory: () => rpcScopedContext },
        { provide: SessionState, useFactory: () => connection.sessionState },
        { provide: RpcKernelConnection, useFactory: () => connection },
        { provide: RpcKernelBaseConnection, useFactory: () => connection },
        { provide: ConnectionWriter, useValue: writer },
    ];
    const additionalInjector = new Injector(providers);
    rpcScopedContext = rootScopedContext.createChildScope('rpc', additionalInjector);
    connection = rpcKernel.createConnection(writer, rpcScopedContext);
    return connection;
}
let WebWorker = class WebWorker {
    constructor(id, logger, httpKernel, rpcKernel, rootScopedContext, options) {
        this.id = id;
        this.logger = logger;
        this.httpKernel = httpKernel;
        this.rpcKernel = rpcKernel;
        this.rootScopedContext = rootScopedContext;
        this.options = options;
    }
    start() {
        if (this.options.server) {
            this.server = this.options.server;
            this.server.on('request', this.httpKernel.handleRequest.bind(this.httpKernel));
            this.wsServer = new WebSocket.Server({ server: this.server });
            this.wsServer.on('connection', this.onWsConnection.bind(this));
        }
        else {
            if (this.options.ssl) {
                const options = this.options.sslOptions || {};
                if (this.options.selfSigned) {
                    const keyPath = join(this.options.varPath, `self-signed-${this.options.host}.key`);
                    const certificatePath = join(this.options.varPath, `self-signed-${this.options.host}.cert`);
                    if (existsSync(keyPath) && existsSync(certificatePath)) {
                        options.key = readFileSync(keyPath, 'utf8');
                        options.cert = readFileSync(certificatePath, 'utf8');
                    }
                    else {
                        const attrs = [{ name: 'commonName', value: this.options.host }];
                        const pems = selfsigned.generate(attrs, { days: 365 });
                        options.cert = pems.cert;
                        options.key = pems.private;
                        writeFileSync(keyPath, pems.private, 'utf8');
                        writeFileSync(certificatePath, pems.cert, 'utf8');
                        this.logger.log(`Self signed certificate for ${this.options.host} created at ${certificatePath}`);
                        this.logger.log(`Tip: If you want to open this server via chrome for localhost, use chrome://flags/#allow-insecure-localhost`);
                    }
                }
                if (!options.key && this.options.sslKey)
                    options.key = readFileSync(this.options.sslKey, 'utf8');
                if (!options.ca && this.options.sslCa)
                    options.key = readFileSync(this.options.sslCa, 'utf8');
                if (!options.cert && this.options.sslCertificate)
                    options.cert = readFileSync(this.options.sslCertificate, 'utf8');
                if (!options.crl && this.options.sslCrl)
                    options.cert = readFileSync(this.options.sslCrl, 'utf8');
                this.servers = new https.Server(Object.assign({ IncomingMessage: HttpRequest, ServerResponse: HttpResponse, }, options), this.httpKernel.handleRequest.bind(this.httpKernel) //as any necessary since http.Server is not typed correctly
                );
                this.servers.listen(this.options.httpsPort || this.options.port, this.options.host);
                if (this.options.keepAliveTimeout)
                    this.servers.keepAliveTimeout = this.options.keepAliveTimeout;
                this.wssServer = new WebSocket.Server({ server: this.servers });
                this.wssServer.on('connection', this.onWsConnection.bind(this));
            }
            const startHttpServer = !this.servers || (this.servers && this.options.httpsPort);
            if (startHttpServer) {
                this.server = new http.Server({ IncomingMessage: HttpRequest, ServerResponse: HttpResponse }, this.httpKernel.handleRequest.bind(this.httpKernel) //as any necessary since http.Server is not typed correctly
                );
                if (this.options.keepAliveTimeout)
                    this.server.keepAliveTimeout = this.options.keepAliveTimeout;
                this.server.listen(this.options.port, this.options.host);
                this.wsServer = new WebSocket.Server({ server: this.server });
                this.wsServer.on('connection', this.onWsConnection.bind(this));
            }
        }
    }
    onWsConnection(ws, req) {
        const connection = createRpcConnection(this.rootScopedContext, this.rpcKernel, {
            write(b) {
                ws.send(b);
            },
            close() {
                ws.close();
            },
            bufferedAmount() {
                return ws.bufferedAmount;
            },
            clientAddress() {
                return req.getRemoteAddress();
            }
        }, req);
        ws.on('message', async (message) => {
            connection.feed(message);
        });
        ws.on('close', async () => {
            connection.close();
        });
    }
    close() {
        if (this.server)
            this.server.close();
        if (this.servers)
            this.servers.close();
    }
};
WebWorker = __decorate([
    injectable(),
    __metadata("design:paramtypes", [Number, Logger,
        HttpKernel,
        RpcKernel,
        InjectorContext, Object])
], WebWorker);
export { WebWorker };
export class WebMemoryWorker extends WebWorker {
    start() { }
}
//# sourceMappingURL=worker.js.map