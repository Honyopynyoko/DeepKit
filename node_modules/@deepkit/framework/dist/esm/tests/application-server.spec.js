var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { rpc } from '@deepkit/rpc';
import { expect, test } from '@jest/globals';
import 'reflect-metadata';
import { Application } from '../src/application';
import { AppModule } from '@deepkit/app';
import { InjectorContext } from '@deepkit/injector';
import { createTestingApp } from '../src/testing';
import { ApplicationServer } from '../src/application-server';
import { Logger, MemoryLoggerTransport } from '@deepkit/logger';
import { KernelModule } from '../src/kernel';
test('testing app api', async () => {
    let MyController = class MyController {
        constructor(logger) {
            this.logger = logger;
        }
        foo() {
            this.logger.log('bar');
            return 'bar';
        }
    };
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], MyController.prototype, "foo", null);
    MyController = __decorate([
        rpc.controller('test'),
        __metadata("design:paramtypes", [Logger])
    ], MyController);
    const testing = createTestingApp({ controllers: [MyController] });
    await testing.startServer();
    const client = testing.createRpcClient();
    const controller = client.controller('test');
    expect(await controller.foo()).toBe('bar');
    expect(testing.app.get(MemoryLoggerTransport).messageStrings.includes('bar'));
    await testing.stopServer();
});
test('basic controller', async () => {
    let createdControllers = 0;
    let MyController = class MyController {
        constructor() {
            createdControllers++;
        }
        foo() {
            return 'bar';
        }
    };
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], MyController.prototype, "foo", null);
    MyController = __decorate([
        rpc.controller('test'),
        __metadata("design:paramtypes", [])
    ], MyController);
    const appModule = new AppModule({
        controllers: [MyController],
        imports: [
            KernelModule.configure({
                broker: { startOnBootstrap: false }
            })
        ]
    });
    const app = new Application(appModule);
    const applicationServer = app.get(ApplicationServer);
    const injectorContext = app.get(InjectorContext);
    const controller = injectorContext.createChildScope('rpc').get(MyController);
    expect(controller.foo()).toBe('bar');
    createdControllers = 0;
    expect(createdControllers).toBe(0);
    await applicationServer.start();
    {
        const client = applicationServer.createClient();
        const controller = client.controller('test');
        const a = await controller.foo();
        expect(a).toBe('bar');
        expect(createdControllers).toBe(1);
        client.disconnect();
    }
    {
        const client = applicationServer.createClient();
        const controller = client.controller('test');
        const a = await controller.foo();
        expect(a).toBe('bar');
        expect(createdControllers).toBe(2);
        client.disconnect();
    }
    await applicationServer.close();
});
//# sourceMappingURL=application-server.spec.js.map