"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpListener = exports.JSONResponse = exports.HtmlResponse = exports.httpWorkflow = exports.HttpControllerErrorEvent = exports.HttpResponseEvent = exports.HttpControllerEvent = exports.HttpResolveParametersEvent = exports.HttpAccessDeniedEvent = exports.HttpAuthEvent = exports.HttpRouteEvent = exports.HttpWorkflowEventWithRoute = exports.HttpRouteNotFoundEvent = exports.HttpRequestEvent = exports.HttpWorkflowEvent = exports.HttpAccessDeniedError = exports.HttpBadRequestError = exports.HttpNotFoundError = exports.HttpError = exports.Redirect = void 0;
const core_1 = require("@deepkit/core");
const type_1 = require("@deepkit/type");
const http_1 = require("http");
const event_1 = require("@deepkit/event");
const model_1 = require("./model");
const injector_1 = require("@deepkit/injector");
const logger_1 = require("@deepkit/logger");
const router_1 = require("./router");
const workflow_1 = require("@deepkit/workflow");
const template_1 = require("@deepkit/template");
const stopwatch_1 = require("@deepkit/stopwatch");
class Redirect {
    constructor(statusCode = 302) {
        this.statusCode = statusCode;
    }
    static toRoute(routeName, parameters = {}, statusCode = 302) {
        const redirect = new Redirect(statusCode);
        redirect.routeName = routeName;
        redirect.routeParameters = parameters;
        return redirect;
    }
    static toUrl(url, statusCode = 302) {
        const redirect = new Redirect(statusCode);
        redirect.url = url;
        return redirect;
    }
}
exports.Redirect = Redirect;
function HttpError(code, defaultMessage = '') {
    return class extends core_1.CustomError {
        constructor(message = defaultMessage) {
            super(message);
        }
        static getHttpCode() {
            return code;
        }
    };
}
exports.HttpError = HttpError;
class HttpNotFoundError extends HttpError(404, 'Not found') {
}
exports.HttpNotFoundError = HttpNotFoundError;
class HttpBadRequestError extends HttpError(400, 'Bad request') {
}
exports.HttpBadRequestError = HttpBadRequestError;
class HttpAccessDeniedError extends HttpError(403, 'Access denied') {
}
exports.HttpAccessDeniedError = HttpAccessDeniedError;
class HttpWorkflowEvent {
    constructor(injectorContext, request, response) {
        this.injectorContext = injectorContext;
        this.request = request;
        this.response = response;
        this.stopped = false;
    }
    stopPropagation() {
        this.stopped = true;
    }
    isStopped() {
        return this.stopped;
    }
    clearNext() {
        this.nextState = undefined;
        this.nextStateEvent = undefined;
    }
    /**
     * @see WorkflowNextEvent.next
     */
    next(nextState, event) {
        this.nextState = nextState;
        this.nextStateEvent = event;
    }
    /**
     * Whether already a next workflow state has been scheduled.
     */
    hasNext() {
        return this.nextState !== undefined;
    }
    get url() {
        return this.request.url || '/';
    }
    /**
     * Whether a response has already been sent.
     */
    get sent() {
        return this.response.headersSent;
    }
    send(response) {
        this.next('response', new HttpResponseEvent(this.injectorContext, this.request, this.response, response));
    }
}
exports.HttpWorkflowEvent = HttpWorkflowEvent;
exports.HttpRequestEvent = HttpWorkflowEvent;
exports.HttpRouteNotFoundEvent = HttpWorkflowEvent;
class HttpWorkflowEventWithRoute extends HttpWorkflowEvent {
    constructor(injectorContext, request, response, route) {
        super(injectorContext, request, response);
        this.injectorContext = injectorContext;
        this.request = request;
        this.response = response;
        this.route = route;
    }
    send(response) {
        this.next('response', new HttpResponseEvent(this.injectorContext, this.request, this.response, response, this.route));
    }
    accessDenied() {
        this.next('accessDenied', new HttpAccessDeniedEvent(this.injectorContext, this.request, this.response, this.route));
    }
}
exports.HttpWorkflowEventWithRoute = HttpWorkflowEventWithRoute;
class HttpRouteEvent extends HttpWorkflowEvent {
    constructor(injectorContext, request, response, parameterResolver, route) {
        super(injectorContext, request, response);
        this.injectorContext = injectorContext;
        this.request = request;
        this.response = response;
        this.parameterResolver = parameterResolver;
        this.route = route;
    }
    routeFound(route, parameterResolver) {
        this.route = route;
        this.next('auth', new HttpAuthEvent(this.injectorContext, this.request, this.response, this.route, parameterResolver));
    }
    notFound() {
        this.next('routeNotFound', new exports.HttpRouteNotFoundEvent(this.injectorContext, this.request, this.response));
    }
}
exports.HttpRouteEvent = HttpRouteEvent;
class HttpAuthEvent extends HttpWorkflowEventWithRoute {
    constructor(injectorContext, request, response, route, parameterResolver) {
        super(injectorContext, request, response, route);
        this.injectorContext = injectorContext;
        this.request = request;
        this.response = response;
        this.route = route;
        this.parameterResolver = parameterResolver;
    }
    success() {
        this.next('resolveParameters', new HttpResolveParametersEvent(this.injectorContext, this.request, this.response, this.parameterResolver, this.route));
    }
}
exports.HttpAuthEvent = HttpAuthEvent;
class HttpAccessDeniedEvent extends HttpWorkflowEvent {
    constructor(injectorContext, request, response, route) {
        super(injectorContext, request, response);
        this.injectorContext = injectorContext;
        this.request = request;
        this.response = response;
        this.route = route;
    }
}
exports.HttpAccessDeniedEvent = HttpAccessDeniedEvent;
class HttpResolveParametersEvent extends HttpWorkflowEventWithRoute {
    constructor(injectorContext, request, response, parameterResolver, route) {
        super(injectorContext, request, response, route);
        this.injectorContext = injectorContext;
        this.request = request;
        this.response = response;
        this.parameterResolver = parameterResolver;
        this.route = route;
        this.parameters = [];
    }
    accessDenied() {
        this.next('accessDenied', new HttpAccessDeniedEvent(this.injectorContext, this.request, this.response, this.route));
    }
}
exports.HttpResolveParametersEvent = HttpResolveParametersEvent;
class HttpControllerEvent extends HttpWorkflowEventWithRoute {
    constructor(injectorContext, request, response, parameters = [], route) {
        super(injectorContext, request, response, route);
        this.injectorContext = injectorContext;
        this.request = request;
        this.response = response;
        this.parameters = parameters;
        this.route = route;
    }
}
exports.HttpControllerEvent = HttpControllerEvent;
class HttpResponseEvent extends workflow_1.WorkflowEvent {
    constructor(injectorContext, request, response, result, route) {
        super();
        this.injectorContext = injectorContext;
        this.request = request;
        this.response = response;
        this.result = result;
        this.route = route;
        /**
         * The time it took to call the controller action in milliseconds.
         */
        this.controllerActionTime = 0;
    }
}
exports.HttpResponseEvent = HttpResponseEvent;
class HttpControllerErrorEvent extends HttpWorkflowEventWithRoute {
    constructor(injectorContext, request, response, route, error) {
        super(injectorContext, request, response, route);
        this.injectorContext = injectorContext;
        this.request = request;
        this.response = response;
        this.route = route;
        this.error = error;
    }
}
exports.HttpControllerErrorEvent = HttpControllerErrorEvent;
exports.httpWorkflow = workflow_1.createWorkflow('http', {
    start: workflow_1.WorkflowEvent,
    request: exports.HttpRequestEvent,
    route: HttpRouteEvent,
    routeNotFound: exports.HttpRouteNotFoundEvent,
    auth: HttpAuthEvent,
    resolveParameters: HttpResolveParametersEvent,
    accessDenied: HttpAccessDeniedEvent,
    controller: HttpControllerEvent,
    controllerError: HttpControllerErrorEvent,
    parametersFailed: HttpControllerErrorEvent,
    response: HttpResponseEvent,
}, {
    start: 'request',
    request: 'route',
    route: ['auth', 'routeNotFound'],
    auth: ['resolveParameters', 'accessDenied'],
    resolveParameters: ['controller', 'parametersFailed'],
    accessDenied: 'response',
    controller: ['accessDenied', 'controllerError', 'response'],
    controllerError: 'response',
    parametersFailed: 'response',
    routeNotFound: 'response',
});
class HtmlResponse {
    constructor(html, statusCode) {
        this.html = html;
        this.statusCode = statusCode;
    }
}
exports.HtmlResponse = HtmlResponse;
class JSONResponse {
    constructor(json, statusCode) {
        this.json = json;
        this.statusCode = statusCode;
    }
}
exports.JSONResponse = JSONResponse;
let HttpListener = class HttpListener {
    constructor(router, logger, stopwatch) {
        this.router = router;
        this.logger = logger;
        this.stopwatch = stopwatch;
    }
    onRequest(event) {
        if (event.sent)
            return;
        if (event.hasNext())
            return;
        event.next('route', new HttpRouteEvent(event.injectorContext, event.request, event.response));
    }
    onRoute(event) {
        if (event.sent)
            return;
        if (event.hasNext())
            return;
        const resolved = this.router.resolveRequest(event.request);
        if (resolved) {
            event.request.uploadedFiles = resolved.uploadedFiles;
            event.routeFound(resolved.routeConfig, resolved.parameters);
        }
    }
    onRouteForward(event) {
        if (event.sent)
            return;
        if (event.hasNext())
            return;
        if (!event.route) {
            event.next('routeNotFound', new exports.HttpRouteNotFoundEvent(event.injectorContext, event.request, event.response));
        }
    }
    async routeNotFound(event) {
        if (event.sent)
            return;
        if (event.hasNext())
            return;
        event.send(new HtmlResponse('Not found', 404));
    }
    onAuth(event) {
        if (event.sent)
            return;
        if (event.hasNext())
            return;
        event.next('resolveParameters', new HttpResolveParametersEvent(event.injectorContext, event.request, event.response, event.parameterResolver, event.route));
    }
    async onResolveParameters(event) {
        if (event.response.finished)
            return;
        if (event.hasNext())
            return;
        try {
            event.parameters = await event.parameterResolver(event.injectorContext);
            event.next('controller', new HttpControllerEvent(event.injectorContext, event.request, event.response, event.parameters, event.route));
        }
        catch (error) {
            event.next('parametersFailed', new HttpControllerErrorEvent(event.injectorContext, event.request, event.response, event.route, error));
        }
    }
    onAccessDenied(event) {
        if (event.sent)
            return;
        if (event.hasNext())
            return;
        event.send(new HtmlResponse('Access denied', 403));
    }
    async onController(event) {
        if (event.sent)
            return;
        if (event.hasNext())
            return;
        const controllerInstance = event.injectorContext.get(event.route.action.controller);
        try {
            const start = Date.now();
            const method = controllerInstance[event.route.action.methodName];
            const responseEvent = new HttpResponseEvent(event.injectorContext, event.request, event.response, await method.apply(controllerInstance, event.parameters), event.route);
            responseEvent.controllerActionTime = Date.now() - start;
            event.next('response', responseEvent);
        }
        catch (error) {
            if (error instanceof HttpAccessDeniedError) {
                event.next('accessDenied', new HttpAccessDeniedEvent(event.injectorContext, event.request, event.response, event.route));
            }
            else {
                event.next('controllerError', new HttpControllerErrorEvent(event.injectorContext, event.request, event.response, event.route, error));
            }
        }
    }
    onParametersFailed(event) {
        if (event.response.finished)
            return;
        if (event.sent)
            return;
        this.logger.error('Controller parameter resolving error:', event.error);
        if (event.error instanceof type_1.ValidationFailed) {
            event.send(new JSONResponse({
                message: event.error.message,
                errors: event.error.errors
            }, 500));
        }
        else {
            event.send(new HtmlResponse('Internal error', 500));
        }
    }
    onControllerError(event) {
        if (event.response.finished)
            return;
        if (event.sent)
            return;
        this.logger.error('Controller error', event.error);
        event.send(new HtmlResponse('Internal error', 500));
    }
    /**
     * This happens before the result is sent.
     */
    async onResultSerialization(event) {
        var _a;
        if (event.route && event.route.returnSchema && event.route.returnSchema.typeSet) {
            if (event.result !== undefined) {
                event.result = type_1.getPropertyClassToXFunction(event.route.returnSchema, event.route && ((_a = event.route) === null || _a === void 0 ? void 0 : _a.serializer) ? event.route.serializer : type_1.jsonSerializer)(event.result, event.route.serializationOptions);
            }
        }
    }
    async onResponse(event) {
        var _a;
        const response = event.result;
        if (response === null || response === undefined) {
            event.response.end(response);
        }
        else if (response instanceof Redirect) {
            if (response.routeName) {
                event.response.writeHead(response.statusCode, {
                    Location: this.router.resolveUrl(response.routeName, response.routeParameters)
                });
            }
            else {
                event.response.writeHead(response.statusCode, {
                    Location: response.url
                });
            }
            event.response.end();
        }
        else if (response instanceof http_1.ServerResponse || response instanceof model_1.HttpResponse) {
        }
        else if (response instanceof HtmlResponse) {
            event.response.setHeader('Content-Type', 'text/html; charset=utf-8');
            if (response.statusCode)
                event.response.writeHead(response.statusCode);
            event.response.end(response.html);
        }
        else if (template_1.isElementStruct(response)) {
            event.response.setHeader('Content-Type', 'text/html; charset=utf-8');
            event.response.end(await template_1.render(event.injectorContext, response, this.stopwatch.active ? this.stopwatch : undefined));
        }
        else if (type_1.isClassInstance(response) && type_1.isRegisteredEntity(type_1.getClassTypeFromInstance(response))) {
            event.response.setHeader('Content-Type', 'application/json; charset=utf-8');
            event.response.end(JSON.stringify((event.route && ((_a = event.route) === null || _a === void 0 ? void 0 : _a.serializer) ? event.route.serializer : type_1.jsonSerializer)
                .for(type_1.getClassTypeFromInstance(response)).serialize(response, event.route ? event.route.serializationOptions : undefined)));
        }
        else if (response instanceof Uint8Array) {
            event.response.end(response);
        }
        else if (response instanceof JSONResponse) {
            event.response.setHeader('Content-Type', 'application/json; charset=utf-8');
            if (response.statusCode)
                event.response.writeHead(response.statusCode);
            event.response.end(JSON.stringify(response.json));
        }
        else {
            event.response.setHeader('Content-Type', 'application/json; charset=utf-8');
            event.response.end(JSON.stringify(response));
        }
    }
};
__decorate([
    event_1.eventDispatcher.listen(exports.httpWorkflow.onRequest, 100),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], HttpListener.prototype, "onRequest", null);
__decorate([
    event_1.eventDispatcher.listen(exports.httpWorkflow.onRoute, 100),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], HttpListener.prototype, "onRoute", null);
__decorate([
    event_1.eventDispatcher.listen(exports.httpWorkflow.onRoute, 1000),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], HttpListener.prototype, "onRouteForward", null);
__decorate([
    event_1.eventDispatcher.listen(exports.httpWorkflow.onRouteNotFound, 100),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], HttpListener.prototype, "routeNotFound", null);
__decorate([
    event_1.eventDispatcher.listen(exports.httpWorkflow.onAuth, 100),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], HttpListener.prototype, "onAuth", null);
__decorate([
    event_1.eventDispatcher.listen(exports.httpWorkflow.onResolveParameters, 100),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], HttpListener.prototype, "onResolveParameters", null);
__decorate([
    event_1.eventDispatcher.listen(exports.httpWorkflow.onAccessDenied, 100),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], HttpListener.prototype, "onAccessDenied", null);
__decorate([
    event_1.eventDispatcher.listen(exports.httpWorkflow.onController, 100),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], HttpListener.prototype, "onController", null);
__decorate([
    event_1.eventDispatcher.listen(exports.httpWorkflow.onParametersFailed, 100),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], HttpListener.prototype, "onParametersFailed", null);
__decorate([
    event_1.eventDispatcher.listen(exports.httpWorkflow.onControllerError, 100),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], HttpListener.prototype, "onControllerError", null);
__decorate([
    event_1.eventDispatcher.listen(exports.httpWorkflow.onResponse, -100),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], HttpListener.prototype, "onResultSerialization", null);
__decorate([
    event_1.eventDispatcher.listen(exports.httpWorkflow.onResponse, 100),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], HttpListener.prototype, "onResponse", null);
HttpListener = __decorate([
    injector_1.injectable(),
    __metadata("design:paramtypes", [router_1.Router,
        logger_1.Logger,
        stopwatch_1.Stopwatch])
], HttpListener);
exports.HttpListener = HttpListener;
//# sourceMappingURL=http.js.map