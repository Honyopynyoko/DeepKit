import 'reflect-metadata';
import { ClassType, CompilerContext } from '@deepkit/core';
import { JitConverterOptions, PropertySchema, Serializer, ValidationFailedItem } from '@deepkit/type';
import { HttpRequest, HttpRequestQuery, HttpRequestResolvedParameters } from './model';
import { BasicInjector, NormalizedProvider, Tag, TagProvider, TagRegistry } from '@deepkit/injector';
import { Logger } from '@deepkit/logger';
import { HttpControllers } from './controllers';
export declare type RouteParameterResolverForInjector = ((injector: BasicInjector) => any[] | Promise<any[]>);
declare type ResolvedController = {
    parameters: RouteParameterResolverForInjector;
    routeConfig: RouteConfig;
    uploadedFiles: {
        [name: string]: UploadedFile;
    };
};
export declare class UploadedFile {
    /**
     * The size of the uploaded file in bytes.
     */
    size: number;
    /**
     * The path this file is being written to.
     */
    path: string;
    /**
     * The name this file had according to the uploading client.
     */
    name: string | null;
    /**
     * The mime type of this file, according to the uploading client.
     */
    type: string | null;
    /**
     * A Date object (or `null`) containing the time this file was last written to.
     * Mostly here for compatibility with the [W3C File API Draft](http://dev.w3.org/2006/webapi/FileAPI/).
     */
    lastModifiedDate: Date | null;
}
export interface RouteControllerAction {
    controller: ClassType;
    methodName: string;
}
export interface RouteParameterConfig {
    type?: 'body' | 'query';
    /**
     * undefined = propertyName, '' === root, else given path
     */
    typePath?: string;
    optional: boolean;
    name: string;
}
export declare class RouteConfig {
    readonly name: string;
    readonly httpMethod: string;
    readonly path: string;
    readonly action: RouteControllerAction;
    baseUrl: string;
    parameterRegularExpressions: {
        [name: string]: any;
    };
    throws: {
        errorType: ClassType;
        message?: string;
    }[];
    description: string;
    groups: string[];
    category: string;
    /**
     * This is set when the route action has a manual return type defined using @t.
     */
    returnSchema?: PropertySchema;
    serializationOptions?: JitConverterOptions;
    serializer?: Serializer;
    /**
     * An arbitrary data container the user can use to store app specific settings/values.
     */
    data: Map<any, any>;
    parameters: {
        [name: string]: RouteParameterConfig;
    };
    constructor(name: string, httpMethod: string, path: string, action: RouteControllerAction);
    getFullPath(): string;
}
/**
 * When this class is injected into a route, then validation errors are not automatically thrown (using onHttpControllerValidationError event),
 * but injected to the route itself. The user is then responsible to handle the errors.
 *
 * Note: The body parameter is still passed, however it might contain now invalid data. The BodyValidation tells what data is invalid.
 */
export declare class BodyValidation {
    readonly errors: ValidationFailedItem[];
    constructor(errors?: ValidationFailedItem[]);
    hasErrors(prefix?: string): boolean;
    getErrors(prefix?: string): ValidationFailedItem[];
    getErrorsForPath(path: string): ValidationFailedItem[];
    getErrorMessageForPath(path: string): string;
}
declare class ParsedRoute {
    routeConfig: RouteConfig;
    regex?: string;
    customValidationErrorHandling?: ParsedRouteParameter;
    pathParameterNames: {
        [name: string]: number;
    };
    protected parameters: ParsedRouteParameter[];
    constructor(routeConfig: RouteConfig);
    addParameter(property: PropertySchema, config?: RouteParameterConfig): ParsedRouteParameter;
    getParameters(): ParsedRouteParameter[];
    getParameter(name: string): ParsedRouteParameter;
}
declare class ParsedRouteParameter {
    property: PropertySchema;
    config?: RouteParameterConfig | undefined;
    regexPosition?: number;
    constructor(property: PropertySchema, config?: RouteParameterConfig | undefined);
    get body(): boolean;
    get query(): boolean;
    get typePath(): string | undefined;
    getName(): string;
    isPartOfPath(): boolean;
}
export declare function parseRouteControllerAction(routeConfig: RouteConfig): ParsedRoute;
export declare function dotToUrlPath(dotPath: string): string;
export interface RouteParameterResolver {
    resolve(context: RouteParameterResolverContext): any | Promise<any>;
}
export interface RouteParameterResolverContext {
    classType: ClassType;
    route: RouteConfig;
    request: HttpRequest;
    /**
     * The parameter name (variable name).
     */
    name: any;
    /**
     * The raw parameter value from the path, if the parameter is defined in the path (e.g. /user/:name).
     * If not in the path, you have to use `parameters.<name>` instead.
     */
    value: any;
    query: HttpRequestQuery;
    parameters: HttpRequestResolvedParameters;
}
export declare class ParameterResolverTagProvider extends TagProvider<any> {
    classTypes: ClassType[];
    forClassType(...classTypes: ClassType[]): this;
}
export declare class RouteParameterResolverTag extends Tag<RouteParameterResolver, ParameterResolverTagProvider> {
    protected createTagProvider(provider: NormalizedProvider<any>): ParameterResolverTagProvider;
}
export declare class Router {
    private logger;
    protected fn?: (request: HttpRequest) => ResolvedController | undefined;
    protected resolveFn?: (name: string, parameters: {
        [name: string]: any;
    }) => string;
    protected routes: RouteConfig[];
    protected parameterResolverTags: TagProvider<RouteParameterResolverTag>[];
    protected form: any;
    constructor(controllers: HttpControllers, logger: Logger, tagRegistry: TagRegistry);
    getRoutes(): RouteConfig[];
    static forControllers(controllers: ClassType[], tagRegistry?: TagRegistry): Router;
    protected getRouteCode(compiler: CompilerContext, routeConfig: RouteConfig): string;
    protected getRouteUrlResolveCode(compiler: CompilerContext, routeConfig: RouteConfig): string;
    addRoute(routeConfig: RouteConfig): void;
    addRouteForController(controller: ClassType): void;
    protected build(): any;
    protected buildUrlResolver(): any;
    resolveUrl(routeName: string, parameters?: {
        [name: string]: any;
    }): string;
    resolveRequest(request: HttpRequest): ResolvedController | undefined;
    resolve(method: string, url: string): ResolvedController | undefined;
}
export {};
