"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Router = exports.RouteParameterResolverTag = exports.ParameterResolverTagProvider = exports.dotToUrlPath = exports.parseRouteControllerAction = exports.BodyValidation = exports.RouteConfig = exports.UploadedFile = void 0;
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
require("reflect-metadata");
const core_1 = require("@deepkit/core");
const type_1 = require("@deepkit/type");
// @ts-ignore
const formidable_1 = __importDefault(require("formidable"));
const querystring_1 = __importDefault(require("querystring"));
const decorator_1 = require("./decorator");
const injector_1 = require("@deepkit/injector");
const logger_1 = require("@deepkit/logger");
const controllers_1 = require("./controllers");
class UploadedFile {
}
__decorate([
    type_1.t.required,
    __metadata("design:type", Number)
], UploadedFile.prototype, "size", void 0);
__decorate([
    type_1.t.required,
    __metadata("design:type", String)
], UploadedFile.prototype, "path", void 0);
__decorate([
    type_1.t.string.required.nullable,
    __metadata("design:type", Object)
], UploadedFile.prototype, "name", void 0);
__decorate([
    type_1.t.string.required.nullable,
    __metadata("design:type", Object)
], UploadedFile.prototype, "type", void 0);
__decorate([
    type_1.t.date.required.nullable,
    __metadata("design:type", Object)
], UploadedFile.prototype, "lastModifiedDate", void 0);
exports.UploadedFile = UploadedFile;
function parseBody(form, req, files) {
    return core_1.asyncOperation((resolve, reject) => {
        form.on('file', (name, file) => {
            files[name] = file;
        });
        form.parse(req, (err, fields, files) => {
            if (err) {
                reject(err);
            }
            else {
                resolve({ fields, files });
            }
        });
    });
}
class RouteConfig {
    constructor(name, httpMethod, path, action) {
        this.name = name;
        this.httpMethod = httpMethod;
        this.path = path;
        this.action = action;
        this.baseUrl = '';
        this.parameterRegularExpressions = {};
        this.throws = [];
        this.description = '';
        this.groups = [];
        this.category = '';
        /**
         * An arbitrary data container the user can use to store app specific settings/values.
         */
        this.data = new Map();
        this.parameters = {};
    }
    getFullPath() {
        let path = this.baseUrl ? core_1.urlJoin(this.baseUrl, this.path) : this.path;
        if (!path.startsWith('/'))
            path = '/' + path;
        return path;
    }
}
exports.RouteConfig = RouteConfig;
/**
 * When this class is injected into a route, then validation errors are not automatically thrown (using onHttpControllerValidationError event),
 * but injected to the route itself. The user is then responsible to handle the errors.
 *
 * Note: The body parameter is still passed, however it might contain now invalid data. The BodyValidation tells what data is invalid.
 */
class BodyValidation {
    constructor(errors = []) {
        this.errors = errors;
    }
    hasErrors(prefix) {
        return this.getErrors(prefix).length > 0;
    }
    getErrors(prefix) {
        if (prefix)
            return this.errors.filter(v => v.path.startsWith(prefix));
        return this.errors;
    }
    getErrorsForPath(path) {
        return this.errors.filter(v => v.path === path);
    }
    getErrorMessageForPath(path) {
        return this.getErrorsForPath(path).map(v => v.message).join(', ');
    }
}
exports.BodyValidation = BodyValidation;
class ParsedRoute {
    constructor(routeConfig) {
        this.routeConfig = routeConfig;
        this.pathParameterNames = {};
        this.parameters = [];
    }
    addParameter(property, config) {
        const parameter = new ParsedRouteParameter(property, config);
        this.parameters.push(parameter);
        return parameter;
    }
    getParameters() {
        return this.parameters;
    }
    getParameter(name) {
        for (const parameter of this.parameters) {
            if (parameter.getName() === name)
                return parameter;
        }
        throw new Error(`No route parameter with name ${name} defined.`);
    }
}
class ParsedRouteParameter {
    constructor(property, config) {
        this.property = property;
        this.config = config;
    }
    get body() {
        return this.config ? this.config.type === 'body' : false;
    }
    get query() {
        return this.config ? this.config.type === 'query' : false;
    }
    get typePath() {
        return this.config ? this.config.typePath : undefined;
    }
    getName() {
        return this.property.name;
    }
    isPartOfPath() {
        return this.regexPosition !== undefined;
    }
}
function parseRoutePathToRegex(routeConfig) {
    const parameterNames = {};
    let path = routeConfig.getFullPath();
    let argumentIndex = 0;
    path = path.replace(/:(\w+)/g, (a, name) => {
        parameterNames[name] = argumentIndex;
        argumentIndex++;
        return routeConfig.parameterRegularExpressions[name] ? '(' + routeConfig.parameterRegularExpressions[name] + ')' : String.raw `([^/]+)`;
    });
    return { regex: path, parameterNames };
}
function parseRouteControllerAction(routeConfig) {
    const schema = type_1.getClassSchema(routeConfig.action.controller);
    const parsedRoute = new ParsedRoute(routeConfig);
    const methodArgumentProperties = schema.getMethodProperties(routeConfig.action.methodName);
    const parsedPath = parseRoutePathToRegex(routeConfig);
    parsedRoute.regex = parsedPath.regex;
    parsedRoute.pathParameterNames = parsedPath.parameterNames;
    for (const property of methodArgumentProperties) {
        const decoratorData = routeConfig.parameters[property.name];
        const parsedParameter = parsedRoute.addParameter(property, decoratorData);
        if (decoratorData && decoratorData.optional)
            property.isOptional = true;
        if (property.type === 'class' && property.classType === BodyValidation) {
            parsedRoute.customValidationErrorHandling = parsedParameter;
        }
        parsedParameter.regexPosition = parsedPath.parameterNames[property.name];
    }
    return parsedRoute;
}
exports.parseRouteControllerAction = parseRouteControllerAction;
function dotToUrlPath(dotPath) {
    if (-1 === dotPath.indexOf('.'))
        return dotPath;
    return dotPath.replace(/\./g, '][').replace('][', '[') + ']';
}
exports.dotToUrlPath = dotToUrlPath;
class ParameterResolverTagProvider extends injector_1.TagProvider {
    constructor() {
        super(...arguments);
        this.classTypes = [];
    }
    forClassType(...classTypes) {
        this.classTypes = classTypes;
        return this;
    }
}
exports.ParameterResolverTagProvider = ParameterResolverTagProvider;
class RouteParameterResolverTag extends injector_1.Tag {
    createTagProvider(provider) {
        return new ParameterResolverTagProvider(provider, this);
    }
}
exports.RouteParameterResolverTag = RouteParameterResolverTag;
let Router = class Router {
    constructor(controllers, logger, tagRegistry) {
        this.logger = logger;
        this.routes = [];
        this.parameterResolverTags = [];
        //todo, move some settings to KernelConfig
        this.form = formidable_1.default({
            multiples: true,
            hash: 'sha1',
            enabledPlugins: ['octetstream', 'querystring', 'json'],
        });
        this.parameterResolverTags = tagRegistry.resolve(RouteParameterResolverTag);
        for (const controller of controllers.controllers)
            this.addRouteForController(controller);
    }
    getRoutes() {
        return this.routes;
    }
    static forControllers(controllers, tagRegistry = new injector_1.TagRegistry()) {
        return new this(new controllers_1.HttpControllers(controllers), new logger_1.Logger([], []), tagRegistry);
    }
    getRouteCode(compiler, routeConfig) {
        const routeConfigVar = compiler.reserveVariable('routeConfigVar', routeConfig);
        const parsedRoute = parseRouteControllerAction(routeConfig);
        const path = routeConfig.getFullPath();
        const prefix = path.substr(0, path.indexOf(':'));
        const regexVar = compiler.reserveVariable('regex', new RegExp('^' + parsedRoute.regex + '$'));
        const setParameters = [];
        const parameterNames = [];
        const parameterValidator = [];
        let bodyValidationErrorHandling = `if (bodyErrors.length) throw ValidationFailed.from(bodyErrors);`;
        let enableParseBody = false;
        const hasParameters = parsedRoute.getParameters().length > 0;
        let requiresAsyncParameters = false;
        let setParametersFromPath = '';
        for (const parameter of parsedRoute.getParameters()) {
            if (parsedRoute.customValidationErrorHandling === parameter) {
                compiler.context.set('BodyValidation', BodyValidation);
                bodyValidationErrorHandling = '';
                setParameters.push(`parameters.${parameter.property.name} = new BodyValidation(bodyErrors);`);
                parameterNames.push(`parameters.${parameter.property.name}`);
            }
            else if (parameter.body) {
                const validatorVar = compiler.reserveVariable('argumentValidator', type_1.jitValidateProperty(parameter.property));
                const converterVar = compiler.reserveVariable('argumentConverter', type_1.getPropertyXtoClassFunction(parameter.property, type_1.jsonSerializer));
                enableParseBody = true;
                setParameters.push(`parameters.${parameter.property.name} = ${converterVar}(bodyFields);`);
                parameterValidator.push(`${validatorVar}(parameters.${parameter.property.name}, ${JSON.stringify(parameter.typePath || '')}, bodyErrors);`);
                parameterNames.push(`parameters.${parameter.property.name}`);
            }
            else if (parameter.query) {
                const converted = parameter.property.type === 'any' ? (v) => v : type_1.getPropertyXtoClassFunction(parameter.property, type_1.jsonSerializer);
                const validator = parameter.property.type === 'any' ? (v) => undefined : type_1.jitValidateProperty(parameter.property);
                const converterVar = compiler.reserveVariable('argumentConverter', converted);
                const validatorVar = compiler.reserveVariable('argumentValidator', validator);
                const queryPath = parameter.typePath === undefined ? parameter.property.name : parameter.typePath;
                const accessor = queryPath ? `['` + (queryPath.replace(/\./g, `']['`)) + `']` : '';
                const queryAccessor = queryPath ? `_query${accessor}` : '_query';
                setParameters.push(`parameters.${parameter.property.name} = ${converterVar}(${queryAccessor});`);
                parameterNames.push(`parameters.${parameter.property.name}`);
                parameterValidator.push(`${validatorVar}(${queryAccessor}, ${JSON.stringify(parameter.typePath)}, validationErrors);`);
            }
            else {
                parameterNames.push(`parameters.${parameter.property.name}`);
                if (parameter.isPartOfPath()) {
                    if (parameter.property.type !== 'class') {
                        const converted = parameter.property.type === 'any' ? (v) => v : type_1.getPropertyXtoClassFunction(parameter.property, type_1.jsonSerializer);
                        const converterVar = compiler.reserveVariable('argumentConverter', converted);
                        setParameters.push(`parameters.${parameter.property.name} = ${converterVar}(_match[${1 + (parameter.regexPosition || 0)}]);`);
                        const validator = parameter.property.type === 'any' ? (v) => undefined : type_1.jitValidateProperty(parameter.property);
                        const validatorVar = compiler.reserveVariable('argumentValidator', validator);
                        parameterValidator.push(`${validatorVar}(parameters.${parameter.property.name}, ${JSON.stringify(parameter.getName())}, validationErrors);`);
                    }
                    else {
                        setParameters.push(`parameters.${parameter.property.name} =_match[${1 + (parameter.regexPosition || 0)}];`);
                    }
                }
                if (parameter.property.type === 'class') {
                    const classType = parameter.property.getResolvedClassType();
                    const classTypeVar = compiler.reserveVariable('classType', classType);
                    const parameterResolverFoundVar = compiler.reserveVariable('parameterResolverFound', false);
                    setParameters.push(`${parameterResolverFoundVar} = false;`);
                    //make sure all parameter values from the path are available
                    if (this.parameterResolverTags.length && !setParametersFromPath) {
                        for (const i in parsedRoute.pathParameterNames) {
                            setParametersFromPath += `parameters.${i} = _match[${1 + parsedRoute.pathParameterNames[i]}];`;
                        }
                    }
                    for (const resolverTag of this.parameterResolverTags) {
                        if (resolverTag instanceof ParameterResolverTagProvider && resolverTag.classTypes.length && !resolverTag.classTypes.includes(classType))
                            continue;
                        const resolverProvideTokenVar = compiler.reserveVariable('resolverProvideToken', resolverTag.provider.provide);
                        requiresAsyncParameters = true;
                        const instance = compiler.reserveVariable('resolverInstance');
                        setParameters.push(`
                            //resolver ${core_1.getClassName(resolverTag.provider.provide)} for ${parameter.getName()}
                            ${instance} = _injector.get(${resolverProvideTokenVar});
                            if (!${parameterResolverFoundVar}) {
                                ${parameterResolverFoundVar} = true;
                                parameters.${parameter.property.name} = await ${instance}.resolve({
                                    classType: ${classTypeVar},
                                    routeConfig: ${routeConfigVar},
                                    request: request,
                                    name: ${JSON.stringify(parameter.property.name)},
                                    value: parameters.${parameter.property.name},
                                    query: _query,
                                    parameters: parameters
                                });
                            }`);
                    }
                    setParameters.push(`if (!${parameterResolverFoundVar}) parameters.${parameter.property.name} = _injector.get(${classTypeVar});`);
                }
            }
        }
        let parseBodyLoading = '';
        if (enableParseBody) {
            const parseBodyVar = compiler.reserveVariable('parseBody', parseBody);
            const formVar = compiler.reserveVariable('form', this.form);
            parseBodyLoading = `
            const bodyParsed = (await ${parseBodyVar}(${formVar}, request, uploadedFiles));
            const bodyFields = {...bodyParsed.fields, ...bodyParsed.files};`;
            requiresAsyncParameters = true;
        }
        let matcher = `_path.startsWith(${JSON.stringify(prefix)}) && (_match = _path.match(${regexVar}))`;
        if (!hasParameters) {
            matcher = `_path === ${JSON.stringify(path)}`;
        }
        let parameters = '() => []';
        if (setParameters.length) {
            parameters = `${requiresAsyncParameters ? 'async' : ''} function(_injector){
                const validationErrors = [];
                const bodyErrors = [];
                const parameters = {};
                ${setParametersFromPath}
                ${parseBodyLoading}
                ${setParameters.join('\n')}
                ${parameterValidator.join('\n')}
                ${bodyValidationErrorHandling}
                if (validationErrors.length) throw ValidationFailed.from(validationErrors);
                return [${parameterNames.join(',')}];
            }`;
        }
        return `
            //=> ${path}
            if (_method === '${routeConfig.httpMethod.toLowerCase()}' && ${matcher}) {
                return {routeConfig: ${routeConfigVar}, parameters: ${parameters}, uploadedFiles: uploadedFiles};
            }
        `;
    }
    getRouteUrlResolveCode(compiler, routeConfig) {
        const parsedRoute = parseRouteControllerAction(routeConfig);
        let url = routeConfig.getFullPath();
        url = url.replace(/:(\w+)/g, (a, name) => {
            return `\${parameters.${name}}`;
        });
        const modify = [];
        for (const parameter of parsedRoute.getParameters()) {
            if (parameter.query) {
                const queryPath = parameter.typePath === undefined ? parameter.property.name : parameter.typePath;
                if (parameter.property.type === 'class') {
                    for (const property of parameter.property.getResolvedClassSchema().getProperties()) {
                        const accessor = `parameters.${parameter.getName()}?.${property.name}`;
                        const thisPath = queryPath ? queryPath + '.' + property.name : property.name;
                        modify.push(`${accessor} !== undefined && query.push(${JSON.stringify(dotToUrlPath(thisPath))} + '=' + encodeURIComponent(${accessor}))`);
                    }
                }
                else {
                    modify.push(`parameters.${parameter.getName()} !== undefined && query.push(${JSON.stringify(dotToUrlPath(queryPath))} + '=' + encodeURIComponent(parameters.${parameter.getName()}))`);
                }
            }
        }
        return `
            case ${JSON.stringify(routeConfig.name)}: {
                let url = \`${url}\`;
                let query = [];
                ${modify.join('\n')}
                return url + (query.length ? '?'+query.join('&') : '');
            }
        `;
    }
    addRoute(routeConfig) {
        this.routes.push(routeConfig);
        this.fn = undefined;
    }
    addRouteForController(controller) {
        const data = decorator_1.httpClass._fetch(controller);
        if (!data)
            return;
        const schema = type_1.getClassSchema(controller);
        for (const action of data.getActions()) {
            const routeConfig = new RouteConfig(action.name, action.httpMethod, action.path, {
                controller,
                methodName: action.methodName
            });
            routeConfig.parameterRegularExpressions = action.parameterRegularExpressions;
            routeConfig.throws = action.throws;
            routeConfig.description = action.description;
            routeConfig.category = action.category;
            routeConfig.groups = action.groups;
            routeConfig.data = new Map(action.data);
            routeConfig.baseUrl = data.baseUrl;
            routeConfig.parameters = { ...action.parameters };
            routeConfig.serializationOptions = action.serializationOptions;
            routeConfig.serializer = action.serializer;
            if (schema.hasMethod(action.methodName))
                routeConfig.returnSchema = schema.getMethod(action.methodName);
            this.addRoute(routeConfig);
        }
    }
    build() {
        const compiler = new core_1.CompilerContext;
        compiler.context.set('_match', null);
        compiler.context.set('ValidationFailed', type_1.ValidationFailed);
        compiler.context.set('parseQueryString', querystring_1.default.parse);
        const code = [];
        for (const route of this.routes) {
            code.push(this.getRouteCode(compiler, route));
        }
        return compiler.build(`
            const _method = request.getMethod().toLowerCase();
            const _url = request.getUrl();
            const _qPosition = _url.indexOf('?');
            let uploadedFiles = {};
            const _path = _qPosition === -1 ? _url : _url.substr(0, _qPosition);
            const _query = _qPosition === -1 ? {} : parseQueryString(_url.substr(_qPosition + 1));
            ${code.join('\n')}
        `, 'request');
    }
    buildUrlResolver() {
        const compiler = new core_1.CompilerContext;
        const code = [];
        for (const route of this.routes) {
            code.push(this.getRouteUrlResolveCode(compiler, route));
        }
        return compiler.build(`
        switch (name) {
            ${code.join('\n')}
        }
        throw new Error('No route for name ' + name + ' found');
        `, 'name', 'parameters');
    }
    resolveUrl(routeName, parameters = {}) {
        if (!this.resolveFn) {
            this.resolveFn = this.buildUrlResolver();
        }
        return this.resolveFn(routeName, parameters);
    }
    resolveRequest(request) {
        if (!this.fn) {
            this.fn = this.build();
        }
        return this.fn(request);
    }
    resolve(method, url) {
        return this.resolveRequest({
            getUrl() {
                return url;
            },
            getMethod() {
                return method;
            },
        });
    }
};
Router = __decorate([
    injector_1.injectable(),
    __metadata("design:paramtypes", [controllers_1.HttpControllers,
        logger_1.Logger,
        injector_1.TagRegistry])
], Router);
exports.Router = Router;
//# sourceMappingURL=router.js.map