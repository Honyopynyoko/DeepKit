import { ClassType } from '@deepkit/core';
import { ClassDecoratorResult, JitConverterOptions, PropertyDecoratorResult, Serializer } from '@deepkit/type';
export interface ControllerOptions {
    name: string;
}
declare class HttpController {
    baseUrl: string;
    protected actions: Set<HttpAction>;
    groups: string[];
    getUrl(action: HttpAction): string;
    addAction(action: HttpAction): void;
    getActions(): Set<HttpAction>;
    getAction(methodName: string): HttpAction;
}
export declare class HttpActionParameter {
    name: string;
    type?: 'body' | 'query';
    /**
     * undefined = propertyName, '' === root, else given path
     */
    typePath?: string;
    optional: boolean;
}
export declare class HttpAction {
    name: string;
    description: string;
    category: string;
    path: string;
    httpMethod: string;
    methodName: string;
    groups: string[];
    serializer?: Serializer;
    serializationOptions?: JitConverterOptions;
    parameterRegularExpressions: {
        [name: string]: any;
    };
    /**
     * This is only filled when the user used @http.body() for example on an method argument.
     */
    parameters: {
        [name: string]: HttpActionParameter;
    };
    /**
     * An arbitrary data container the user can use to store app specific settings/values.
     */
    data: Map<any, any>;
    throws: {
        errorType: ClassType;
        message?: string;
    }[];
}
export declare class HttpDecorator {
    t: HttpController;
    controller(baseUrl?: string): void;
    groupAll(...group: string[]): void;
    setAction(action: HttpAction): void;
}
export declare const httpClass: ClassDecoratorResult<typeof HttpDecorator>;
export declare class HttpActionDecorator {
    t: HttpAction;
    onDecorator(target: ClassType, property: string): void;
    name(name: string): void;
    setParameter(name: string, parameter: HttpActionParameter): void;
    description(description: string): void;
    serialization(options: JitConverterOptions): void;
    serializer(serializer: Serializer): void;
    /**
     * Allows to change the HttpAction object and composite multiple properties into one function.
     *
     * @example
     * ```typescript
     * const authGroup = Symbol('authGroup');
     *
     * function authGroup(group: 'admin' | 'user') {
     *    return (action: HttpAction) => {
     *        action.data.set(authGroup, group);
     *    };
     * }
     *
     * class My Controller {
     *    @http.GET('/assets').use(authGroup('admin'))
     *    assets() {}
     * }
     * ```
     */
    use(use: (action: HttpAction) => void): void;
    /**
     * Arbitrary value container that can be read in RouterParameterResolver and all
     * HTTP workflow events (like authentication).
     *
     * @example
     * ```typescript
     * class My Controller {
     *    @http.GET('/assets').data('authGroup', 'admin')
     *    assets() {}
     * }
     * ```
    */
    data(name: string, value: any): void;
    category(category: string): void;
    group(...group: string[]): void;
    GET(path?: string): void;
    POST(path?: string): void;
    PUT(path?: string): void;
    DELETE(path?: string): void;
    ANY(path?: string): void;
    throws(errorType: ClassType, message?: string): void;
    regexp(parameterName: string, regex: any): void;
}
declare class HttpActionParameterDecorator {
    t: HttpActionParameter;
    onDecorator(target: ClassType, propertyName?: string, parameterIndex?: number): void;
    /**
     * Marks the argument as body parameter. Data from the client sent in the body
     * will be tried to parsed (JSON/form data) and deserialized to the defined type.
     * Make sure the class type as a schema assigned.
     *
     * @example
     * ```typescript
     * class MyActionBody {
     *     @t name!: string;
     * }
     *
     * class Controller {
     *     @http.GET()
     *     myAction(@http.body() body: MyActionBody) {
     *         console.log('body', body.name);
     *     }
     * }
     * ```
     */
    body(): void;
    query(path?: string): void;
    get optional(): void;
    /**
     * Marks the argument as query parameter. Data from the query string is parsed
     * and deserialized to the defined type.
     * Define a `path` if you want to parse a subset of the query string only.
     *
     * Note: Make sure the defined parameter type has optional properties,
     * otherwise it's always required to pass a query string.
     *
     * @example
     * ```typescript
     * class MyActionQueries {
     *     @t.optional name?: string;
     * }
     *
     * class Controller {
     *     @http.GET('my-action')
     *     myAction(@http.queries() query: MyActionQueries) {
     *         console.log('query', query.name);
     *     }
     * }
     *
     * // Open via, e.g.
     * // -> /my-action?name=Peter
     * ```
     *
     */
    queries(path?: string): void;
}
export declare const httpAction: PropertyDecoratorResult<typeof HttpActionDecorator>;
export declare const httpActionParameter: PropertyDecoratorResult<typeof HttpActionParameterDecorator>;
export declare const http: Omit<import("@deepkit/type").FluidDecorator<HttpDecorator, import("@deepkit/type").ClassDecoratorFn> & ((classType: import("@deepkit/core").AbstractClassType<any>) => void) & {
    _fetch: (classType: ClassType<any>) => HttpController | undefined;
} & import("@deepkit/type").FluidDecorator<HttpActionDecorator, import("@deepkit/type").PropertyDecoratorFn> & ((prototype: object, property: string, parameterIndexOrDescriptor?: any) => void) & {
    _fetch: (classType: ClassType<any>, property: string, parameterIndexOrDescriptor?: any) => HttpAction | undefined;
} & import("@deepkit/type").FluidDecorator<HttpActionParameterDecorator, import("@deepkit/type").PropertyDecoratorFn> & {
    _fetch: (classType: ClassType<any>, property: string, parameterIndexOrDescriptor?: any) => HttpActionParameter | undefined;
}, "_fetch">;
export {};
