/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { urlJoin } from '@deepkit/core';
import { createClassDecoratorContext, createPropertyDecoratorContext, getClassSchema, mergeDecorator } from '@deepkit/type';
class HttpController {
    constructor() {
        this.baseUrl = '';
        this.actions = new Set();
        this.groups = [];
    }
    getUrl(action) {
        return urlJoin('/', this.baseUrl, action.path);
    }
    addAction(action) {
        this.actions.add(action);
    }
    getActions() {
        for (const a of this.actions) {
            for (const g of this.groups) {
                if (!a.groups.includes(g))
                    a.groups.push(g);
            }
        }
        return this.actions;
    }
    getAction(methodName) {
        for (const a of this.getActions()) {
            if (a.methodName === methodName)
                return a;
        }
        throw new Error(`No action with methodName ${methodName} found`);
    }
}
export class HttpActionParameter {
    constructor() {
        this.name = '';
        this.optional = false;
    }
}
export class HttpAction {
    constructor() {
        this.name = '';
        this.description = '';
        this.category = '';
        this.path = '';
        this.httpMethod = 'GET';
        this.methodName = '';
        this.groups = [];
        this.parameterRegularExpressions = {};
        /**
         * This is only filled when the user used @http.body() for example on an method argument.
         */
        this.parameters = {};
        /**
         * An arbitrary data container the user can use to store app specific settings/values.
         */
        this.data = new Map();
        this.throws = [];
    }
}
export class HttpDecorator {
    constructor() {
        this.t = new HttpController;
    }
    controller(baseUrl = '') {
        this.t.baseUrl = baseUrl;
    }
    groupAll(...group) {
        this.t.groups.push(...group);
    }
    setAction(action) {
        this.t.addAction(action);
    }
}
export const httpClass = createClassDecoratorContext(HttpDecorator);
export class HttpActionDecorator {
    constructor() {
        this.t = new HttpAction;
    }
    onDecorator(target, property) {
        this.t.methodName = property;
        httpClass.setAction(this.t)(target);
    }
    name(name) {
        this.t.name = name;
    }
    setParameter(name, parameter) {
        this.t.parameters[name] = parameter;
    }
    description(description) {
        this.t.description = description;
    }
    serialization(options) {
        this.t.serializationOptions = options;
    }
    serializer(serializer) {
        this.t.serializer = serializer;
    }
    /**
     * Allows to change the HttpAction object and composite multiple properties into one function.
     *
     * @example
     * ```typescript
     * const authGroup = Symbol('authGroup');
     *
     * function authGroup(group: 'admin' | 'user') {
     *    return (action: HttpAction) => {
     *        action.data.set(authGroup, group);
     *    };
     * }
     *
     * class My Controller {
     *    @http.GET('/assets').use(authGroup('admin'))
     *    assets() {}
     * }
     * ```
     */
    use(use) {
        use(this.t);
    }
    /**
     * Arbitrary value container that can be read in RouterParameterResolver and all
     * HTTP workflow events (like authentication).
     *
     * @example
     * ```typescript
     * class My Controller {
     *    @http.GET('/assets').data('authGroup', 'admin')
     *    assets() {}
     * }
     * ```
    */
    data(name, value) {
        this.t.data.set(name, value);
    }
    category(category) {
        this.t.category = category;
    }
    group(...group) {
        this.t.groups.push(...group);
    }
    GET(path = '') {
        this.t.httpMethod = 'GET';
        this.t.path = path;
    }
    POST(path = '') {
        this.t.httpMethod = 'POST';
        this.t.path = path;
    }
    PUT(path = '') {
        this.t.httpMethod = 'PUT';
        this.t.path = path;
    }
    DELETE(path = '') {
        this.t.httpMethod = 'DELETE';
        this.t.path = path;
    }
    ANY(path = '') {
        this.t.httpMethod = 'ANY';
        this.t.path = path;
    }
    throws(errorType, message) {
        this.t.throws.push({ errorType, message });
    }
    regexp(parameterName, regex) {
        this.t.parameterRegularExpressions[parameterName] = regex;
    }
}
class HttpActionParameterDecorator {
    constructor() {
        this.t = new HttpActionParameter();
    }
    onDecorator(target, propertyName, parameterIndex) {
        if (!propertyName)
            throw new Error('@http action parameter decorator can only be used on method arguments.');
        if (parameterIndex === undefined)
            throw new Error('@http action parameter decorator can only be used on method arguments.');
        const schema = getClassSchema(target);
        const property = schema.getMethodProperties(propertyName)[parameterIndex];
        this.t.name = property.name;
        if (this.t.typePath === undefined) {
            this.t.typePath = property.name;
        }
        httpAction.setParameter(property.name, this.t)(target.prototype, propertyName);
    }
    /**
     * Marks the argument as body parameter. Data from the client sent in the body
     * will be tried to parsed (JSON/form data) and deserialized to the defined type.
     * Make sure the class type as a schema assigned.
     *
     * @example
     * ```typescript
     * class MyActionBody {
     *     @t name!: string;
     * }
     *
     * class Controller {
     *     @http.GET()
     *     myAction(@http.body() body: MyActionBody) {
     *         console.log('body', body.name);
     *     }
     * }
     * ```
     */
    body() {
        this.t.type = 'body';
        this.t.typePath = ''; //root
    }
    query(path) {
        this.t.typePath = path; //undefined === propertyName
        this.t.type = 'query';
    }
    get optional() {
        this.t.optional = true;
        return;
    }
    /**
     * Marks the argument as query parameter. Data from the query string is parsed
     * and deserialized to the defined type.
     * Define a `path` if you want to parse a subset of the query string only.
     *
     * Note: Make sure the defined parameter type has optional properties,
     * otherwise it's always required to pass a query string.
     *
     * @example
     * ```typescript
     * class MyActionQueries {
     *     @t.optional name?: string;
     * }
     *
     * class Controller {
     *     @http.GET('my-action')
     *     myAction(@http.queries() query: MyActionQueries) {
     *         console.log('query', query.name);
     *     }
     * }
     *
     * // Open via, e.g.
     * // -> /my-action?name=Peter
     * ```
     *
     */
    queries(path = '') {
        this.t.typePath = path; //'' === root
        this.t.type = 'query';
    }
}
createPropertyDecoratorContext(HttpActionDecorator);
export const httpAction = createPropertyDecoratorContext(HttpActionDecorator);
export const httpActionParameter = createPropertyDecoratorContext(HttpActionParameterDecorator);
export const http = mergeDecorator(httpClass, httpAction, httpActionParameter);
//# sourceMappingURL=decorator.js.map