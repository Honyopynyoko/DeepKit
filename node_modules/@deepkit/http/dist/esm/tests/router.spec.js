var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { expect, test } from '@jest/globals';
import 'reflect-metadata';
import { dotToUrlPath, RouteParameterResolverTag, Router } from '../src/router';
import { http, httpClass } from '../src/decorator';
import { t } from '@deepkit/type';
import { HttpListener, httpWorkflow, JSONResponse } from '../src/http';
import { HttpKernel } from '../src/kernel';
import { eventDispatcher, EventDispatcher } from '@deepkit/event';
import { InjectorContext, TagProvider, TagRegistry } from '@deepkit/injector';
import { ConsoleTransport, Logger } from '@deepkit/logger';
import { HttpRequest } from '../src/model';
import { sleep } from '@deepkit/core';
import { Stopwatch } from '@deepkit/stopwatch';
function createHttpKernel(controllers, providers = [], listeners = []) {
    const tagProviders = new TagRegistry();
    for (const provider of providers.slice(0)) {
        if (provider instanceof TagProvider) {
            providers.unshift(provider.provider);
            tagProviders.tags.push(provider);
        }
    }
    const router = Router.forControllers(controllers, tagProviders);
    const injector = InjectorContext.forProviders([
        { provide: Router, useValue: router },
        ...controllers,
        ...providers,
        ...listeners,
        HttpListener,
        { provide: Logger, useValue: new Logger([new ConsoleTransport()]) },
        Stopwatch
    ]);
    const eventDispatcher = new EventDispatcher(injector);
    eventDispatcher.registerListener(HttpListener);
    for (const listener of listeners)
        eventDispatcher.registerListener(listener);
    return new HttpKernel(router, eventDispatcher, injector, new Logger([new ConsoleTransport()]), new Stopwatch());
}
test('router', async () => {
    var _a, _b, _c;
    class Controller {
        helloWorld() {
        }
        hello(name) {
        }
        userStatic(id) {
        }
        userStatic2(id, id2) {
        }
        static() {
        }
    }
    __decorate([
        http.GET(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "helloWorld", null);
    __decorate([
        http.GET(':name'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "hello", null);
    __decorate([
        http.GET('/user/:id/static'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "userStatic", null);
    __decorate([
        http.GET('/user2/:id/static/:id2'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String, String]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "userStatic2", null);
    __decorate([
        http.GET('/static'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "static", null);
    const router = Router.forControllers([Controller]);
    expect((_a = (await router.resolve('GET', '/'))) === null || _a === void 0 ? void 0 : _a.routeConfig.action).toMatchObject({ controller: Controller, methodName: 'helloWorld' });
    expect((_b = (await router.resolve('GET', '/peter'))) === null || _b === void 0 ? void 0 : _b.routeConfig.action).toMatchObject({ controller: Controller, methodName: 'hello' });
    expect((_c = (await router.resolve('GET', '/peter'))) === null || _c === void 0 ? void 0 : _c.parameters(undefined)).toEqual(['peter']);
    const userStatic = await router.resolve('GET', '/user/1233/static');
    expect(userStatic === null || userStatic === void 0 ? void 0 : userStatic.routeConfig.action).toMatchObject({ controller: Controller, methodName: 'userStatic' });
    expect(userStatic === null || userStatic === void 0 ? void 0 : userStatic.parameters(undefined)).toEqual(['1233']);
    const userStatic2 = await router.resolve('GET', '/user2/1233/static/123');
    expect(userStatic2 === null || userStatic2 === void 0 ? void 0 : userStatic2.routeConfig.action).toMatchObject({ controller: Controller, methodName: 'userStatic2' });
    expect(userStatic2 === null || userStatic2 === void 0 ? void 0 : userStatic2.parameters(undefined)).toEqual(['1233', '123']);
});
test('router parameters', async () => {
    var _a;
    class Controller {
        string(name) {
            return new JSONResponse(name);
        }
        number(id) {
            return new JSONResponse(id);
        }
        boolean(yes) {
            return new JSONResponse(yes);
        }
        any(path) {
            return new JSONResponse(path);
        }
    }
    __decorate([
        http.GET('/user/:name'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "string", null);
    __decorate([
        http.GET('/user-id/:id'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "number", null);
    __decorate([
        http.GET('/boolean/:yes'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Boolean]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "boolean", null);
    __decorate([
        http.GET(':path').regexp('path', '.*'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "any", null);
    const router = Router.forControllers([Controller]);
    expect((_a = (await router.resolve('GET', '/user/peter'))) === null || _a === void 0 ? void 0 : _a.routeConfig.action).toMatchObject({ controller: Controller, methodName: 'string' });
    const httpKernel = createHttpKernel([Controller]);
    expect(await httpKernel.handleRequestFor('GET', '/user/peter')).toBe('peter');
    expect(await httpKernel.handleRequestFor('GET', '/user-id/123')).toBe(123);
    expect(await httpKernel.handleRequestFor('GET', '/user-id/asd')).toMatchObject({ message: 'Validation failed: id(invalid_number): No valid number given, got NaN' });
    expect(await httpKernel.handleRequestFor('GET', '/boolean/1')).toBe(true);
    expect(await httpKernel.handleRequestFor('GET', '/boolean/false')).toBe(false);
    expect(await httpKernel.handleRequestFor('GET', '/any')).toBe('any');
    expect(await httpKernel.handleRequestFor('GET', '/any/path')).toBe('any/path');
});
test('router HttpRequest', async () => {
    class Controller {
        anyReq(req, path) {
            return [req.url, path];
        }
    }
    __decorate([
        http.GET(':path').regexp('path', '.*'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [HttpRequest, String]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "anyReq", null);
    const httpKernel = createHttpKernel([Controller]);
    expect(await httpKernel.handleRequestFor('GET', '/req/any/path')).toEqual(['/req/any/path', 'req/any/path']);
});
test('router parameterResolver', async () => {
    class User {
        constructor(username) {
            this.username = username;
        }
    }
    class Group {
        constructor(name) {
            this.name = name;
        }
    }
    class Controller {
        route1(user) {
            return [user.username];
        }
        route2(user) {
            return [user.username];
        }
        route3(user, group) {
            return [user.username, group.name];
        }
    }
    __decorate([
        http.GET('user/:username'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [User]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "route1", null);
    __decorate([
        http.GET('invalid'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [User]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "route2", null);
    __decorate([
        http.GET('user/:user/group/:group'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [User, Group]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "route3", null);
    class UserResolver {
        resolve(context) {
            const value = context.value || context.parameters.username;
            if (!value)
                throw new Error('No value specified');
            return new User(value);
        }
    }
    class GroupResolver {
        resolve(context) {
            if (!context.value)
                throw new Error('No value specified');
            return new Group(context.value);
        }
    }
    const httpKernel = createHttpKernel([Controller], [RouteParameterResolverTag.provide(UserResolver).forClassType(User), RouteParameterResolverTag.provide(GroupResolver).forClassType(Group)]);
    expect(await httpKernel.handleRequestFor('GET', '/user/peter')).toEqual(['peter']);
    expect(await httpKernel.handleRequestFor('GET', '/user/peter/group/a')).toEqual(['peter', 'a']);
    expect(await httpKernel.handleRequestFor('GET', '/invalid')).toEqual('Internal error');
});
test('router body', async () => {
    class Body {
    }
    __decorate([
        t,
        __metadata("design:type", String)
    ], Body.prototype, "username", void 0);
    class Controller {
        anyReq(body, req) {
            return [body.username, body instanceof Body, req.url];
        }
    }
    __decorate([
        http.POST(),
        __param(0, http.body()),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Body, HttpRequest]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "anyReq", null);
    const httpKernel = createHttpKernel([Controller]);
    expect(await httpKernel.handleRequestFor('POST', '/', { username: 'Peter' })).toEqual(['Peter', true, '/']);
});
test('router body double', async () => {
    class Body {
    }
    __decorate([
        t,
        __metadata("design:type", String)
    ], Body.prototype, "username", void 0);
    class Controller {
        anyReq(body, body2, req) {
            return [body2.username, body2 instanceof Body && body instanceof Body, req.url];
        }
    }
    __decorate([
        http.POST(),
        __param(0, http.body()),
        __param(1, http.body()),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Body, Body, HttpRequest]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "anyReq", null);
    const httpData = httpClass._fetch(Controller);
    if (!httpData)
        throw new Error('httpClass undefined');
    const action = [...httpData.getActions()][0];
    expect(action.methodName).toBe('anyReq');
    expect(action.httpMethod).toBe('POST');
    expect(action.parameters['body']).not.toBeUndefined();
    expect(action.parameters['body'].name).toBe('body');
    expect(action.parameters['body2']).not.toBeUndefined();
    expect(action.parameters['body2'].name).toBe('body2');
    const httpKernel = createHttpKernel([Controller]);
    expect(await httpKernel.handleRequestFor('POST', '/', { username: 'Peter' })).toEqual(['Peter', true, '/']);
});
test('router groups', async () => {
    {
        class Controller {
            a() {
            }
            b() {
            }
            c() {
            }
        }
        __decorate([
            http.GET('a').group('a'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], Controller.prototype, "a", null);
        __decorate([
            http.GET('b'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], Controller.prototype, "b", null);
        __decorate([
            http.GET('c').group('c'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], Controller.prototype, "c", null);
        const httpData = httpClass._fetch(Controller);
        if (!httpData)
            throw new Error('httpClass undefined');
        expect(httpData.getAction('a').groups).toEqual(['a']);
        expect(httpData.getAction('b').groups).toEqual([]);
        expect(httpData.getAction('c').groups).toEqual(['c']);
    }
    {
        let Controller = class Controller {
            a() {
            }
            b() {
            }
            c() {
            }
        };
        __decorate([
            http.GET('a').group('a'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], Controller.prototype, "a", null);
        __decorate([
            http.GET('b'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], Controller.prototype, "b", null);
        __decorate([
            http.GET('c').group('c'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], Controller.prototype, "c", null);
        Controller = __decorate([
            http.groupAll('all')
        ], Controller);
        const httpData = httpClass._fetch(Controller);
        if (!httpData)
            throw new Error('httpClass undefined');
        expect(httpData.getAction('a').groups).toEqual(['a', 'all']);
        expect(httpData.getAction('b').groups).toEqual(['all']);
        expect(httpData.getAction('c').groups).toEqual(['c', 'all']);
    }
    expect(() => {
        let ControllerC = class ControllerC {
        };
        ControllerC = __decorate([
            http.group('all')
        ], ControllerC);
    }).toThrow('Property decorators can only be used on class properties');
});
test('router query', async () => {
    class Controller {
        anyReq(test) {
            return test;
        }
    }
    __decorate([
        http.GET('my-action'),
        __param(0, http.query().optional),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "anyReq", null);
    const httpData = httpClass._fetch(Controller);
    if (!httpData)
        throw new Error('httpClass undefined');
    const action = [...httpData.getActions()][0];
    expect(action.methodName).toBe('anyReq');
    expect(action.httpMethod).toBe('GET');
    expect(action.parameters['test']).not.toBeUndefined();
    expect(action.parameters['test'].name).toBe('test');
    expect(action.parameters['test'].type).toBe('query');
    const httpKernel = createHttpKernel([Controller]);
    expect(await httpKernel.handleRequestFor('GET', '/my-action?test=123')).toEqual(123);
    expect(await httpKernel.handleRequestFor('GET', '/my-action')).toEqual(undefined);
});
test('router query all', async () => {
    class AnyReqQuery {
    }
    __decorate([
        t.optional,
        __metadata("design:type", String)
    ], AnyReqQuery.prototype, "test", void 0);
    __decorate([
        t.optional,
        __metadata("design:type", String)
    ], AnyReqQuery.prototype, "filter", void 0);
    __decorate([
        t.optional,
        __metadata("design:type", Number)
    ], AnyReqQuery.prototype, "page", void 0);
    class Controller {
        anyReq(anyReqQuery) {
            return anyReqQuery;
        }
    }
    __decorate([
        http.GET('my-action'),
        __param(0, http.queries()),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [AnyReqQuery]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "anyReq", null);
    const httpKernel = createHttpKernel([Controller]);
    expect(await httpKernel.handleRequestFor('GET', '/my-action?test=123')).toEqual({ test: '123' });
    expect(await httpKernel.handleRequestFor('GET', '/my-action')).toEqual({});
    expect(await httpKernel.handleRequestFor('GET', '/my-action?filter=page&page=5')).toEqual({ filter: 'page', page: 5 });
});
test('serializer options', async () => {
    class User {
    }
    __decorate([
        t,
        __metadata("design:type", String)
    ], User.prototype, "username", void 0);
    __decorate([
        t.group('sensitive'),
        __metadata("design:type", String)
    ], User.prototype, "password", void 0);
    class Controller {
        anyReq() {
            return { username: 'Peter', password: 'secret' };
        }
    }
    __decorate([
        http.GET().serialization({ groupsExclude: ['sensitive'] }),
        t.type(User),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "anyReq", null);
    const httpKernel = createHttpKernel([Controller]);
    expect(await httpKernel.handleRequestFor('GET', '/')).toEqual({ username: 'Peter' });
});
test('hook after serializer', async () => {
    class User {
    }
    __decorate([
        t,
        __metadata("design:type", String)
    ], User.prototype, "username", void 0);
    __decorate([
        t.group('sensitive'),
        __metadata("design:type", String)
    ], User.prototype, "password", void 0);
    class Controller {
        async anyReq() {
            await sleep(0.1);
            return { username: 'Peter', password: 'secret' };
        }
    }
    __decorate([
        http.GET().serialization({ groupsExclude: ['sensitive'] }),
        t.type(User),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Promise)
    ], Controller.prototype, "anyReq", null);
    class Listener {
        onResponse(event) {
            event.result = { processingTime: event.controllerActionTime, data: event.result };
        }
    }
    __decorate([
        eventDispatcher.listen(httpWorkflow.onResponse),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], Listener.prototype, "onResponse", null);
    const httpKernel = createHttpKernel([Controller], [], [Listener]);
    const result = await httpKernel.handleRequestFor('GET', '/');
    expect(result.data).toEqual({ username: 'Peter' });
    expect(result.processingTime).toBeGreaterThanOrEqual(99);
});
test('custom request handling', async () => {
    class Listener {
        onRouteNotFound(event) {
            //CORS requirement for example
            if (event.request.method === 'OPTIONS')
                event.send(new JSONResponse(true, 200));
        }
    }
    __decorate([
        eventDispatcher.listen(httpWorkflow.onRouteNotFound),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], Listener.prototype, "onRouteNotFound", null);
    const httpKernel = createHttpKernel([], [], [Listener]);
    expect(await httpKernel.handleRequestFor('OPTIONS', '/')).toBe(true);
});
test('promise serializer', async () => {
    class Controller {
        async anyReq1() {
            return "test";
        }
        async anyReq2() {
            return 1;
        }
    }
    __decorate([
        http.GET('1'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Promise)
    ], Controller.prototype, "anyReq1", null);
    __decorate([
        http.GET('2'),
        t.string,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Promise)
    ], Controller.prototype, "anyReq2", null);
    const httpKernel = createHttpKernel([Controller]);
    expect(await httpKernel.handleRequestFor('GET', '/1')).toBe("test");
    expect(await httpKernel.handleRequestFor('GET', '/2')).toBe("1");
});
test('unions', async () => {
    class Controller {
        list(page) {
            return page;
        }
    }
    __decorate([
        http.GET('/list'),
        __param(0, http.query()),
        __param(0, t.union(t.number, t.boolean)),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "list", null);
    const httpKernel = createHttpKernel([Controller]);
    expect(await httpKernel.handleRequestFor('GET', '/list?page=1')).toEqual(1);
    expect(await httpKernel.handleRequestFor('GET', '/list?page=2222')).toEqual(2222);
    expect(await httpKernel.handleRequestFor('GET', '/list?page=false')).toEqual(false);
});
test('router dotToUrlPath', () => {
    expect(dotToUrlPath('peter')).toBe('peter');
    expect(dotToUrlPath('foo.bar')).toBe('foo[bar]');
    expect(dotToUrlPath('foo.bar.deep')).toBe('foo[bar][deep]');
    expect(dotToUrlPath('foo.bar.deep.very')).toBe('foo[bar][deep][very]');
});
test('router url resolve', async () => {
    class AnyReqQuery {
    }
    __decorate([
        t.optional,
        __metadata("design:type", String)
    ], AnyReqQuery.prototype, "test", void 0);
    __decorate([
        t.optional,
        __metadata("design:type", String)
    ], AnyReqQuery.prototype, "filter", void 0);
    __decorate([
        t.optional,
        __metadata("design:type", Number)
    ], AnyReqQuery.prototype, "page", void 0);
    class Controller {
        first() {
            return '';
        }
        second(peter) {
            return '';
        }
        secondQuery(peter) {
            return '';
        }
        secondQuery2(peter) {
            return '';
        }
        third(params) {
            return params;
        }
        third2(params) {
            return params;
        }
    }
    __decorate([
        http.GET('').name('first'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "first", null);
    __decorate([
        http.GET(':peter').name('second'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "second", null);
    __decorate([
        http.GET('').name('secondQuery'),
        __param(0, http.query()),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "secondQuery", null);
    __decorate([
        http.GET('').name('secondQuery2'),
        __param(0, http.query('changed')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "secondQuery2", null);
    __decorate([
        http.GET('third').name('third'),
        __param(0, http.queries()),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [AnyReqQuery]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "third", null);
    __decorate([
        http.GET('third2').name('third2'),
        __param(0, http.queries('deep')),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [AnyReqQuery]),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "third2", null);
    const router = Router.forControllers([Controller]);
    expect(router.resolveUrl('first')).toBe('/');
    expect(router.resolveUrl('second', { peter: 'foo' })).toBe('/foo');
    expect(router.resolveUrl('secondQuery', { peter: 'foo' })).toBe('/?peter=foo');
    expect(router.resolveUrl('secondQuery2', { peter: 'foo' })).toBe('/?changed=foo');
    expect(router.resolveUrl('third', {})).toBe('/third');
    expect(router.resolveUrl('third', { params: { test: 123 } })).toBe('/third?test=123');
    expect(router.resolveUrl('third', { params: { test: 123, filter: 'peter' } })).toBe('/third?test=123&filter=peter');
    expect(router.resolveUrl('third2', {})).toBe('/third2');
    expect(router.resolveUrl('third2', { params: { test: 123 } })).toBe('/third2?deep[test]=123');
    expect(router.resolveUrl('third2', { params: { test: 123, filter: 'peter' } })).toBe('/third2?deep[test]=123&deep[filter]=peter');
});
//# sourceMappingURL=router.spec.js.map