import { ClassSchema, ExtractClassDefinition, PlainSchemaProps, PropertySchema } from '@deepkit/type';
import { Provider, ProviderWithScope, TagRegistry } from './provider';
import { ClassType, CompilerContext, CustomError } from '@deepkit/core';
import { InjectorModule } from './module';
export declare class ConfigToken<T extends {}> {
    config: ConfigDefinition<T>;
    name: keyof T & string;
    constructor(config: ConfigDefinition<T>, name: keyof T & string);
}
export declare class ConfigSlice<T extends {}> {
    bag?: {
        [name: string]: any;
    };
    config: ConfigDefinition<T>;
    names: (keyof T & string)[];
    constructor(config: ConfigDefinition<T>, names: (keyof T & string)[]);
    valueOf(): this;
}
export declare class ConfigDefinition<T extends {}> {
    readonly schema: ClassSchema<T>;
    protected module?: InjectorModule;
    type: T;
    constructor(schema: ClassSchema<T>);
    setModule(module: InjectorModule): void;
    hasModule(): boolean;
    getModule(): InjectorModule;
    getConfigOrDefaults(): any;
    all(): ClassType<T>;
    slice<N extends (keyof T & string)[]>(names: N): ClassType<Pick<T, N[number]>>;
    token<N extends (keyof T & string)>(name: N): ConfigToken<T>;
}
export declare class InjectorReference {
    readonly to: any;
    constructor(to: any);
}
export declare function injectorReference<T>(classTypeOrToken: T): any;
export declare function createConfig<T extends PlainSchemaProps>(config: T): ConfigDefinition<ExtractClassDefinition<T>>;
export interface InjectDecorator {
    (target: object, property?: string, parameterIndexOrDescriptor?: any): any;
    /**
     * Mark as optional.
     */
    readonly optional: this;
    /**
     * Resolves the dependency token from the root injector.
     */
    readonly root: this;
}
declare type ForwardRef<T> = () => T;
export declare function inject(token?: any | ForwardRef<any>): InjectDecorator;
export declare class InjectToken {
    readonly name: string;
    constructor(name: string);
    toString(): string;
}
export declare function injectable(): (target: object) => void;
export declare class CircularDependencyError extends CustomError {
}
export declare class TokenNotFoundError extends CustomError {
}
export declare class DependenciesUnmetError extends CustomError {
}
export declare function tokenLabel(token: any): string;
export interface ConfigContainer {
    get(path: string): any;
}
export interface BasicInjector {
    get<T, R = T extends ClassType<infer R> ? R : T>(token: T, frontInjector?: Injector): R;
}
export declare class Injector implements BasicInjector {
    protected providers: Provider[];
    protected parents: (BasicInjector | Injector)[];
    protected injectorContext: InjectorContext;
    protected configuredProviderRegistry: ConfiguredProviderRegistry | undefined;
    protected tagRegistry: TagRegistry;
    circularCheck: boolean;
    protected resolved: any[];
    protected retriever(injector: Injector, token: any, frontInjector?: Injector): any;
    constructor(providers?: Provider[], parents?: (BasicInjector | Injector)[], injectorContext?: InjectorContext, configuredProviderRegistry?: ConfiguredProviderRegistry | undefined, tagRegistry?: TagRegistry);
    /**
     * Creates a clone of this instance, maintains the provider structure, but drops provider instances.
     * Note: addProviders() in the new fork changes the origin, since providers array is not cloned.
     */
    fork(parents?: Injector[], injectorContext?: InjectorContext): Injector;
    /**
     * Changes the provider structure of this injector.
     *
     * Note: This is very performance sensitive. Every time you call this function a new dependency injector function
     * is generated, which si pretty slow. So, it's recommended to create a Injector with providers in the constructor
     * and not change it.
     */
    addProviders(...providers: Provider[]): void;
    isRoot(): boolean;
    protected createFactoryProperty(property: PropertySchema, compiler: CompilerContext, classTypeVar: string, argPosition: number, notFoundFunction: string): string;
    protected createFactory(compiler: CompilerContext, classType: ClassType): string;
    protected buildRetriever(): (injector: Injector, token: any, frontInjector?: Injector) => any;
    get<T, R = T extends ClassType<infer R> ? R : T>(token: T, frontInjector?: Injector): R;
}
export declare class MemoryInjector extends Injector {
    protected providers: ({
        provide: any;
        useValue: any;
    } | {
        provide: any;
        useFactory: () => any;
    })[];
    constructor(providers: ({
        provide: any;
        useValue: any;
    } | {
        provide: any;
        useFactory: () => any;
    })[]);
    fork(parents?: Injector[]): Injector;
    protected retriever(injector: Injector, token: any): any;
    get<T, R = T extends ClassType<infer R> ? R : T>(token: T, frontInjector?: Injector): R;
}
export declare class ContextRegistry {
    contexts: Context[];
    get size(): number;
    get(id: number): Context;
    set(id: number, value: Context): void;
}
export declare class ScopedContextScopeCaches {
    protected size: number;
    protected caches: {
        [name: string]: ScopedContextCache;
    };
    constructor(size: number);
    getCache(scope: string): ScopedContextCache;
}
export declare class ScopedContextCache {
    protected size: number;
    protected injectors: (Injector | undefined)[];
    constructor(size: number);
    get(contextId: number): Injector | undefined;
    set(contextId: number, injector: Injector): void;
}
export declare class Context {
    readonly module: InjectorModule;
    readonly id: number;
    readonly parent?: Context | undefined;
    providers: ProviderWithScope[];
    constructor(module: InjectorModule, id: number, parent?: Context | undefined);
}
export declare type ConfiguredProviderCalls = {
    type: 'call';
    methodName: string | symbol | number;
    args: any[];
} | {
    type: 'property';
    property: string | symbol | number;
    value: any;
} | {
    type: 'stop';
};
export declare class ConfiguredProviderRegistry {
    calls: Map<any, ConfiguredProviderCalls[]>;
    add(token: any, ...newCalls: ConfiguredProviderCalls[]): void;
    get(token: any): ConfiguredProviderCalls[];
    clone(): ConfiguredProviderRegistry;
}
export declare type ConfigureProvider<T> = {
    [name in keyof T]: T[name] extends (...args: infer A) => any ? (...args: A) => ConfigureProvider<T> : T[name];
};
/**
 * Returns a configuration object that reflects the API of the given ClassType or token. Each call
 * is scheduled and executed once the provider has been created by the dependency injection container.
 */
export declare function setupProvider<T extends ClassType<T> | any>(classTypeOrToken: T, registry: ConfiguredProviderRegistry): ConfigureProvider<T extends ClassType<infer C> ? C : T>;
export declare class InjectorContext implements BasicInjector {
    readonly contextManager: ContextRegistry;
    readonly scope: string;
    readonly configuredProviderRegistry: ConfiguredProviderRegistry;
    readonly parent: InjectorContext | undefined;
    readonly additionalInjectorParent: Injector | undefined;
    readonly modules: {
        [name: string]: InjectorModule;
    };
    tagRegistry: TagRegistry;
    protected injectors: (Injector | undefined)[];
    readonly scopeCaches: ScopedContextScopeCaches;
    protected cache: ScopedContextCache;
    static contextSymbol: symbol;
    constructor(contextManager?: ContextRegistry, scope?: string, configuredProviderRegistry?: ConfiguredProviderRegistry, parent?: InjectorContext | undefined, additionalInjectorParent?: Injector | undefined, modules?: {
        [name: string]: InjectorModule;
    }, scopeCaches?: ScopedContextScopeCaches, tagRegistry?: TagRegistry);
    getModule(name: string): InjectorModule;
    registerModule(module: InjectorModule, config?: ConfigDefinition<any>): void;
    /**
     * Returns a configuration object that reflects the API of the given ClassType or token. Each call
     * is scheduled and executed once the provider has been created by the dependency injection container.
     */
    setupProvider<T extends ClassType<T> | any>(classTypeOrToken: T): ConfigureProvider<T extends ClassType<infer C> ? C : T>;
    getModuleNames(): string[];
    static forProviders(providers: ProviderWithScope[]): InjectorContext;
    getInjector(contextId: number): Injector;
    get<T, R = T extends ClassType<infer R> ? R : T>(token: T, frontInjector?: Injector): R;
    createChildScope(scope: string, additionalInjectorParent?: Injector): InjectorContext;
}
export {};
