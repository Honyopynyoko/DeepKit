import { ClassType } from '@deepkit/core';
export interface ProviderBase {
    /**
     * Per default all instances are singleton (scoped to its scope). Enabling transient makes the
     * Injector create always a new instance for every consumer.
     */
    transient?: true;
}
export interface ValueProvider<T> extends ProviderBase {
    /**
     * An injection token. (Typically an instance of `ClassType`, but can be `any`).
     */
    provide: symbol | string | ClassType<T>;
    /**
     * The value to inject.
     */
    useValue: T;
}
export interface ClassProvider<T> extends ProviderBase {
    /**
     * An injection token. (Typically an instance of `ClassType`, but can be `any`).
     */
    provide: ClassType<T>;
    /**
     * Class to instantiate for the `token`.
     */
    useClass?: ClassType<T>;
}
export interface ExistingProvider<T> extends ProviderBase {
    /**
     * An injection token. (Typically an instance of `ClassType`, but can be `any`).
     */
    provide: symbol | string | ClassType<T>;
    /**
     * Existing `token` to return. (equivalent to `injector.get(useExisting)`)
     */
    useExisting: ClassType<T>;
}
export interface FactoryProvider<T> extends ProviderBase {
    /**
     * An injection token. (Typically an instance of `ClassType`, but can be `any`).
     */
    provide: symbol | string | ClassType<T>;
    /**
     * A function to invoke to create a value for this `token`. The function is invoked with
     * resolved values of `token`s in the `deps` field.
     */
    useFactory: (...args: any[]) => T;
    /**
     * A list of `token`s which need to be resolved by the injector. The list of values is then
     * used as arguments to the `useFactory` function.
     */
    deps?: any[];
}
export declare type Provider<T = any> = ClassType | ValueProvider<T> | ClassProvider<T> | ExistingProvider<T> | FactoryProvider<T> | TagProvider<T>;
export declare type ProviderProvide<T = any> = ValueProvider<T> | ClassProvider<T> | ExistingProvider<T> | FactoryProvider<T>;
export declare class TagRegistry {
    tags: TagProvider<any>[];
    constructor(tags?: TagProvider<any>[]);
    resolve<T extends ClassType<Tag<any>>>(tag: T): TagProvider<InstanceType<T>>[];
}
export declare class TagProvider<T> {
    provider: NormalizedProvider<T>;
    tag: Tag<T>;
    constructor(provider: NormalizedProvider<T>, tag: Tag<T>);
}
export declare class Tag<T, TP extends TagProvider<T> = TagProvider<T>> {
    readonly services: T[];
    _: () => T;
    _2: () => TP;
    constructor(services?: T[]);
    protected createTagProvider(provider: NormalizedProvider<any>): TP;
    static provide<P extends ClassType<T> | ValueProvider<T> | ClassProvider<T> | ExistingProvider<T> | FactoryProvider<T>, T extends ReturnType<InstanceType<B>['_']>, TP extends ReturnType<InstanceType<B>['_2']>, B extends ClassType<Tag<any>>>(this: B, provider: P): TP;
}
export interface ProviderScope {
    scope?: 'module' | 'rpc' | 'http' | 'cli' | string;
}
export declare type NormalizedProvider<T = any> = ProviderProvide<T> & ProviderScope;
export declare type ProviderWithScope<T = any> = ClassType | (ProviderProvide<T> & ProviderScope) | TagProvider<any>;
export declare function isScopedProvider(obj: any): obj is ProviderProvide & ProviderScope;
export declare function isValueProvider(obj: any): obj is ValueProvider<any>;
export declare function isClassProvider(obj: any): obj is ClassProvider<any>;
export declare function isExistingProvider(obj: any): obj is ExistingProvider<any>;
export declare function isFactoryProvider(obj: any): obj is FactoryProvider<any>;
export declare function isInjectionProvider(obj: any): obj is Provider<any>;
export declare function getProviders(providers: ProviderWithScope[], requestScope: 'module' | 'session' | 'request' | string): Provider<any>[];
