/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { isClass } from '@deepkit/core';
export class TagRegistry {
    constructor(tags = []) {
        this.tags = tags;
    }
    resolve(tag) {
        return this.tags.filter(v => v.tag instanceof tag);
    }
}
export class TagProvider {
    constructor(provider, tag) {
        this.provider = provider;
        this.tag = tag;
    }
}
export class Tag {
    constructor(services = []) {
        this.services = services;
    }
    createTagProvider(provider) {
        return new TagProvider(provider, this);
    }
    static provide(provider) {
        const t = new this;
        if (isClass(provider)) {
            return t.createTagProvider({ provide: provider });
        }
        return t.createTagProvider(provider);
    }
}
export function isScopedProvider(obj) {
    return obj.provide && obj.hasOwnProperty('scope');
}
export function isValueProvider(obj) {
    return obj.provide && obj.hasOwnProperty('useValue');
}
export function isClassProvider(obj) {
    return obj.provide && !isValueProvider(obj) && !isExistingProvider(obj) && !isFactoryProvider(obj);
}
export function isExistingProvider(obj) {
    return obj.provide && obj.hasOwnProperty('useExisting');
}
export function isFactoryProvider(obj) {
    return obj.provide && obj.hasOwnProperty('useFactory');
}
export function isInjectionProvider(obj) {
    return isValueProvider(obj) || isClassProvider(obj) || isExistingProvider(obj) || isFactoryProvider(obj);
}
export function getProviders(providers, requestScope) {
    const result = [];
    function normalize(provider) {
        if (isClass(provider)) {
            return provider;
        }
        return provider;
    }
    for (const provider of providers) {
        if (isClass(provider)) {
            if (requestScope === 'module')
                result.push(provider);
            continue;
        }
        if (isClass(provider)) {
            if (requestScope === 'module')
                result.push(provider);
            continue;
        }
        const scope = isScopedProvider(provider) ? provider.scope : 'module';
        if (scope === requestScope) {
            result.push(normalize(provider));
        }
    }
    return result;
}
//# sourceMappingURL=provider.js.map