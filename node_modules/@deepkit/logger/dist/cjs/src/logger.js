"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = exports.ScopedLogger = exports.TimestampFormatter = exports.RemoveColorFormatter = exports.ColorFormatter = exports.ConsoleTransport = exports.LoggerLevel = void 0;
const ansi_styles_1 = __importDefault(require("ansi-styles"));
const format_util_1 = __importDefault(require("format-util"));
const core_1 = require("@deepkit/core");
var LoggerLevel;
(function (LoggerLevel) {
    LoggerLevel[LoggerLevel["none"] = 0] = "none";
    LoggerLevel[LoggerLevel["alert"] = 1] = "alert";
    LoggerLevel[LoggerLevel["error"] = 2] = "error";
    LoggerLevel[LoggerLevel["warning"] = 3] = "warning";
    LoggerLevel[LoggerLevel["log"] = 4] = "log";
    LoggerLevel[LoggerLevel["info"] = 5] = "info";
    LoggerLevel[LoggerLevel["debug"] = 6] = "debug";
})(LoggerLevel = exports.LoggerLevel || (exports.LoggerLevel = {}));
class ConsoleTransport {
    write(message, level) {
        if (level === LoggerLevel.error) {
            process.stderr.write(message + '\n');
        }
        else {
            process.stdout.write(message + '\n');
        }
    }
    supportsColor() {
        return true;
    }
}
exports.ConsoleTransport = ConsoleTransport;
class ColorFormatter {
    format(message, level) {
        if (level === LoggerLevel.error || level === LoggerLevel.alert) {
            message = `<red>${message}</red>`;
        }
        if (message.includes('<')) {
            message = message.replace(/<(\/)?([a-zA-Z]+)>/g, function (a, end, color) {
                if (!ansi_styles_1.default[color])
                    return a;
                if (end === '/')
                    return ansi_styles_1.default[color].close;
                return ansi_styles_1.default[color].open;
            });
        }
        return message;
    }
}
exports.ColorFormatter = ColorFormatter;
ColorFormatter.colors = [
    'black',
    'red',
    'green',
    'yellow',
    'blue',
    'cyan',
    'magenta',
    'white',
    'gray',
    'grey',
];
class RemoveColorFormatter {
    format(message, level) {
        if (message.includes('<')) {
            message = message.replace(/<(\/)?([a-zA-Z]+)>/g, function (a, end, color) {
                return '';
            });
        }
        return message;
    }
}
exports.RemoveColorFormatter = RemoveColorFormatter;
class TimestampFormatter {
    format(message, level) {
        return `<yellow>${new Date().toISOString()}</yellow> [${String(LoggerLevel[level]).toUpperCase()}] ${message}`;
    }
}
exports.TimestampFormatter = TimestampFormatter;
class ScopedLogger {
    constructor(parent, scope) {
        this.parent = parent;
        this.scope = scope;
    }
    scoped(name) {
        return this.parent.scoped(name);
    }
    get level() {
        if (this.parent.scopedLevel[this.scope] !== undefined)
            return this.parent.scopedLevel[this.scope];
        return this.parent.level;
    }
    set level(level) {
        this.parent.scopedLevel[this.scope] = level;
    }
    is(level) {
        return level <= this.level;
    }
    alert(...message) {
        this.parent.alert(`<yellow>${this.scope}</yellow>`, ...message);
    }
    error(...message) {
        this.parent.error(`<yellow>${this.scope}</yellow>`, ...message);
    }
    warning(...message) {
        this.parent.warning(`<yellow>${this.scope}</yellow>`, ...message);
    }
    log(...message) {
        this.parent.log(`<yellow>${this.scope}</yellow>`, ...message);
    }
    info(...message) {
        this.parent.info(`<yellow>${this.scope}</yellow>`, ...message);
    }
    debug(...message) {
        this.parent.debug(`<yellow>${this.scope}</yellow>`, ...message);
    }
}
exports.ScopedLogger = ScopedLogger;
class Logger {
    constructor(transport = [], formatter = []) {
        this.transport = transport;
        this.formatter = formatter;
        this.colorFormatter = new ColorFormatter;
        this.removeColorFormatter = new RemoveColorFormatter;
        this.level = LoggerLevel.info;
        this.scopedLevel = {};
        this.scopes = {};
    }
    scoped(name) {
        var _a;
        return (_a = this.scopes)[name] || (_a[name] = new ScopedLogger(this, name));
    }
    addTransport(transport) {
        this.transport.push(transport);
    }
    removeTransport(transport) {
        core_1.arrayRemoveItem(this.transport, transport);
    }
    hasFormatter(formatterType) {
        for (const formatter of this.formatter) {
            if (formatter instanceof formatterType)
                return true;
        }
        return false;
    }
    addFormatter(formatter) {
        this.formatter.push(formatter);
    }
    format(message, level) {
        for (const formatter of this.formatter) {
            message = formatter.format(message, level);
        }
        return message;
    }
    is(level) {
        return level <= this.level;
    }
    send(messages, level) {
        if (!this.is(level))
            return;
        let message = this.format(format_util_1.default(...messages), level);
        for (const transport of this.transport) {
            if (transport.supportsColor()) {
                transport.write(this.colorFormatter.format(message, level), level);
            }
            else {
                transport.write(this.removeColorFormatter.format(message, level), level);
            }
        }
    }
    alert(...message) {
        this.send(message, LoggerLevel.alert);
    }
    error(...message) {
        this.send(message, LoggerLevel.error);
    }
    warning(...message) {
        this.send(message, LoggerLevel.warning);
    }
    log(...message) {
        this.send(message, LoggerLevel.log);
    }
    info(...message) {
        this.send(message, LoggerLevel.info);
    }
    debug(...message) {
        this.send(message, LoggerLevel.debug);
    }
}
exports.Logger = Logger;
//# sourceMappingURL=logger.js.map