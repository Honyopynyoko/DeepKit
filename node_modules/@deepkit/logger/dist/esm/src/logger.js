/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import style from 'ansi-styles';
import format from 'format-util';
import { arrayRemoveItem } from '@deepkit/core';
export var LoggerLevel;
(function (LoggerLevel) {
    LoggerLevel[LoggerLevel["none"] = 0] = "none";
    LoggerLevel[LoggerLevel["alert"] = 1] = "alert";
    LoggerLevel[LoggerLevel["error"] = 2] = "error";
    LoggerLevel[LoggerLevel["warning"] = 3] = "warning";
    LoggerLevel[LoggerLevel["log"] = 4] = "log";
    LoggerLevel[LoggerLevel["info"] = 5] = "info";
    LoggerLevel[LoggerLevel["debug"] = 6] = "debug";
})(LoggerLevel || (LoggerLevel = {}));
export class ConsoleTransport {
    write(message, level) {
        if (level === LoggerLevel.error) {
            process.stderr.write(message + '\n');
        }
        else {
            process.stdout.write(message + '\n');
        }
    }
    supportsColor() {
        return true;
    }
}
export class ColorFormatter {
    format(message, level) {
        if (level === LoggerLevel.error || level === LoggerLevel.alert) {
            message = `<red>${message}</red>`;
        }
        if (message.includes('<')) {
            message = message.replace(/<(\/)?([a-zA-Z]+)>/g, function (a, end, color) {
                if (!style[color])
                    return a;
                if (end === '/')
                    return style[color].close;
                return style[color].open;
            });
        }
        return message;
    }
}
ColorFormatter.colors = [
    'black',
    'red',
    'green',
    'yellow',
    'blue',
    'cyan',
    'magenta',
    'white',
    'gray',
    'grey',
];
export class RemoveColorFormatter {
    format(message, level) {
        if (message.includes('<')) {
            message = message.replace(/<(\/)?([a-zA-Z]+)>/g, function (a, end, color) {
                return '';
            });
        }
        return message;
    }
}
export class TimestampFormatter {
    format(message, level) {
        return `<yellow>${new Date().toISOString()}</yellow> [${String(LoggerLevel[level]).toUpperCase()}] ${message}`;
    }
}
export class ScopedLogger {
    constructor(parent, scope) {
        this.parent = parent;
        this.scope = scope;
    }
    scoped(name) {
        return this.parent.scoped(name);
    }
    get level() {
        if (this.parent.scopedLevel[this.scope] !== undefined)
            return this.parent.scopedLevel[this.scope];
        return this.parent.level;
    }
    set level(level) {
        this.parent.scopedLevel[this.scope] = level;
    }
    is(level) {
        return level <= this.level;
    }
    alert(...message) {
        this.parent.alert(`<yellow>${this.scope}</yellow>`, ...message);
    }
    error(...message) {
        this.parent.error(`<yellow>${this.scope}</yellow>`, ...message);
    }
    warning(...message) {
        this.parent.warning(`<yellow>${this.scope}</yellow>`, ...message);
    }
    log(...message) {
        this.parent.log(`<yellow>${this.scope}</yellow>`, ...message);
    }
    info(...message) {
        this.parent.info(`<yellow>${this.scope}</yellow>`, ...message);
    }
    debug(...message) {
        this.parent.debug(`<yellow>${this.scope}</yellow>`, ...message);
    }
}
export class Logger {
    constructor(transport = [], formatter = []) {
        this.transport = transport;
        this.formatter = formatter;
        this.colorFormatter = new ColorFormatter;
        this.removeColorFormatter = new RemoveColorFormatter;
        this.level = LoggerLevel.info;
        this.scopedLevel = {};
        this.scopes = {};
    }
    scoped(name) {
        var _a;
        return (_a = this.scopes)[name] || (_a[name] = new ScopedLogger(this, name));
    }
    addTransport(transport) {
        this.transport.push(transport);
    }
    removeTransport(transport) {
        arrayRemoveItem(this.transport, transport);
    }
    hasFormatter(formatterType) {
        for (const formatter of this.formatter) {
            if (formatter instanceof formatterType)
                return true;
        }
        return false;
    }
    addFormatter(formatter) {
        this.formatter.push(formatter);
    }
    format(message, level) {
        for (const formatter of this.formatter) {
            message = formatter.format(message, level);
        }
        return message;
    }
    is(level) {
        return level <= this.level;
    }
    send(messages, level) {
        if (!this.is(level))
            return;
        let message = this.format(format(...messages), level);
        for (const transport of this.transport) {
            if (transport.supportsColor()) {
                transport.write(this.colorFormatter.format(message, level), level);
            }
            else {
                transport.write(this.removeColorFormatter.format(message, level), level);
            }
        }
    }
    alert(...message) {
        this.send(message, LoggerLevel.alert);
    }
    error(...message) {
        this.send(message, LoggerLevel.error);
    }
    warning(...message) {
        this.send(message, LoggerLevel.warning);
    }
    log(...message) {
        this.send(message, LoggerLevel.log);
    }
    info(...message) {
        this.send(message, LoggerLevel.info);
    }
    debug(...message) {
        this.send(message, LoggerLevel.debug);
    }
}
//# sourceMappingURL=logger.js.map