"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoDatabaseAdapter = exports.MongoDatabaseQueryFactory = void 0;
const orm_1 = require("@deepkit/orm");
const type_1 = require("@deepkit/type");
const query_1 = require("./query");
const persistence_1 = require("./persistence");
const client_1 = require("./client/client");
const delete_1 = require("./client/command/delete");
const query_resolver_1 = require("./query.resolver");
class MongoDatabaseQueryFactory extends orm_1.DatabaseAdapterQueryFactory {
    constructor(client, databaseSession) {
        super();
        this.client = client;
        this.databaseSession = databaseSession;
    }
    createQuery(classType) {
        const schema = type_1.getClassSchema(classType);
        return new query_1.MongoDatabaseQuery(schema, this.databaseSession, new query_resolver_1.MongoQueryResolver(schema, this.databaseSession, this.client));
    }
}
exports.MongoDatabaseQueryFactory = MongoDatabaseQueryFactory;
class MongoDatabaseAdapter extends orm_1.DatabaseAdapter {
    constructor(connectionString) {
        super();
        this.ormSequences = type_1.t.schema({
            name: type_1.t.string,
            value: type_1.t.number,
        }, { name: this.getAutoIncrementSequencesCollection() });
        this.client = new client_1.MongoClient(connectionString);
    }
    getName() {
        return 'mongo';
    }
    getSchemaName() {
        return '';
    }
    createPersistence(session) {
        return new persistence_1.MongoPersistence(this.client, this.ormSequences, session);
    }
    isNativeForeignKeyConstraintSupported() {
        return false;
    }
    queryFactory(databaseSession) {
        return new MongoDatabaseQueryFactory(this.client, databaseSession);
    }
    disconnect(force) {
        this.client.close();
    }
    getAutoIncrementSequencesCollection() {
        return 'orm_sequences';
    }
    async resetAutoIncrementSequences() {
        await this.client.execute(new delete_1.DeleteCommand(this.ormSequences));
    }
    async migrate(classSchemas) {
        // for (const schema of classSchemas) {
        //     const collection = await this.connection.getCollection(schema);
        //     //collection not existing yet, so create lock
        //     for (const [name, index] of schema.indices.entries()) {
        //         const fields: { [name: string]: 1 } = {};
        //
        //         if (index.fields.length === 1 && index.fields[0] === '_id') continue;
        //
        //         for (const f of index.fields) {
        //             fields[f] = 1;
        //         }
        //
        //         const options: any = {
        //             name: name
        //         };
        //         if (index.options.unique) options.unique = true;
        //         if (index.options.sparse) options.sparse = true;
        //
        //         try {
        //             await collection.createIndex(fields, options);
        //         } catch (error) {
        //             console.log('failed index', name, '. Recreate ...');
        //             //failed, so drop and re-create
        //             await collection.dropIndex(name);
        //             await collection.createIndex(fields, options);
        //         }
        //     }
        // }
    }
    ;
}
exports.MongoDatabaseAdapter = MongoDatabaseAdapter;
//# sourceMappingURL=adapter.js.map