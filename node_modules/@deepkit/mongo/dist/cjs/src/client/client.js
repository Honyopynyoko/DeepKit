"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoClient = void 0;
const connection_1 = require("./connection");
const error_1 = require("./error");
const core_1 = require("@deepkit/core");
const drop_database_1 = require("./command/drop-database");
const config_1 = require("./config");
class MongoClient {
    constructor(connectionString) {
        this.inCloseProcedure = false;
        this.config = new config_1.MongoClientConfig(connectionString);
        this.connectionPool = new connection_1.MongoConnectionPool(this.config);
    }
    resolveCollectionName(schema) {
        return this.config.resolveCollectionName(schema);
    }
    async connect() {
        await this.connectionPool.connect();
    }
    close() {
        this.inCloseProcedure = true;
        this.connectionPool.close();
    }
    async dropDatabase(dbName) {
        await this.execute(new drop_database_1.DropDatabaseCommand(dbName));
    }
    /**
     * Returns an existing or new connection, that needs to be released once done using it.
     */
    getConnection(request = {}) {
        return this.connectionPool.getConnection(request);
    }
    async execute(command) {
        const maxRetries = 10;
        const request = { writable: command.needsWritableHost() };
        await this.connectionPool.ensureHostsConnected(true);
        for (let i = 1; i <= maxRetries; i++) {
            const connection = await this.connectionPool.getConnection(request);
            try {
                return await connection.execute(command);
            }
            catch (error) {
                if (command.needsWritableHost()) {
                    if (!error_1.isErrorRetryableWrite(error))
                        throw error;
                }
                else {
                    if (!error_1.isErrorRetryableRead(error))
                        throw error;
                }
                if (i == maxRetries) {
                    throw error;
                }
                await core_1.sleep(0.25);
            }
            finally {
                connection.release();
            }
        }
        throw new error_1.MongoError(`Could not execute command since no connection found: ${command}`);
    }
}
exports.MongoClient = MongoClient;
//# sourceMappingURL=client.js.map