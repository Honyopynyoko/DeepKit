"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sha256ScramAuth = exports.Sha1ScramAuth = exports.ScramAuth = void 0;
const crypto_1 = require("crypto");
const type_1 = require("@deepkit/type");
const command_1 = require("../command");
const error_1 = require("../../error");
// @ts-ignore
const saslprep_1 = __importDefault(require("saslprep"));
class SaslStartCommand extends type_1.t.class({
    saslStart: type_1.t.literal(1),
    $db: type_1.t.string,
    mechanism: type_1.t.string,
    payload: type_1.t.type(Uint8Array),
    autoAuthorize: type_1.t.literal(1),
    options: {
        skipEmptyExchange: type_1.t.literal(true)
    }
}) {
}
class SaslStartResponse extends type_1.t.extendClass(command_1.BaseResponse, {
    conversationId: type_1.t.number,
    payload: type_1.t.type(Uint8Array),
    done: type_1.t.boolean,
}) {
}
class SaslContinueCommand extends type_1.t.class({
    saslContinue: type_1.t.literal(1),
    $db: type_1.t.string,
    conversationId: type_1.t.number,
    payload: type_1.t.type(Buffer),
}) {
}
class SaslContinueResponse extends type_1.t.extendClass(command_1.BaseResponse, {
    conversationId: type_1.t.literal(1),
    payload: type_1.t.type(Uint8Array),
    done: type_1.t.boolean,
}) {
}
function H(method, text) {
    return crypto_1.createHash(method).update(text).digest();
}
function HMAC(method, key, text) {
    return crypto_1.createHmac(method, key).update(text).digest();
}
function cleanUsername(username) {
    return username.replace('=', '=3D').replace(',', '=2C');
}
function passwordDigest(u, p) {
    if (p.length === 0)
        throw new error_1.MongoError('password cannot be empty');
    const md5 = crypto_1.createHash('md5');
    md5.update(`${u}:mongo:${p}`, 'utf8'); //lgtm[js/weak-cryptographic-algorithm] lgtm[js/insufficient-password-hash]
    return md5.digest('hex');
}
function HI(data, salt, iterations, cryptoAlgorithm) {
    if (cryptoAlgorithm !== 'sha1' && cryptoAlgorithm !== 'sha256') {
        throw new error_1.MongoError(`Invalid crypto algorithm ${cryptoAlgorithm}`);
    }
    //should we implement a cache like the original driver?
    return crypto_1.pbkdf2Sync(data, salt, iterations, cryptoAlgorithm === 'sha1' ? 20 : 32, cryptoAlgorithm);
}
function xor(a, b) {
    const length = Math.max(a.length, b.length);
    const buffer = Buffer.alloc(length);
    for (let i = 0; i < length; i++)
        buffer[i] = a[i] ^ b[i];
    return buffer;
}
class ScramAuth {
    constructor(mechanism) {
        this.mechanism = mechanism;
        this.nonce = crypto_1.randomBytes(24);
        this.cryptoMethod = this.mechanism === 'SCRAM-SHA-1' ? 'sha1' : 'sha256';
    }
    async auth(command, config) {
        const username = cleanUsername(config.authUser || '');
        const password = config.authPassword || '';
        const startResponse = await command.sendAndWait(SaslStartCommand, {
            saslStart: 1,
            $db: config.getAuthSource(),
            mechanism: this.mechanism,
            payload: Buffer.concat([Buffer.from('n,,', 'utf8'), this.clientFirstMessageBare(username, this.nonce)]),
            autoAuthorize: 1,
            options: { skipEmptyExchange: true }
        }, SaslStartResponse);
        const processedPassword = this.mechanism === 'SCRAM-SHA-256' ? saslprep_1.default(password) : passwordDigest(username, password);
        const payloadAsString = Buffer.from(startResponse.payload).toString('utf8');
        const payloadStart = this.parseStartPayload(payloadAsString);
        const withoutProof = `c=biws,r=${payloadStart.r}`;
        const saltedPassword = HI(processedPassword, Buffer.from(payloadStart.s, 'base64'), payloadStart.i, this.cryptoMethod);
        const clientKey = HMAC(this.cryptoMethod, saltedPassword, 'Client Key');
        const serverKey = HMAC(this.cryptoMethod, saltedPassword, 'Server Key');
        const storedKey = H(this.cryptoMethod, clientKey);
        const authMessage = [
            this.clientFirstMessageBare(username, this.nonce),
            payloadAsString,
            withoutProof
        ].join(',');
        const clientSignature = HMAC(this.cryptoMethod, storedKey, authMessage);
        const clientProof = `p=${xor(clientKey, clientSignature).toString('base64')}`;
        const clientFinal = [withoutProof, clientProof].join(',');
        const serverSignature = HMAC(this.cryptoMethod, serverKey, authMessage);
        const continueResponse = await command.sendAndWait(SaslContinueCommand, {
            saslContinue: 1,
            $db: config.getAuthSource(),
            conversationId: startResponse.conversationId,
            payload: Buffer.from(clientFinal)
        }, SaslContinueResponse);
        const payloadContinueString = Buffer.from(continueResponse.payload).toString('utf8');
        const payloadContinue = this.parseContinuePayload(payloadContinueString);
        if (!crypto_1.timingSafeEqual(Buffer.from(payloadContinue.v, 'base64'), serverSignature)) {
            throw new error_1.MongoError('Server returned an invalid signature');
        }
        if (continueResponse.done)
            return;
        //not done yet, fire an empty round
        const continueResponse2 = await command.sendAndWait(SaslContinueCommand, {
            saslContinue: 1,
            $db: config.getAuthSource(),
            conversationId: startResponse.conversationId,
            payload: Buffer.alloc(0)
        }, SaslContinueResponse);
        if (continueResponse2.done)
            return;
        throw new error_1.MongoError('Sasl reached end and never never acknowledged a done.');
    }
    //e.g. "r=fyko+d2lbbFgONRv9qkxdawLHo+Vgk7qvUOKUwuWLIWg4l/9SraGMHEE,s=rQ9ZY3MntBeuP3E1TDVC4w==,i=10000"
    parseStartPayload(payload) {
        const result = { r: '', s: '', i: 0 };
        for (const pair of payload.split(',')) {
            const firstSign = pair.indexOf('=');
            const name = pair.substr(0, firstSign);
            const value = pair.substr(firstSign + 1);
            result[name] = name === 'i' ? parseInt(value, 10) : value;
        }
        if (result.i < 4096)
            throw new error_1.MongoError(`Server returned an invalid iteration count ${result.i}`);
        if (result.r.startsWith('nonce'))
            throw new error_1.MongoError(`Server returned an invalid nonce: ${result.r}`);
        return result;
    }
    //e.g. "v=UMWeI25JD1yNYZRMpZ4VHvhZ9e0="
    parseContinuePayload(payload) {
        const result = { v: '' };
        for (const pair of payload.split(',')) {
            const firstSign = pair.indexOf('=');
            const name = pair.substr(0, firstSign);
            result[name] = pair.substr(firstSign + 1);
        }
        return result;
    }
    clientFirstMessageBare(username, nonce) {
        // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.
        // Since the username is not sasl-prep-d, we need to do this here.
        return Buffer.from(`n=${username},r=${nonce.toString('base64')}`, 'utf8');
    }
}
exports.ScramAuth = ScramAuth;
class Sha1ScramAuth extends ScramAuth {
    constructor() {
        super('SCRAM-SHA-1');
    }
}
exports.Sha1ScramAuth = Sha1ScramAuth;
class Sha256ScramAuth extends ScramAuth {
    constructor() {
        super('SCRAM-SHA-256');
    }
}
exports.Sha256ScramAuth = Sha256ScramAuth;
//# sourceMappingURL=scram.js.map