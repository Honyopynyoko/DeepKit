/// <reference types="node" />
import { ClassSchema, ExtractClassType } from '@deepkit/type';
import { ClassType } from '@deepkit/core';
import { MongoClientConfig } from '../config';
import { Host } from '../host';
export interface CommandMessageResponseCallbackResult<T> {
    /**
     * When the command is finished, set the `result`
     */
    result?: T;
    /**
     * When the command is not finished and another message should be sent, set the new CommandMessage
     * as `next`.
     */
    next?: CommandMessage<any, any>;
}
export declare class CommandMessage<T, R extends ClassSchema | ClassType> {
    readonly schema: ClassSchema<T>;
    readonly message: T;
    readonly responseSchema: R;
    readonly responseCallback: (response: ExtractClassType<R>) => {
        result?: any;
        next?: CommandMessage<any, any>;
    };
    constructor(schema: ClassSchema<T>, message: T, responseSchema: R, responseCallback: (response: ExtractClassType<R>) => {
        result?: any;
        next?: CommandMessage<any, any>;
    });
}
export declare const BaseResponse: ClassSchema<import("@deepkit/type").ExtractClassDefinition<{
    ok: import("@deepkit/type").FieldDecoratorResult<number>;
    errmsg: import("@deepkit/type").FieldDecoratorResult<string | undefined>;
    code: import("@deepkit/type").FieldDecoratorResult<number | undefined>;
    codeName: import("@deepkit/type").FieldDecoratorResult<string | undefined>;
}>>;
export declare abstract class Command {
    protected current?: {
        response?: ClassSchema | ClassType;
        resolve: Function;
        reject: Function;
    };
    sender?: (schema: ClassSchema | ClassType, message: Buffer) => void;
    sendAndWait<T extends ClassSchema | ClassType, R extends ClassSchema | ClassType>(schema: T, message: ExtractClassType<T>, response?: R): Promise<ExtractClassType<R>>;
    abstract execute(config: MongoClientConfig, host: Host): Promise<any>;
    abstract needsWritableHost(): boolean;
    handleResponse(response: Uint8Array): void;
}
