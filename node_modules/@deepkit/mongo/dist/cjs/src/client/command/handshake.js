"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandshakeCommand = void 0;
const type_1 = require("@deepkit/type");
const command_1 = require("./command");
const ismaster_1 = require("./ismaster");
const scram_1 = require("./auth/scram");
const error_1 = require("../error");
const x509_1 = require("./auth/x509");
const isMasterSchema = type_1.t.schema({
    isMaster: type_1.t.number,
    $db: type_1.t.string,
    saslSupportedMechs: type_1.t.string.optional,
    client: {
        // application: {
        //     name: t.string,
        // },
        driver: {
            name: type_1.t.string,
            version: type_1.t.string,
        },
        os: {
            type: type_1.t.string,
        }
    }
});
class NotImplemented {
    constructor() {
        throw new error_1.MongoError('Auth not implemented yet');
    }
}
const authClassTypes = {
    ["scram-sha-1" /* MONGODB_SCRAM_SHA1 */]: scram_1.Sha1ScramAuth,
    ["scram-sha-256" /* MONGODB_SCRAM_SHA256 */]: scram_1.Sha256ScramAuth,
    ["x509" /* MONGODB_X509 */]: x509_1.X509Auth,
    ["mongodb-aws" /* MONGODB_AWS */]: NotImplemented,
    ["gssapi" /* MONGODB_GSSAPI */]: NotImplemented,
    ["plain" /* MONGODB_PLAIN */]: NotImplemented,
};
function detectedAuthMechanismFromResponse(response) {
    if (response.saslSupportedMechs && response.saslSupportedMechs.includes('SCRAM-SHA-256')) {
        return "scram-sha-256" /* MONGODB_SCRAM_SHA256 */;
    }
    return "scram-sha-1" /* MONGODB_SCRAM_SHA1 */;
}
/**
 * A handshake happens directly when a connection has been established.
 * It differs to regular IsMasterCommand in a way that it sends `client` data as well,
 * which is only allowed at the first message, and additionally sends auth data if necessary.
 */
class HandshakeCommand extends command_1.Command {
    needsWritableHost() {
        return false;
    }
    async execute(config, host) {
        const db = config.getAuthSource();
        const cmd = {
            isMaster: 1,
            $db: db,
            saslSupportedMechs: !config.options.authMechanism && config.authUser ? `${db}.${config.authUser}` : undefined,
            client: {
                // application: {
                //     name: 'undefined'
                // },
                driver: {
                    name: 'deepkit/mongo',
                    version: '1.0.0'
                },
                os: {
                    type: 'Darwin'
                }
            }
        };
        const response = await this.sendAndWait(isMasterSchema, cmd, ismaster_1.IsMasterResponse);
        const hostType = host.getTypeFromIsMasterResult(response);
        host.setType(hostType);
        if (hostType === 5 /* arbiter */) {
            //If the server is of type RSArbiter, no authentication is possible and the handshake is complete.
            return true;
        }
        if (config.authUser) {
            await this.doAuth(config, response);
        }
        return true;
    }
    async doAuth(config, response) {
        const authType = config.options.authMechanism || detectedAuthMechanismFromResponse(response);
        const authClassType = authClassTypes[authType];
        const auth = new authClassType;
        await auth.auth(this, config);
    }
}
exports.HandshakeCommand = HandshakeCommand;
//# sourceMappingURL=handshake.js.map