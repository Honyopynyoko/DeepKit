"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoClientConfig = void 0;
const host_1 = require("./host");
const options_1 = require("./options");
const url_1 = require("url");
const type_1 = require("@deepkit/type");
const querystring_1 = require("querystring");
const error_1 = require("./error");
const core_1 = require("@deepkit/core");
const dns_1 = require("./dns");
/**
 * Default URL:
 * mongodb://mongodb0.example.com:27017
 *
 * ReplicaSet UR:
 * mongodb://mongodb0.example.com:27017,mongodb1.example.com:27017,mongodb2.example.com:27017/?replicaSet=myRepl
 *
 * Shared URL:
 * mongodb://mongos0.example.com:27017,mongos1.example.com:27017,mongos2.example.com:27017
 *
 * SVR URL:
 * mongodb+srv://server.example.com/
 */
class MongoClientConfig {
    constructor(connectionString) {
        this.hosts = [];
        /**
         * In seconds.
         */
        this.srvCacheTimeout = 3600;
        this.options = new options_1.ConnectionOptions;
        this.isSrv = false;
        this.srvDomain = '';
        this.parseConnectionString(connectionString);
    }
    parseConnectionString(url) {
        //we replace only first `,` with `/,` so we get additional host names in parsed.path
        url = url.replace(',', '/,');
        const parsed = url_1.parse(url);
        //e.g. for `mongodb://peter:asd@localhost,127.0.0.1,yetanother/asd`
        //parsed.pathname contains now /,127.0.0.1,yetanother/asd
        //and parsed.hostname localhost. Thus we merge those, when we detect `/,` in path
        const hostnames = [];
        let defaultDb = parsed.pathname ? parsed.pathname.substr(1) : '';
        if (!parsed.hostname)
            throw new Error('No hostname found in connection string');
        hostnames.push(`${parsed.hostname}:${parsed.port || 27017}`);
        if (parsed.pathname && parsed.pathname.startsWith('/,')) {
            //we got multiple host names
            const lastSlash = parsed.pathname.lastIndexOf('/');
            if (lastSlash === 0) {
                //no database name provided, so whole path contains host names
                //offset `2` because `/,`
                hostnames.push(...parsed.pathname.substr(2).split(','));
                defaultDb = '';
            }
            else {
                hostnames.push(...parsed.pathname.substr(2, lastSlash).split(','));
                defaultDb = parsed.pathname.substr(lastSlash + 1);
            }
        }
        this.hosts.splice(0, this.hosts.length);
        for (const hostname of hostnames) {
            const [host, port] = hostname.split(':');
            this.hosts.push(new host_1.Host(host, port ? parseInt(port, 10) : 27017));
        }
        this.defaultDb = defaultDb;
        if (parsed.auth) {
            const firstColon = parsed.auth.indexOf(':');
            if (firstColon === -1) {
                this.authUser = parsed.auth;
            }
            else {
                this.authUser = parsed.auth.substr(0, firstColon);
                this.authPassword = parsed.auth.substr(firstColon + 1);
            }
        }
        this.options = type_1.jsonSerializer.for(options_1.ConnectionOptions).validatedDeserialize(parsed.query ? querystring_1.parse(parsed.query) : {});
        if (url.startsWith('mongodb+srv://')) {
            this.isSrv = true;
            this.srvDomain = this.hosts[0].hostname;
        }
    }
    //see https://docs.mongodb.com/manual/reference/connection-string/#urioption.authSource
    getAuthSource() {
        return this.options.authSource || this.defaultDb || 'admin';
    }
    async resolveSrvHosts() {
        return await dns_1.resolveSrvHosts(this.srvDomain);
    }
    newHost(hostname, port) {
        const host = new host_1.Host(hostname, port);
        this.hosts.push(host);
    }
    findHostBy(hostname, port) {
        for (const host of this.hosts) {
            if (host.hostname === hostname && host.port === port)
                return host;
        }
        throw new error_1.MongoError(`Could not find host ${hostname}:${port}`);
    }
    deleteHost(hostname, port) {
        const host = this.findHostBy(hostname, port);
        core_1.arrayRemoveItem(this.hosts, host);
        for (const connection of host.connections) {
            connection.close();
        }
    }
    resolveCollectionName(schema) {
        schema = type_1.getClassSchema(schema);
        return schema.collectionName || schema.name || 'unknown';
    }
    async getHosts() {
        if (this.isSrv) {
            if (this.srvDomain === 'example.com')
                return [];
            //todo: refactor this to do it in the background
            if (this.hostsFetchedMS) {
                const diff = (Date.now() - this.hostsFetchedMS) / 1000;
                if (diff < this.srvCacheTimeout)
                    return this.hosts;
            }
            const hostsData = await this.resolveSrvHosts();
            const options = { ...hostsData.options ? querystring_1.parse(hostsData.options) : {} };
            const partialOptions = type_1.jsonSerializer.for(options_1.ConnectionOptions).validatedDeserialize(options);
            for (const [k, v] of core_1.eachPair(partialOptions)) {
                this.options[k] = v;
            }
            const hosts = hostsData.hosts;
            const removedHosts = new Map();
            for (const host of this.hosts) {
                removedHosts.set(host.id, host);
            }
            for (const host of hosts) {
                const id = `${host.hostname}:${host.port}`;
                if (removedHosts.has(id)) {
                    removedHosts.delete(id);
                }
                else {
                    //we got a new one
                    this.newHost(host.hostname, host.port);
                }
            }
            //removedHosts contains now all no longer valid hosts
            for (const removedHost of removedHosts.values()) {
                this.deleteHost(removedHost.hostname, removedHost.port);
            }
            this.hostsFetchedMS = Date.now();
            //default to SSL true if it's not specified
            if (this.options.ssl === undefined) {
                this.options.ssl = true;
            }
        }
        return this.hosts;
    }
}
__decorate([
    core_1.singleStack(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MongoClientConfig.prototype, "getHosts", null);
exports.MongoClientConfig = MongoClientConfig;
//# sourceMappingURL=config.js.map