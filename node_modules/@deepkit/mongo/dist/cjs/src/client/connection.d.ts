/// <reference types="node" />
import { ClassType } from '@deepkit/core';
import { Host } from './host';
import { Socket } from 'net';
import { TLSSocket } from 'tls';
import { Command } from './command/command';
import { ClassSchema } from '@deepkit/type';
import { MongoClientConfig } from './config';
export declare enum MongoConnectionStatus {
    pending = "pending",
    connecting = "connecting",
    connected = "connected",
    disconnected = "disconnected"
}
export interface ConnectionRequest {
    writable?: boolean;
    nearest?: boolean;
}
export declare class MongoConnectionPool {
    protected config: MongoClientConfig;
    protected connectionId: number;
    /**
     * Connections, might be in any state, not necessarily connected.
     */
    connections: MongoConnection[];
    protected nextConnectionClose: Promise<boolean>;
    constructor(config: MongoClientConfig);
    protected waitForAllConnectionsToConnect(throws?: boolean): Promise<void>;
    connect(): Promise<void>;
    close(): void;
    ensureHostsConnected(throws?: boolean): Promise<void>;
    protected findHostForRequest(hosts: Host[], request: ConnectionRequest): Host;
    protected createAdditionalConnectionForRequest(request: ConnectionRequest): MongoConnection;
    protected newConnection(host: Host): MongoConnection;
    protected release(connection: MongoConnection): void;
    /**
     * Returns an existing or new connection, that needs to be released once done using it.
     */
    getConnection(request: ConnectionRequest): Promise<MongoConnection>;
}
export declare function readUint32LE(buffer: Uint8Array | ArrayBuffer, offset?: number): number;
export declare class MongoConnection {
    id: number;
    readonly host: Host;
    protected config: MongoClientConfig;
    protected onClose: (connection: MongoConnection) => void;
    protected onRelease: (connection: MongoConnection) => void;
    protected messageId: number;
    status: MongoConnectionStatus;
    bufferSize: number;
    connectingPromise?: Promise<void>;
    lastCommand?: {
        command: Command;
        promise?: Promise<any>;
    };
    activeCommands: number;
    executedCommands: number;
    activeTransaction: boolean;
    reserved: boolean;
    cleanupTimeout: any;
    protected socket: Socket | TLSSocket;
    responseParser: ResponseParser;
    protected boundSendMessage: <T>(schema: ClassType<T> | ClassSchema<T>, message: T) => void;
    constructor(id: number, host: Host, config: MongoClientConfig, onClose: (connection: MongoConnection) => void, onRelease: (connection: MongoConnection) => void);
    isConnected(): boolean;
    isConnecting(): boolean;
    close(): void;
    release(): void;
    /**
     * When a full message from the server was received.
     */
    protected onResponse(response: Uint8Array): void;
    /**
     * Puts a command on the queue and executes it when queue is empty.
     * A promises is return that is resolved with the  when executed successfully, or rejected
     * when timed out, parser error, or any other error.
     */
    execute<T extends Command>(command: T): Promise<ReturnType<T['execute']>>;
    protected sendMessage<T>(schema: ClassType<T> | ClassSchema<T>, message: T): void;
    connect(): Promise<void>;
}
export declare class ResponseParser {
    protected readonly onMessage: (response: Uint8Array) => void;
    protected currentMessage?: Uint8Array;
    protected currentMessageSize: number;
    constructor(onMessage: (response: Uint8Array) => void);
    feed(data: Uint8Array, bytes?: number): void;
}
