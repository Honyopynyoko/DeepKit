"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponseParser = exports.MongoConnection = exports.readUint32LE = exports.MongoConnectionPool = exports.MongoConnectionStatus = void 0;
const core_1 = require("@deepkit/core");
const net_1 = require("net");
const tls_1 = require("tls");
const type_1 = require("@deepkit/type");
const bson_1 = require("@deepkit/bson");
const handshake_1 = require("./command/handshake");
const error_1 = require("./error");
var MongoConnectionStatus;
(function (MongoConnectionStatus) {
    MongoConnectionStatus["pending"] = "pending";
    MongoConnectionStatus["connecting"] = "connecting";
    MongoConnectionStatus["connected"] = "connected";
    MongoConnectionStatus["disconnected"] = "disconnected";
})(MongoConnectionStatus = exports.MongoConnectionStatus || (exports.MongoConnectionStatus = {}));
class MongoConnectionPool {
    constructor(config) {
        this.config = config;
        this.connectionId = 0;
        /**
         * Connections, might be in any state, not necessarily connected.
         */
        this.connections = [];
        this.nextConnectionClose = Promise.resolve(true);
    }
    async waitForAllConnectionsToConnect(throws = false) {
        const promises = [];
        for (const connection of this.connections) {
            if (connection.connectingPromise) {
                promises.push(connection.connectingPromise);
            }
        }
        if (promises.length) {
            if (throws) {
                await Promise.all(promises);
            }
            else {
                await Promise.allSettled(promises);
            }
        }
    }
    async connect() {
        await this.ensureHostsConnected(true);
    }
    close() {
        //import to work on the copy, since Connection.onClose modifies this.connections.
        const connections = this.connections.slice(0);
        for (const connection of connections) {
            connection.close();
        }
    }
    async ensureHostsConnected(throws = false) {
        //make sure each host has at least one connection
        //getHosts automatically updates hosts (mongodb-srv) and returns new one,
        //so we don't need any interval to automatically update it.
        const hosts = await this.config.getHosts();
        for (const host of hosts) {
            if (host.connections.length > 0)
                continue;
            this.newConnection(host);
        }
        await this.waitForAllConnectionsToConnect(throws);
    }
    findHostForRequest(hosts, request) {
        //todo, handle request.nearest
        for (const host of hosts) {
            if (request.writable && host.isWritable())
                return host;
            if (!request.writable && host.isReadable())
                return host;
        }
        throw new error_1.MongoError(`Could not find host for connection request. (writable=${request.writable}, hosts=${hosts.length})`);
    }
    createAdditionalConnectionForRequest(request) {
        const hosts = this.config.hosts;
        const host = this.findHostForRequest(hosts, request);
        if (!host)
            throw new error_1.MongoError(`Could not find host for connection request. (writable=${request.writable}, hosts=${hosts.length})`);
        return this.newConnection(host);
    }
    newConnection(host) {
        const connection = new MongoConnection(this.connectionId++, host, this.config, (connection) => {
            core_1.arrayRemoveItem(host.connections, connection);
            core_1.arrayRemoveItem(this.connections, connection);
            //onClose does not automatically reconnect. Only new commands re-establish connections.
        }, (connection) => {
            this.release(connection);
        });
        host.connections.push(connection);
        this.connections.push(connection);
        // console.log('newConnection', connection.id);
        return connection;
    }
    release(connection) {
        connection.reserved = false;
        // console.log('release', connection.id, JSON.stringify(this.config.options.maxIdleTimeMS));
        connection.cleanupTimeout = setTimeout(() => {
            if (this.connections.length <= this.config.options.minPoolSize) {
                return;
            }
            connection.close();
        }, this.config.options.maxIdleTimeMS);
    }
    /**
     * Returns an existing or new connection, that needs to be released once done using it.
     */
    async getConnection(request) {
        do {
            for (const connection of this.connections) {
                if (!connection.isConnected())
                    continue;
                if (connection.reserved)
                    continue;
                if (request.nearest)
                    throw new Error('Nearest not implemented yet');
                if (request.writable && !connection.host.isWritable())
                    continue;
                if (!request.writable) {
                    if (connection.host.isSecondary() && !this.config.options.secondaryReadAllowed)
                        continue;
                    if (!connection.host.isReadable())
                        continue;
                }
                connection.reserved = true;
                if (connection.cleanupTimeout) {
                    clearTimeout(connection.cleanupTimeout);
                    connection.cleanupTimeout = undefined;
                }
                return connection;
            }
            if (this.connections.length < this.config.options.maxPoolSize) {
                const connection = await this.createAdditionalConnectionForRequest(request);
                connection.reserved = true;
                return connection;
            }
            await core_1.sleep(0.1);
        } while (true);
    }
}
exports.MongoConnectionPool = MongoConnectionPool;
function readUint32LE(buffer, offset = 0) {
    return buffer[offset] + (buffer[offset + 1] * 2 ** 8) + (buffer[offset + 2] * 2 ** 16) + (buffer[offset + 3] * 2 ** 24);
}
exports.readUint32LE = readUint32LE;
class MongoConnection {
    constructor(id, host, config, onClose, onRelease) {
        this.id = id;
        this.host = host;
        this.config = config;
        this.onClose = onClose;
        this.onRelease = onRelease;
        this.messageId = 0;
        this.status = MongoConnectionStatus.pending;
        this.bufferSize = 2.5 * 1024 * 1024;
        this.activeCommands = 0;
        this.executedCommands = 0;
        this.activeTransaction = false;
        this.reserved = false;
        this.boundSendMessage = this.sendMessage.bind(this);
        const responseParser = this.responseParser = new ResponseParser(this.onResponse.bind(this));
        if (this.config.options.ssl === true) {
            const options = {
                host: host.hostname,
                port: host.port,
                timeout: config.options.connectTimeoutMS,
                servername: host.hostname
            };
            const optional = {
                ca: config.options.tlsCAFile,
                key: config.options.tlsCertificateKeyFile || config.options.tlsCertificateFile,
                cert: config.options.tlsCertificateFile,
                passphrase: config.options.tlsCertificateKeyFilePassword,
                rejectUnauthorized: config.options.rejectUnauthorized,
                crl: config.options.tlsCRLFile,
                checkServerIdentity: config.options.checkServerIdentity ? undefined : () => undefined,
            };
            for (const i in optional) {
                if (optional[i])
                    options[i] = optional[i];
            }
            this.socket = tls_1.connect(options);
            this.socket.on('data', (data) => this.responseParser.feed(data));
        }
        else {
            this.socket = net_1.createConnection({
                host: host.hostname,
                port: host.port,
                timeout: config.options.connectTimeoutMS
            });
            this.socket.on('data', (data) => this.responseParser.feed(data));
            // const socket = this.socket = turbo.connect(host.port, host.hostname);
            // // this.socket.setNoDelay(true);
            // const buffer = Buffer.allocUnsafe(this.bufferSize);
            //
            // function read() {
            //     socket.read(buffer, onRead);
            // }
            //
            // function onRead(err: any, buf: Buffer, bytes: number) {
            //     if (!bytes) return;
            //     responseParser.feed(buf, bytes);
            //     read();
            // }
            //
            // read();
        }
        this.socket.on('close', () => {
            this.status = MongoConnectionStatus.disconnected;
            onClose(this);
        });
        //important to catch it, so it doesn't bubble up
        this.connect().catch(() => {
            this.socket.end();
        });
    }
    isConnected() {
        return this.status === MongoConnectionStatus.connected;
    }
    isConnecting() {
        return this.status === MongoConnectionStatus.connecting;
    }
    close() {
        this.status = MongoConnectionStatus.disconnected;
        this.socket.end();
    }
    release() {
        this.onRelease(this);
    }
    /**
     * When a full message from the server was received.
     */
    onResponse(response) {
        //we remove the header for the command
        const size = readUint32LE(response);
        const offset = 16 + 4 + 1; //MSG response
        // const offset = 16 + 4 + 8 + 4 + 4; //QUERY_REPLY
        const message = response.slice(offset, size);
        if (!this.lastCommand)
            throw new Error(`Got a server response without active command`);
        this.lastCommand.command.handleResponse(message);
    }
    /**
     * Puts a command on the queue and executes it when queue is empty.
     * A promises is return that is resolved with the  when executed successfully, or rejected
     * when timed out, parser error, or any other error.
     */
    async execute(command) {
        if (this.status === MongoConnectionStatus.pending)
            await this.connect();
        if (this.status === MongoConnectionStatus.disconnected)
            throw new Error('Disconnected');
        if (this.lastCommand && this.lastCommand.promise) {
            await this.lastCommand.promise;
        }
        this.lastCommand = { command };
        this.activeCommands++;
        this.executedCommands++;
        command.sender = this.boundSendMessage;
        try {
            this.lastCommand.promise = command.execute(this.config, this.host);
            return await this.lastCommand.promise;
        }
        finally {
            this.lastCommand = undefined;
            this.activeCommands--;
        }
    }
    sendMessage(schema, message) {
        const messageSerializer = bson_1.getBSONSerializer(schema);
        const messageSizer = bson_1.getBSONSizer(schema);
        const buffer = Buffer.allocUnsafe(16 + 4 + 1 + messageSizer(message));
        // const buffer = Buffer.alloc(16 + 4 + 10 + 1 + 4 + 4 + calculateObjectSize(message));
        const writer = new bson_1.Writer(buffer);
        //header, 16 bytes
        const messageId = ++this.messageId;
        writer.writeInt32(10); //messageLength, 4
        writer.writeInt32(messageId); //requestID, 4
        writer.writeInt32(0); //responseTo, 4
        writer.writeInt32(2013); //OP_MSG, 4
        // writer.writeInt32(2004); //OP_QUERY, 4
        //OP_MSG, 5 bytes
        writer.writeUint32(0); //message flags, 4
        writer.writeByte(0); //kind 0, 1
        // //OP_QUERY, 5 bytes
        // writer.writeUint32(0); //message flags, 4
        // writer.writeAsciiString('admin.$cmd'); //collection name, 10
        // writer.writeByte(0); //null, 1
        // writer.writeInt32(0); //skip, 4
        // writer.writeInt32(1); //return, 4
        try {
            const section = messageSerializer(message);
            // const section = serialize(message);
            writer.writeBuffer(section);
            const messageLength = writer.offset;
            writer.offset = 0;
            writer.writeInt32(messageLength);
            //detect backPressure
            this.socket.write(buffer);
        }
        catch (error) {
            console.log('failed sending message', message, 'using schema', type_1.getClassSchema(schema).toString());
            throw error;
        }
    }
    async connect() {
        if (this.status === MongoConnectionStatus.disconnected)
            throw new Error('Connection disconnected');
        if (this.status !== MongoConnectionStatus.pending)
            return;
        this.status = MongoConnectionStatus.connecting;
        this.connectingPromise = core_1.asyncOperation(async (resolve, reject) => {
            this.socket.on('error', (error) => {
                this.connectingPromise = undefined;
                this.status = MongoConnectionStatus.disconnected;
                reject(error);
            });
            if (this.socket.destroyed) {
                this.status = MongoConnectionStatus.disconnected;
                this.connectingPromise = undefined;
                resolve();
            }
            if (await this.execute(new handshake_1.HandshakeCommand())) {
                this.status = MongoConnectionStatus.connected;
                this.socket.setTimeout(this.config.options.socketTimeoutMS);
                this.connectingPromise = undefined;
                resolve();
            }
            else {
                this.status = MongoConnectionStatus.disconnected;
                this.connectingPromise = undefined;
                reject(new error_1.MongoError('Could not complete handshake 🤷‍️'));
            }
        });
        return this.connectingPromise;
    }
}
exports.MongoConnection = MongoConnection;
class ResponseParser {
    constructor(onMessage) {
        this.onMessage = onMessage;
        this.currentMessageSize = 0;
    }
    feed(data, bytes) {
        if (!data.byteLength)
            return;
        if (!bytes)
            bytes = data.byteLength;
        if (!this.currentMessage) {
            if (data.byteLength < 4) {
                //not enough data to read the header. Wait for next onData
                return;
            }
            this.currentMessage = data.byteLength === bytes ? data : data.slice(0, bytes);
            this.currentMessageSize = readUint32LE(data);
        }
        else {
            this.currentMessage = Buffer.concat([this.currentMessage, data.byteLength === bytes ? data : data.slice(0, bytes)]);
            if (!this.currentMessageSize) {
                if (this.currentMessage.byteLength < 4) {
                    //not enough data to read the header. Wait for next onData
                    return;
                }
                this.currentMessageSize = readUint32LE(this.currentMessage);
            }
        }
        let currentSize = this.currentMessageSize;
        let currentBuffer = this.currentMessage;
        while (currentBuffer) {
            if (currentSize > currentBuffer.byteLength) {
                //important to copy, since the incoming might change its data
                this.currentMessage = new Uint8Array(currentBuffer);
                // this.currentMessage = currentBuffer;
                this.currentMessageSize = currentSize;
                //message not completely loaded, wait for next onData
                return;
            }
            if (currentSize === currentBuffer.byteLength) {
                //current buffer is exactly the message length
                this.currentMessageSize = 0;
                this.currentMessage = undefined;
                this.onMessage(currentBuffer);
                return;
            }
            if (currentSize < currentBuffer.byteLength) {
                //we have more messages in this buffer. read what is necessary and hop to next loop iteration
                const message = currentBuffer.slice(0, currentSize);
                this.onMessage(message);
                currentBuffer = currentBuffer.slice(currentSize);
                if (currentBuffer.byteLength < 4) {
                    //not enough data to read the header. Wait for next onData
                    this.currentMessage = currentBuffer;
                    return;
                }
                const nextCurrentSize = readUint32LE(currentBuffer);
                if (nextCurrentSize <= 0)
                    throw new Error('message size wrong');
                currentSize = nextCurrentSize;
                //buffer and size has been set. consume this message in the next loop iteration
            }
        }
    }
}
exports.ResponseParser = ResponseParser;
//# sourceMappingURL=connection.js.map