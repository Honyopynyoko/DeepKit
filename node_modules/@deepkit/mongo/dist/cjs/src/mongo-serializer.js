"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.mongoSerializer = void 0;
const bson_1 = require("@deepkit/bson");
const type_1 = require("@deepkit/type");
exports.mongoSerializer = new type_1.Serializer('mongo');
exports.mongoSerializer.fromClass.register('string', type_1.compilerToString);
exports.mongoSerializer.fromClass.register('number', type_1.compilerToNumber);
exports.mongoSerializer.fromClass.register('array', (property, state) => {
    if (property.backReference || (property.parent && property.parent.backReference)) {
        //we don't serialize back references to mongodb
        state.template = '';
    }
    else {
        type_1.convertArray(property, state);
    }
});
exports.mongoSerializer.toClass.register('array', (property, state) => {
    if (property.backReference || (property.parent && property.parent.backReference)) {
        //we don't serialize back references to mongodb
        state.addSetter('undefined');
    }
    else {
        type_1.convertArray(property, state);
    }
});
exports.mongoSerializer.fromClass.register('class', (property, state) => {
    //When property is a reference we store the actual primary (as foreign key) of the referenced instance instead of the actual instance.
    //This way we implemented basically relations in the database
    const classSchema = type_1.getClassSchema(property.resolveClassType);
    if (property.isReference) {
        const classType = state.setVariable('classType', property.resolveClassType);
        const primary = classSchema.getPrimaryField();
        state.addCodeForSetter(`
            if (${state.accessor} instanceof ${classType}) {
                ${type_1.getDataConverterJS(state.setter, `${state.accessor}.${primary.name}`, primary, state.serializerCompilers, state.rootContext, state.jitStack)}
            } else {
                //we treat the input as if the user gave the primary key directly
                ${type_1.getDataConverterJS(state.setter, `${state.accessor}`, primary, state.serializerCompilers, state.rootContext, state.jitStack)}
            }
            `);
    }
    else if (property.backReference || (property.parent && property.parent.backReference)) {
        //we don't serialize back references to mongodb
        state.template = '';
    }
    else {
        const classToX = state.setVariable('classToX', state.jitStack.getOrCreate(classSchema, () => type_1.getClassToXFunction(classSchema, state.serializerCompilers.serializer, state.jitStack)));
        state.addSetter(`${classToX}.fn(${state.accessor}, _options, _stack)`);
    }
});
//this is necessary since we use in FindCommand `filter: t.any`, so uuid and objectId need to be a wrapper type so that @deepkit/bson serializes correctly
exports.mongoSerializer.fromClass.register('uuid', (property, state) => {
    state.setContext({ UUID: bson_1.UUID });
    state.addSetter(`new UUID(${state.accessor})`);
});
exports.mongoSerializer.fromClass.register('objectId', (property, state) => {
    state.setContext({ ObjectId: bson_1.ObjectId });
    state.addSetter(`new ObjectId(${state.accessor})`);
});
//# sourceMappingURL=mongo-serializer.js.map