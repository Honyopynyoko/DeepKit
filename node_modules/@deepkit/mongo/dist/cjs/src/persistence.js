"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoPersistence = void 0;
const orm_1 = require("@deepkit/orm");
const mapping_1 = require("./mapping");
const insert_1 = require("./client/command/insert");
const update_1 = require("./client/command/update");
const delete_1 = require("./client/command/delete");
const mongo_serializer_1 = require("./mongo-serializer");
const find_and_modify_1 = require("./client/command/find-and-modify");
const core_1 = require("@deepkit/core");
const find_1 = require("./client/command/find");
const bson_1 = require("@deepkit/bson");
class MongoPersistence extends orm_1.DatabasePersistence {
    constructor(client, ormSequences, session) {
        super();
        this.client = client;
        this.ormSequences = ormSequences;
        this.session = session;
    }
    release() {
    }
    async remove(classSchema, items) {
        const scopeSerializer = mongo_serializer_1.mongoSerializer.for(classSchema);
        const classState = orm_1.getClassState(classSchema);
        if (classSchema.getPrimaryFields().length === 1) {
            const pk = classSchema.getPrimaryField();
            const pkName = pk.name;
            const ids = [];
            for (const item of items) {
                const converted = scopeSerializer.partialSerialize(orm_1.getInstanceState(classState, item).getLastKnownPK());
                ids.push(converted[pkName]);
            }
            await this.client.execute(new delete_1.DeleteCommand(classSchema, { [pkName]: { $in: ids } }));
        }
        else {
            const fields = [];
            for (const item of items) {
                fields.push(scopeSerializer.partialSerialize(orm_1.getInstanceState(classState, item).getLastKnownPK()));
            }
            await this.client.execute(new delete_1.DeleteCommand(classSchema, { $or: fields }));
        }
    }
    async insert(classSchema, items) {
        const insert = [];
        const has_Id = classSchema.hasProperty('_id');
        const scopeSerializer = mongo_serializer_1.mongoSerializer.for(classSchema);
        const autoIncrement = classSchema.getAutoIncrementField();
        let autoIncrementValue = 0;
        if (autoIncrement) {
            const command = new find_and_modify_1.FindAndModifyCommand(this.ormSequences, { name: classSchema.getCollectionName(), }, { $inc: { value: items.length } });
            command.returnNew = true;
            command.fields = ['value'];
            command.upsert = true;
            const res = await this.client.execute(command);
            autoIncrementValue = res.value['value'] - items.length;
        }
        for (const item of items) {
            if (autoIncrement)
                item[autoIncrement.name] = ++autoIncrementValue;
            if (has_Id && !item['_id']) {
                item['_id'] = bson_1.ObjectId.generate();
            }
            //replaces references with the foreign key
            const converted = scopeSerializer.serialize(item);
            insert.push(converted);
        }
        await this.client.execute(new insert_1.InsertCommand(classSchema, insert));
    }
    async update(classSchema, changeSets) {
        const updates = [];
        const scopeSerializer = mongo_serializer_1.mongoSerializer.for(classSchema);
        let hasAtomic = false;
        const primaryKeyName = classSchema.getPrimaryField().name;
        const pks = [];
        const projection = {};
        projection[primaryKeyName] = 1;
        const assignReturning = {};
        for (const changeSet of changeSets) {
            if (!hasAtomic && !core_1.empty(changeSet.changes.$inc))
                hasAtomic = true;
            pks.push(changeSet.primaryKey[primaryKeyName]);
            const id = changeSet.primaryKey[primaryKeyName];
            if (!core_1.empty(changeSet.changes.$inc)) {
                for (const i in changeSet.changes.$inc) {
                    if (!changeSet.changes.$inc.hasOwnProperty(i))
                        continue;
                    if (!assignReturning[id]) {
                        assignReturning[id] = { item: changeSet.item, names: [] };
                    }
                    projection[i] = 1;
                    assignReturning[id].names.push(i);
                }
            }
            const u = {};
            if (changeSet.changes.$set && !core_1.empty(changeSet.changes.$set)) {
                u.$set = scopeSerializer.partialSerialize(changeSet.changes.$set);
            }
            if (changeSet.changes.$inc)
                u.$inc = changeSet.changes.$inc;
            if (changeSet.changes.$unset)
                u.$unset = changeSet.changes.$unset;
            updates.push({
                q: mapping_1.convertClassQueryToMongo(classSchema.classType, changeSet.primaryKey),
                u: u,
                multi: false,
            });
        }
        const res = await this.client.execute(new update_1.UpdateCommand(classSchema, updates));
        if (res > 0 && hasAtomic) {
            const returnings = await this.client.execute(new find_1.FindCommand(classSchema, { [primaryKeyName]: { $in: pks } }, projection));
            for (const returning of returnings) {
                const r = assignReturning[returning[primaryKeyName]];
                for (const name of r.names) {
                    r.item[name] = returning[name];
                }
            }
        }
    }
}
exports.MongoPersistence = MongoPersistence;
//# sourceMappingURL=persistence.js.map