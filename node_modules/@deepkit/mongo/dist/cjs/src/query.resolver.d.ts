import { DatabaseAdapter, DatabaseSession, DeleteResult, Entity, Formatter, GenericQueryResolver, PatchResult } from '@deepkit/orm';
import { Changes, ClassSchema } from '@deepkit/type';
import { MongoClient } from './client/client';
import { DEEP_SORT, MongoQueryModel } from './query.model';
export declare function getMongoFilter<T>(classSchema: ClassSchema<T>, model: MongoQueryModel<T>): any;
export declare class MongoQueryResolver<T extends Entity> extends GenericQueryResolver<T, DatabaseAdapter, MongoQueryModel<T>> {
    protected client: MongoClient;
    constructor(classSchema: ClassSchema<T>, databaseSession: DatabaseSession<DatabaseAdapter>, client: MongoClient);
    protected countSchema: ClassSchema<import("@deepkit/type").ExtractClassDefinition<{
        count: import("@deepkit/type").FieldDecoratorResult<number>;
    }>>;
    has(model: MongoQueryModel<T>): Promise<boolean>;
    protected getPrimaryKeysProjection(classSchema: ClassSchema): {
        [name: string]: 0 | 1;
    };
    protected fetchIds(queryModel: MongoQueryModel<T>, limit?: number): Promise<any[]>;
    delete(queryModel: MongoQueryModel<T>, deleteResult: DeleteResult<T>): Promise<void>;
    patch(model: MongoQueryModel<T>, changes: Changes<T>, patchResult: PatchResult<T>): Promise<void>;
    count(queryModel: MongoQueryModel<T>): Promise<number>;
    findOneOrUndefined(model: MongoQueryModel<T>): Promise<T | undefined>;
    find(model: MongoQueryModel<T>): Promise<T[]>;
    protected buildAggregationPipeline(model: MongoQueryModel<T>): any[];
    /**
     * Returns undefined when no selection limitation has happened. When non-undefined
     * the mongo driver returns a t.partial.
    */
    protected getProjection<T>(classSchema: ClassSchema, select: Set<string>): {
        [name: string]: 0 | 1;
    } | undefined;
    protected createFormatter(withIdentityMap?: boolean): Formatter;
    protected getSortFromModel<T>(modelSort?: DEEP_SORT<T>): {
        [name: string]: 1 | -1 | {
            $meta: 'textScore';
        };
    };
}
