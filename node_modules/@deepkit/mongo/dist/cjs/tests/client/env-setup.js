"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoEnv = void 0;
const globals_1 = require("@jest/globals");
const type_1 = require("@deepkit/type");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const core_1 = require("@deepkit/core");
const net_1 = require("net");
const createdEnvs = [];
globals_1.afterEach(() => {
    for (const env of createdEnvs) {
        env.close();
    }
    createdEnvs.splice(0, createdEnvs.length);
});
class MongoEnv {
    constructor() {
        this.instances = new Map();
        this.tempFolder = `/tmp/mongo-env/` + type_1.uuid();
        fs_1.mkdirSync(this.tempFolder, { recursive: true });
        createdEnvs.push(this);
    }
    close() {
        for (const p of this.instances.values()) {
            if (!p.process.killed)
                p.process.kill();
        }
        if (fs_1.existsSync(this.tempFolder)) {
            fs_1.rmdirSync(this.tempFolder, { recursive: true });
        }
    }
    getInstance(name) {
        const instance = this.instances.get(name);
        if (!instance)
            throw new Error(`No mongo instance with name ${name} found`);
        return instance;
    }
    async addReplicaSet(host, member, priority, votes) {
        const unixPath = this.getInstance(member).unixPath;
        const line = { host: unixPath, priority: priority, votes: votes };
        await this.execute(host, `rs.add(${JSON.stringify(line)})`);
    }
    async waitUntilBeingPrimary(name) {
        await this.wait(name, 'db.isMaster()', (res) => res.ismaster, 'never became primary');
    }
    async waitUntilBeingSecondary(name) {
        await this.wait(name, 'db.isMaster()', (res) => res.secondary, 'never became secondary');
    }
    async wait(name, cmd, checker, errorMessage) {
        for (let i = 0; i < 20; i++) {
            const res = await this.executeJson(name, cmd);
            if (checker(res))
                return;
            await core_1.sleep(0.3);
        }
        throw new Error(`${name}: ${errorMessage}`);
    }
    async executeJson(name, cmd) {
        const res = await this.execute(name, `JSON.stringify(${cmd})`);
        try {
            return JSON.parse(res);
        }
        catch (error) {
            console.log('Could not parse JSON: ' + res);
        }
    }
    async execute(name, cmd) {
        const instance = this.getInstance(name);
        const args = [
            '--quiet',
            '--host', instance.unixPath
        ];
        console.log('execute', name, cmd);
        const res = child_process_1.spawnSync('mongo', args, {
            input: cmd,
            encoding: 'utf8'
        });
        if (res.status !== 0) {
            console.error('command stderr:', res.stderr);
            throw new Error(`Could not execute on ${name} command: ${cmd}`);
        }
        return res.stdout;
    }
    async addMongo(name, replSet) {
        const unixPath = `${this.tempFolder}/${name}.sock`;
        const dbPath = `${this.tempFolder}/${name}.db`;
        fs_1.mkdirSync(dbPath);
        const args = [
            '--dbpath', dbPath,
            '--bind_ip', unixPath,
            '--port', '0',
        ];
        if (replSet)
            args.push('--replSet', replSet);
        console.log('execute: mongod ' + args.join(' '));
        const p = child_process_1.spawn('mongod', args, {
            stdio: 'ignore',
        });
        const instance = {
            unixPath: unixPath,
            closeRequested: false,
            process: p
        };
        this.instances.set(name, instance);
        //wait for up
        for (let i = 0; i < 10; i++) {
            const connected = await new Promise((resolve) => {
                const connection = net_1.createConnection(unixPath);
                connection.on('error', () => {
                    connection.end();
                    resolve(false);
                });
                connection.on('connect', () => {
                    connection.end();
                    resolve(true);
                });
            });
            if (connected) {
                return;
            }
            await core_1.sleep(0.3);
        }
        p.kill();
        this.instances.delete(name);
        throw new Error(`Could not boot ${name} at ${unixPath} (db=${dbPath})`);
    }
}
exports.MongoEnv = MongoEnv;
//# sourceMappingURL=env-setup.js.map