"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
require("reflect-metadata");
const type_1 = require("@deepkit/type");
const orm_1 = require("@deepkit/orm");
const entities_1 = require("./entities");
const utils_1 = require("./utils");
Error.stackTraceLimit = 100;
globals_1.test('test save undefined values', async () => {
    const session = await utils_1.createDatabase('test save undefined values');
    let Model = class Model {
        constructor(name) {
            this.name = name;
        }
    };
    __decorate([
        type_1.t.primary.mongoId,
        __metadata("design:type", String)
    ], Model.prototype, "_id", void 0);
    Model = __decorate([
        type_1.Entity('undefined-model-value'),
        __param(0, type_1.t.optional),
        __metadata("design:paramtypes", [String])
    ], Model);
    // const collection = await session.adapter.connection.getCollection(getClassSchema(Model));
    //
    // {
    //     await collection.deleteMany({});
    //     await db.persist(new Model(undefined));
    //     const mongoItem = await collection.find().toArray();
    //     expect(mongoItem[0].name).toBe(null);
    //     const marshalItem = await session.query(Model).findOne();
    //     expect(marshalItem.name).toBe(undefined);
    // }
    //
    // {
    //     await collection.deleteMany({});
    //     await db.persist(new Model('peter'));
    //     const mongoItem = await collection.find().toArray();
    //     expect(mongoItem[0].name).toBe('peter');
    // }
});
globals_1.test('query patch', async () => {
    const db = await utils_1.createDatabase('testing');
    const session = db.createSession();
    const item = new entities_1.SimpleModel('foo');
    await db.persist(item);
    const dbItem = await db.query(entities_1.SimpleModel).filter({ name: 'foo' }).findOne();
    globals_1.expect(dbItem).not.toBe(item);
    const patched = await db.query(entities_1.SimpleModel).filter({ name: 'foo' }).patchOne({ name: 'bar' });
    globals_1.expect(patched.modified).toBe(1);
    globals_1.expect(await db.query(entities_1.SimpleModel).filter({ name: 'foo' }).has()).toBe(false);
    globals_1.expect(await db.query(entities_1.SimpleModel).filter({ name: 'bar' }).has()).toBe(true);
});
globals_1.test('query filter with undefined filter', async () => {
    const db = await utils_1.createDatabase('testing');
    const item1 = new entities_1.SuperSimple();
    const item2 = new entities_1.SuperSimple();
    item2.name = 'foo';
    await db.persist(item1, item2);
    {
        const items = await db.query(entities_1.SuperSimple).find();
        globals_1.expect(items.length).toBe(2);
        globals_1.expect(await db.query(entities_1.SuperSimple).has()).toBe(true);
    }
    {
        const items = await db.query(entities_1.SuperSimple).filter({ name: undefined }).find();
        globals_1.expect(items.length).toBe(1); //only one item has name: undefined
        globals_1.expect(await db.query(entities_1.SuperSimple).filter({ name: undefined }).count()).toBe(1); //only one item has name: undefined
        globals_1.expect(await db.query(entities_1.SuperSimple).filter({ name: undefined }).has()).toBe(true);
    }
    {
        await db.query(entities_1.SuperSimple).patchMany({ name: undefined });
        globals_1.expect(await db.query(entities_1.SuperSimple).filter({ name: undefined }).count()).toBe(2);
    }
});
globals_1.test('uof sets undefined for optional field', async () => {
    const db = await utils_1.createDatabase('testing');
    const item1 = new entities_1.SuperSimple();
    item1.name = 'foo';
    await db.persist(item1);
    globals_1.expect(await db.query(entities_1.SuperSimple).filter({ name: undefined }).count()).toBe(0);
    {
        const session = db.createSession();
        const item = await session.query(entities_1.SuperSimple).findOne();
        globals_1.expect(item.name).toBe('foo');
        item.name = undefined;
        await session.commit();
        globals_1.expect(await db.query(entities_1.SuperSimple).filter({ name: undefined }).count()).toBe(1);
    }
});
globals_1.test('uow patch', async () => {
    const db = await utils_1.createDatabase('testing');
    const session = db.createSession();
    const item = new entities_1.SimpleModel('foo');
    session.add(item);
    await session.commit();
    item.name = 'bar';
    await session.commit();
    globals_1.expect(await db.query(entities_1.SimpleModel).filter({ name: 'foo' }).has()).toBe(false);
    globals_1.expect(await db.query(entities_1.SimpleModel).filter({ name: 'bar' }).has()).toBe(true);
});
globals_1.test('save model', async () => {
    const db = await utils_1.createDatabase('testing');
    const session = db.createSession();
    globals_1.expect(type_1.getEntityName(entities_1.SimpleModel)).toBe('SimpleModel');
    const instance = type_1.jsonSerializer.for(entities_1.SimpleModel).deserialize({
        name: 'myName',
    });
    globals_1.expect(instance).toBeInstanceOf(entities_1.SimpleModel);
    globals_1.expect(instance.name).toBe('myName');
    session.add(instance);
    await session.commit();
    globals_1.expect(await session.query(entities_1.SimpleModel).count()).toBe(1);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myName' }).count()).toBe(1);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'MyNameNOTEXIST' }).count()).toBe(0);
    globals_1.expect(await session.query(entities_1.SimpleModel).has()).toBe(true);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myName' }).has()).toBe(true);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myNameNOTEXIST' }).has()).toBe(false);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myName' }).findOneOrUndefined()).not.toBeUndefined();
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myNameNOTEXIST' }).findOneOrUndefined()).toBeUndefined();
    await globals_1.expect(session.query(entities_1.SimpleModel).filter({ name: 'myNameNOTEXIST' }).findOne()).rejects.toThrowError('not found');
    const found = await session.query(entities_1.SimpleModel).filter({ id: instance.id }).findOne();
    globals_1.expect(found).toBeInstanceOf(entities_1.SimpleModel);
    globals_1.expect(found.name).toBe('myName');
    globals_1.expect(found.id).toBe(instance.id);
    const list = await session.query(entities_1.SimpleModel).filter({ id: instance.id }).find();
    globals_1.expect(list[0]).toBeInstanceOf(entities_1.SimpleModel);
    globals_1.expect(list[0].name).toBe('myName');
    globals_1.expect(list[0].id).toBe(instance.id);
    const listAll = await session.query(entities_1.SimpleModel).find();
    globals_1.expect(listAll[0]).toBeInstanceOf(entities_1.SimpleModel);
    globals_1.expect(listAll[0].name).toBe('myName');
    globals_1.expect(listAll[0].id).toBe(instance.id);
    globals_1.expect((await session.query(entities_1.SimpleModel).filter({ name: 'noneExisting' }).patchOne({ name: 'myName2' })).modified).toBe(0);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ id: instance.id }).ids(true)).toEqual([instance.id]);
    globals_1.expect((await session.query(entities_1.SimpleModel).filter({ id: instance.id }).patchOne({ name: 'myName2' })).modified).toBe(1);
    {
        const found = await session.query(entities_1.SimpleModel).filter({ id: instance.id }).findOne();
        globals_1.expect(found === instance).toBe(true);
        globals_1.expect(found).toBeInstanceOf(entities_1.SimpleModel);
        globals_1.expect(found.name).toBe('myName2'); //although we get the stuff from the identityMap, those were also adjusted in GenericQuery.patch
    }
    {
        const found = await session.query(entities_1.SimpleModel).disableIdentityMap().filter({ id: instance.id }).findOne();
        globals_1.expect(found === instance).toBe(false);
        globals_1.expect(found).toBeInstanceOf(entities_1.SimpleModel);
        globals_1.expect(found.name).toBe('myName2');
    }
    instance.name = 'New Name';
    await db.persist(instance);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'MyName' }).has()).toBe(false);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'New Name' }).has()).toBe(true);
});
globals_1.test('test patchAll', async () => {
    const db = await utils_1.createDatabase('testing');
    const session = db.createSession();
    await db.persist(new entities_1.SimpleModel('myName1'));
    await db.persist(new entities_1.SimpleModel('myName2'));
    await db.persist(new entities_1.SimpleModel('peter'));
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: { $regex: /^myName?/ } }).count()).toBe(2);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: { $regex: /^peter.*/ } }).count()).toBe(1);
    await session.query(entities_1.SimpleModel).filter({ name: { $regex: /^myName?/ } }).patchMany({
        name: 'peterNew'
    });
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: { $regex: /^myName?/ } }).count()).toBe(0);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: { $regex: /^peter.*/ } }).count()).toBe(3);
    const fields = await session.query(entities_1.SimpleModel).filter({ name: 'peterNew' }).select('name').findOne();
    globals_1.expect(fields.name).toBe('peterNew');
    const fieldRows = await session.query(entities_1.SimpleModel).select('name').find();
    globals_1.expect(fieldRows.length).toBe(3);
    globals_1.expect(fieldRows[0].name).toBe('peterNew');
    globals_1.expect(fieldRows[1].name).toBe('peterNew');
    globals_1.expect(fieldRows[2].name).toBe('peter');
});
globals_1.test('test delete', async () => {
    const db = await utils_1.createDatabase('testing');
    const session = db.createSession();
    const instance1 = type_1.jsonSerializer.for(entities_1.SimpleModel).deserialize({
        name: 'myName1',
    });
    const instance2 = type_1.jsonSerializer.for(entities_1.SimpleModel).deserialize({
        name: 'myName2',
    });
    session.add(instance1);
    session.add(instance2);
    await session.commit();
    globals_1.expect(orm_1.getInstanceStateFromItem(instance1).isKnownInDatabase()).toBe(true);
    globals_1.expect(orm_1.getInstanceStateFromItem(instance2).isKnownInDatabase()).toBe(true);
    globals_1.expect(await session.query(entities_1.SimpleModel).count()).toBe(2);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myName1' }).count()).toBe(1);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myName2' }).count()).toBe(1);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myName3' }).count()).toBe(0);
    session.remove(instance1);
    await session.commit();
    globals_1.expect(orm_1.getInstanceStateFromItem(instance1).isKnownInDatabase()).toBe(false);
    globals_1.expect(await session.query(entities_1.SimpleModel).count()).toBe(1);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myName1' }).count()).toBe(0);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myName2' }).count()).toBe(1);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myName3' }).count()).toBe(0);
    session.remove(instance2);
    await session.commit();
    globals_1.expect(orm_1.getInstanceStateFromItem(instance2).isKnownInDatabase()).toBe(false);
    globals_1.expect(await session.query(entities_1.SimpleModel).count()).toBe(0);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myName1' }).count()).toBe(0);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myName2' }).count()).toBe(0);
    globals_1.expect(await session.query(entities_1.SimpleModel).filter({ name: 'myName3' }).count()).toBe(0);
    globals_1.expect(orm_1.getInstanceStateFromItem(instance1).isKnownInDatabase()).toBe(false);
    globals_1.expect(orm_1.getInstanceStateFromItem(instance2).isKnownInDatabase()).toBe(false);
    session.add(instance1);
    session.add(instance2);
    await session.commit();
    globals_1.expect(orm_1.getInstanceStateFromItem(instance1).isKnownInDatabase()).toBe(true);
    globals_1.expect(orm_1.getInstanceStateFromItem(instance2).isKnownInDatabase()).toBe(true);
    globals_1.expect(await session.query(entities_1.SimpleModel).count()).toBe(2);
    globals_1.expect((await session.query(entities_1.SimpleModel).filter({ name: { $regex: /myName[0-9]/ } }).deleteMany()).modified).toBe(2);
    globals_1.expect(await session.query(entities_1.SimpleModel).count()).toBe(0);
    globals_1.expect(orm_1.getInstanceStateFromItem(instance1).isKnownInDatabase()).toBe(false);
    session.add(instance1);
    session.add(instance2);
    await session.commit();
    globals_1.expect(await session.query(entities_1.SimpleModel).count()).toBe(2);
    await session.query(entities_1.SimpleModel).filter({ name: { $regex: /myName[0-9]/ } }).deleteOne();
    globals_1.expect(await session.query(entities_1.SimpleModel).count()).toBe(1);
    await session.query(entities_1.SimpleModel).filter({ name: { $regex: /myName[0-9]/ } }).deleteOne();
    globals_1.expect(await session.query(entities_1.SimpleModel).count()).toBe(0);
});
globals_1.test('test super simple model', async () => {
    const db = await utils_1.createDatabase('testing-simple-model');
    const session = db.createSession();
    const instance = type_1.jsonSerializer.for(entities_1.SuperSimple).deserialize({
        name: 'myName',
    });
    globals_1.expect(instance._id).toBeUndefined();
    await db.persist(instance);
    globals_1.expect(instance._id).not.toBeUndefined();
    {
        const items = await session.query(entities_1.SuperSimple).find();
        globals_1.expect(items[0]).toBeInstanceOf(entities_1.SuperSimple);
        globals_1.expect(items[0]._id).toBe(instance._id);
        globals_1.expect(items[0].name).toBe(instance.name);
    }
});
// test('test databaseName', async () => {
//     const session = await createDatabase('testing-databaseName');
//     await (await session.adapter.connection.connect()).db('testing2').dropDatabase();
//
//     @Entity('DifferentDataBase', 'differentCollection')
//     @DatabaseName('testing2')
//     class DifferentDataBase {
//         @t.primary.mongoId
//         _id?: string;
//
//         @t
//         name?: string;
//     }
//
//     const instance = jsonSerializer.for(DifferentDataBase).deserialize({
//         name: 'myName',
//     });
//
//     expect(getDatabaseName(DifferentDataBase)).toBe('testing2');
//     expect(session.adapter.connection.resolveCollectionName(getClassSchema(DifferentDataBase))).toBe('differentCollection');
//
//     expect(instance._id).toBeUndefined();
//     await db.persist(instance);
//     expect(instance._id).not.toBeUndefined();
//
//     const collection = await session.adapter.connection.getCollection(getClassSchema(DifferentDataBase));
//     expect(await collection.countDocuments({})).toBe(1);
//
//     const items = await session.query(DifferentDataBase).find();
//     expect(items[0]._id).toBe(instance._id);
//     expect(items[0].name).toBe(instance.name);
// });
globals_1.test('no id', async () => {
    const db = await utils_1.createDatabase('testing');
    let NoId = class NoId {
    };
    __decorate([
        type_1.t.mongoId,
        __metadata("design:type", String)
    ], NoId.prototype, "_id", void 0);
    __decorate([
        type_1.t,
        __metadata("design:type", String)
    ], NoId.prototype, "name", void 0);
    NoId = __decorate([
        type_1.Entity('NoId')
    ], NoId);
    const instance = type_1.jsonSerializer.for(NoId).deserialize({
        name: 'myName',
    });
    await globals_1.expect(db.persist(instance)).rejects.toThrow('has no primary field');
});
globals_1.test('second object id', async () => {
    const db = await utils_1.createDatabase('testing');
    const session = db.createSession();
    let SecondObjectId = class SecondObjectId {
        constructor() {
            this.preview = type_1.arrayBufferFrom('FooBar', 'utf8');
        }
    };
    __decorate([
        type_1.t.primary.mongoId,
        __metadata("design:type", String)
    ], SecondObjectId.prototype, "_id", void 0);
    __decorate([
        type_1.t,
        __metadata("design:type", String)
    ], SecondObjectId.prototype, "name", void 0);
    __decorate([
        type_1.t.type(ArrayBuffer),
        __metadata("design:type", ArrayBuffer)
    ], SecondObjectId.prototype, "preview", void 0);
    __decorate([
        type_1.t.mongoId,
        __metadata("design:type", String)
    ], SecondObjectId.prototype, "secondId", void 0);
    SecondObjectId = __decorate([
        type_1.Entity('SecondObjectId')
    ], SecondObjectId);
    const instance = type_1.jsonSerializer.for(SecondObjectId).deserialize({
        name: 'myName',
        secondId: '5bf4a1ccce060e0b38864c9e',
        preview: type_1.nodeBufferToArrayBuffer(Buffer.from('QmFhcg==', 'base64')), //Baar
    });
    session.add(instance);
    await session.commit();
    const dbItem = await session.query(SecondObjectId).filter({ name: 'myName' }).findOne();
    globals_1.expect(dbItem.name).toBe('myName');
    const dbItemBySecondId = await session.query(SecondObjectId).filter({ secondId: '5bf4a1ccce060e0b38864c9e' }).findOne();
    globals_1.expect(dbItemBySecondId.name).toBe('myName');
    // const collection = await session.adapter.connection.getCollection(getClassSchema(SecondObjectId));
    // const mongoItem = await collection.find().toArray();
    // expect(mongoItem.length).toBe(1);
    // expect(mongoItem[0].name).toBe('myName');
    // expect(mongoItem[0].preview).toBeInstanceOf(mongodb.Binary);
    // expect(mongoItem[0].preview.buffer.toString('utf8')).toBe('Baar');
    //
    // expect(mongoItem[0]._id).toBeInstanceOf(mongodb.ObjectID);
    // expect(mongoItem[0].secondId).toBeInstanceOf(mongodb.ObjectID);
    // expect(mongoItem[0]._id.toHexString()).toBe(instance._id);
    // expect(mongoItem[0].secondId.toHexString()).toBe(instance.secondId);
});
globals_1.test('references back', async () => {
    const db = await utils_1.createDatabase('testing-references-back');
    const session = db.createSession();
    let User = class User {
        constructor(name) {
            this.name = name;
            this.id = type_1.uuid();
            this.images = [];
        }
    };
    __decorate([
        type_1.t.uuid.primary,
        __metadata("design:type", String)
    ], User.prototype, "id", void 0);
    __decorate([
        type_1.t.array(() => Image).backReference(),
        __metadata("design:type", Array)
    ], User.prototype, "images", void 0);
    User = __decorate([
        type_1.Entity('user1'),
        __param(0, type_1.t),
        __metadata("design:paramtypes", [String])
    ], User);
    let Image = class Image {
        constructor(user, title) {
            this.user = user;
            this.title = title;
            this.id = type_1.uuid();
            if (user.images && !user.images.includes(this)) {
                user.images.push(this);
            }
        }
    };
    __decorate([
        type_1.t.uuid.primary,
        __metadata("design:type", String)
    ], Image.prototype, "id", void 0);
    Image = __decorate([
        type_1.Entity('image1'),
        __param(0, type_1.t.reference()),
        __param(1, type_1.t),
        __metadata("design:paramtypes", [User, String])
    ], Image);
    const userSchema = type_1.getClassSchema(User);
    globals_1.expect(userSchema.getProperty('images').backReference).not.toBeUndefined();
    const imageSchema = type_1.getClassSchema(Image);
    globals_1.expect(imageSchema.getProperty('user')).toBeInstanceOf(type_1.PropertySchema);
    globals_1.expect(imageSchema.getProperty('user').type).toBe('class');
    globals_1.expect(imageSchema.getProperty('user').classType).toBe(User);
    const marc = new User('marc');
    const peter = new User('peter');
    const marcel = new User('marcel');
    session.add(marc);
    session.add(peter);
    session.add(marcel);
    const image2 = new Image(marc, 'image2');
    session.add(new Image(marc, 'image1'));
    session.add(image2);
    session.add(new Image(marc, 'image3'));
    session.add(new Image(peter, 'image1'));
    await session.commit();
    {
        globals_1.expect(orm_1.getInstanceStateFromItem(marc).isFromDatabase()).toBe(false);
        globals_1.expect(orm_1.getInstanceStateFromItem(image2).isFromDatabase()).toBe(false);
        const marcFromDb = await session.query(User).joinWith('images').filter({ name: 'marc' }).findOne();
        globals_1.expect(marcFromDb === marc).toBe(true);
        globals_1.expect(orm_1.getInstanceStateFromItem(marcFromDb).isFromDatabase()).toBe(false);
        //make sure that it returns the image2 we already have
        const imageDb = await session.query(Image).joinWith('user').filter({ title: 'image2' }).findOne();
        globals_1.expect(orm_1.getInstanceStateFromItem(imageDb).isFromDatabase()).toBe(false);
        globals_1.expect(imageDb).toBe(image2);
        globals_1.expect(imageDb.title).toBe('image2');
        globals_1.expect(imageDb.user).toBeInstanceOf(User);
        //reference is still correct and not overwritten
        globals_1.expect(imageDb.user.name).toBe('marc');
        globals_1.expect(imageDb.user).toBe(marc);
        const marcFromDb2 = await session.query(User).joinWith('images').filter({ name: 'marc' }).findOne();
        globals_1.expect(marcFromDb2 === marc).toBe(true);
    }
    {
        const marcFromDb = await session.query(User).disableIdentityMap().filter({ name: 'marc' }).findOne();
        globals_1.expect(orm_1.getInstanceStateFromItem(marcFromDb).isFromDatabase()).toBe(true);
        globals_1.expect(() => {
            marcFromDb.images;
        }).toThrow('images was not populated');
        globals_1.expect(typeof marcFromDb.id).toBe('string');
        globals_1.expect(marcFromDb.name).toBe('marc');
        const plain = type_1.jsonSerializer.for(User).serialize(marcFromDb);
        globals_1.expect(typeof plain.id).toBe('string');
        globals_1.expect(plain.name).toBe('marc');
        globals_1.expect(plain.images).toBe(null);
    }
    {
        const marcFromDb = await session.query(User).joinWith('images').filter({ name: 'marc' }).findOne();
        globals_1.expect(marcFromDb === marc).toBe(true);
        globals_1.expect(orm_1.getInstanceStateFromItem(marcFromDb).isFromDatabase()).toBe(false);
        globals_1.expect(marcFromDb.name).toBe('marc');
        globals_1.expect(marcFromDb.images.length).toBe(3);
        globals_1.expect(marcFromDb.images[0]).toBeInstanceOf(Image);
        globals_1.expect(marcFromDb.images[1]).toBeInstanceOf(Image);
        globals_1.expect(marcFromDb.images[2]).toBeInstanceOf(Image);
    }
    {
        const image2 = await session.query(Image).disableIdentityMap().filter({ title: 'image2' }).findOne();
        globals_1.expect(() => {
            image2.user.name;
        }).toThrow(`Can not access User.name since class was not completely hydrated`);
        image2.user.name = 'changed';
        globals_1.expect(image2.user.name).toBe('changed');
        globals_1.expect(image2.title).toBe('image2');
        //writing is allowed again
        const mowla = new User('mowla');
        image2.user = mowla;
        image2.user.name = 'mowla2';
        globals_1.expect(image2.user).toBe(mowla);
    }
    {
        const image2 = await session.query(Image).joinWith('user').filter({ title: 'image2' }).findOne();
        globals_1.expect(image2.title).toBe('image2');
        globals_1.expect(image2.user).toBeInstanceOf(User);
        globals_1.expect(image2.user.name).toBe('marc');
    }
});
globals_1.test('test identityMap', async () => {
    const db = await utils_1.createDatabase('testing');
    const session = db.createSession();
    const item = new entities_1.SimpleModel('myName1');
    session.add(item);
    await session.commit();
    const pkHash = orm_1.getInstanceStateFromItem(item).getLastKnownPKHash();
    const idItem = session.identityMap.getByHash(type_1.getClassSchema(entities_1.SimpleModel), pkHash);
    globals_1.expect(idItem).toBe(item);
    const dbItem = await session.query(entities_1.SimpleModel).filter({ name: 'myName1' }).findOne();
    globals_1.expect(dbItem === item).toBe(true);
    globals_1.expect(dbItem).toBe(item);
});
//# sourceMappingURL=mongo.spec.js.map