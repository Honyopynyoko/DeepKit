/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { MongoConnectionPool } from './connection';
import { isErrorRetryableRead, isErrorRetryableWrite, MongoError } from './error';
import { sleep } from '@deepkit/core';
import { DropDatabaseCommand } from './command/drop-database';
import { MongoClientConfig } from './config';
export class MongoClient {
    constructor(connectionString) {
        this.inCloseProcedure = false;
        this.config = new MongoClientConfig(connectionString);
        this.connectionPool = new MongoConnectionPool(this.config);
    }
    resolveCollectionName(schema) {
        return this.config.resolveCollectionName(schema);
    }
    async connect() {
        await this.connectionPool.connect();
    }
    close() {
        this.inCloseProcedure = true;
        this.connectionPool.close();
    }
    async dropDatabase(dbName) {
        await this.execute(new DropDatabaseCommand(dbName));
    }
    /**
     * Returns an existing or new connection, that needs to be released once done using it.
     */
    getConnection(request = {}) {
        return this.connectionPool.getConnection(request);
    }
    async execute(command) {
        const maxRetries = 10;
        const request = { writable: command.needsWritableHost() };
        await this.connectionPool.ensureHostsConnected(true);
        for (let i = 1; i <= maxRetries; i++) {
            const connection = await this.connectionPool.getConnection(request);
            try {
                return await connection.execute(command);
            }
            catch (error) {
                if (command.needsWritableHost()) {
                    if (!isErrorRetryableWrite(error))
                        throw error;
                }
                else {
                    if (!isErrorRetryableRead(error))
                        throw error;
                }
                if (i == maxRetries) {
                    throw error;
                }
                await sleep(0.25);
            }
            finally {
                connection.release();
            }
        }
        throw new MongoError(`Could not execute command since no connection found: ${command}`);
    }
}
//# sourceMappingURL=client.js.map