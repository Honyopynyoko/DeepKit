/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { DatabasePersistence, getClassState, getInstanceState } from '@deepkit/orm';
import { convertClassQueryToMongo } from './mapping';
import { InsertCommand } from './client/command/insert';
import { UpdateCommand } from './client/command/update';
import { DeleteCommand } from './client/command/delete';
import { mongoSerializer } from './mongo-serializer';
import { FindAndModifyCommand } from './client/command/find-and-modify';
import { empty } from '@deepkit/core';
import { FindCommand } from './client/command/find';
import { ObjectId } from '@deepkit/bson';
export class MongoPersistence extends DatabasePersistence {
    constructor(client, ormSequences, session) {
        super();
        this.client = client;
        this.ormSequences = ormSequences;
        this.session = session;
    }
    release() {
    }
    async remove(classSchema, items) {
        const scopeSerializer = mongoSerializer.for(classSchema);
        const classState = getClassState(classSchema);
        if (classSchema.getPrimaryFields().length === 1) {
            const pk = classSchema.getPrimaryField();
            const pkName = pk.name;
            const ids = [];
            for (const item of items) {
                const converted = scopeSerializer.partialSerialize(getInstanceState(classState, item).getLastKnownPK());
                ids.push(converted[pkName]);
            }
            await this.client.execute(new DeleteCommand(classSchema, { [pkName]: { $in: ids } }));
        }
        else {
            const fields = [];
            for (const item of items) {
                fields.push(scopeSerializer.partialSerialize(getInstanceState(classState, item).getLastKnownPK()));
            }
            await this.client.execute(new DeleteCommand(classSchema, { $or: fields }));
        }
    }
    async insert(classSchema, items) {
        const insert = [];
        const has_Id = classSchema.hasProperty('_id');
        const scopeSerializer = mongoSerializer.for(classSchema);
        const autoIncrement = classSchema.getAutoIncrementField();
        let autoIncrementValue = 0;
        if (autoIncrement) {
            const command = new FindAndModifyCommand(this.ormSequences, { name: classSchema.getCollectionName(), }, { $inc: { value: items.length } });
            command.returnNew = true;
            command.fields = ['value'];
            command.upsert = true;
            const res = await this.client.execute(command);
            autoIncrementValue = res.value['value'] - items.length;
        }
        for (const item of items) {
            if (autoIncrement)
                item[autoIncrement.name] = ++autoIncrementValue;
            if (has_Id && !item['_id']) {
                item['_id'] = ObjectId.generate();
            }
            //replaces references with the foreign key
            const converted = scopeSerializer.serialize(item);
            insert.push(converted);
        }
        await this.client.execute(new InsertCommand(classSchema, insert));
    }
    async update(classSchema, changeSets) {
        const updates = [];
        const scopeSerializer = mongoSerializer.for(classSchema);
        let hasAtomic = false;
        const primaryKeyName = classSchema.getPrimaryField().name;
        const pks = [];
        const projection = {};
        projection[primaryKeyName] = 1;
        const assignReturning = {};
        for (const changeSet of changeSets) {
            if (!hasAtomic && !empty(changeSet.changes.$inc))
                hasAtomic = true;
            pks.push(changeSet.primaryKey[primaryKeyName]);
            const id = changeSet.primaryKey[primaryKeyName];
            if (!empty(changeSet.changes.$inc)) {
                for (const i in changeSet.changes.$inc) {
                    if (!changeSet.changes.$inc.hasOwnProperty(i))
                        continue;
                    if (!assignReturning[id]) {
                        assignReturning[id] = { item: changeSet.item, names: [] };
                    }
                    projection[i] = 1;
                    assignReturning[id].names.push(i);
                }
            }
            const u = {};
            if (changeSet.changes.$set && !empty(changeSet.changes.$set)) {
                u.$set = scopeSerializer.partialSerialize(changeSet.changes.$set);
            }
            if (changeSet.changes.$inc)
                u.$inc = changeSet.changes.$inc;
            if (changeSet.changes.$unset)
                u.$unset = changeSet.changes.$unset;
            updates.push({
                q: convertClassQueryToMongo(classSchema.classType, changeSet.primaryKey),
                u: u,
                multi: false,
            });
        }
        const res = await this.client.execute(new UpdateCommand(classSchema, updates));
        if (res > 0 && hasAtomic) {
            const returnings = await this.client.execute(new FindCommand(classSchema, { [primaryKeyName]: { $in: pks } }, projection));
            for (const returning of returnings) {
                const r = assignReturning[returning[primaryKeyName]];
                for (const name of r.names) {
                    r.item[name] = returning[name];
                }
            }
        }
    }
}
//# sourceMappingURL=persistence.js.map