import { afterEach } from '@jest/globals';
import { uuid } from '@deepkit/type';
import { spawn, spawnSync } from 'child_process';
import { existsSync, mkdirSync, rmdirSync } from 'fs';
import { sleep } from '@deepkit/core';
import { createConnection } from 'net';
const createdEnvs = [];
afterEach(() => {
    for (const env of createdEnvs) {
        env.close();
    }
    createdEnvs.splice(0, createdEnvs.length);
});
export class MongoEnv {
    constructor() {
        this.instances = new Map();
        this.tempFolder = `/tmp/mongo-env/` + uuid();
        mkdirSync(this.tempFolder, { recursive: true });
        createdEnvs.push(this);
    }
    close() {
        for (const p of this.instances.values()) {
            if (!p.process.killed)
                p.process.kill();
        }
        if (existsSync(this.tempFolder)) {
            rmdirSync(this.tempFolder, { recursive: true });
        }
    }
    getInstance(name) {
        const instance = this.instances.get(name);
        if (!instance)
            throw new Error(`No mongo instance with name ${name} found`);
        return instance;
    }
    async addReplicaSet(host, member, priority, votes) {
        const unixPath = this.getInstance(member).unixPath;
        const line = { host: unixPath, priority: priority, votes: votes };
        await this.execute(host, `rs.add(${JSON.stringify(line)})`);
    }
    async waitUntilBeingPrimary(name) {
        await this.wait(name, 'db.isMaster()', (res) => res.ismaster, 'never became primary');
    }
    async waitUntilBeingSecondary(name) {
        await this.wait(name, 'db.isMaster()', (res) => res.secondary, 'never became secondary');
    }
    async wait(name, cmd, checker, errorMessage) {
        for (let i = 0; i < 20; i++) {
            const res = await this.executeJson(name, cmd);
            if (checker(res))
                return;
            await sleep(0.3);
        }
        throw new Error(`${name}: ${errorMessage}`);
    }
    async executeJson(name, cmd) {
        const res = await this.execute(name, `JSON.stringify(${cmd})`);
        try {
            return JSON.parse(res);
        }
        catch (error) {
            console.log('Could not parse JSON: ' + res);
        }
    }
    async execute(name, cmd) {
        const instance = this.getInstance(name);
        const args = [
            '--quiet',
            '--host', instance.unixPath
        ];
        console.log('execute', name, cmd);
        const res = spawnSync('mongo', args, {
            input: cmd,
            encoding: 'utf8'
        });
        if (res.status !== 0) {
            console.error('command stderr:', res.stderr);
            throw new Error(`Could not execute on ${name} command: ${cmd}`);
        }
        return res.stdout;
    }
    async addMongo(name, replSet) {
        const unixPath = `${this.tempFolder}/${name}.sock`;
        const dbPath = `${this.tempFolder}/${name}.db`;
        mkdirSync(dbPath);
        const args = [
            '--dbpath', dbPath,
            '--bind_ip', unixPath,
            '--port', '0',
        ];
        if (replSet)
            args.push('--replSet', replSet);
        console.log('execute: mongod ' + args.join(' '));
        const p = spawn('mongod', args, {
            stdio: 'ignore',
        });
        const instance = {
            unixPath: unixPath,
            closeRequested: false,
            process: p
        };
        this.instances.set(name, instance);
        //wait for up
        for (let i = 0; i < 10; i++) {
            const connected = await new Promise((resolve) => {
                const connection = createConnection(unixPath);
                connection.on('error', () => {
                    connection.end();
                    resolve(false);
                });
                connection.on('connect', () => {
                    connection.end();
                    resolve(true);
                });
            });
            if (connected) {
                return;
            }
            await sleep(0.3);
        }
        p.kill();
        this.instances.delete(name);
        throw new Error(`Could not boot ${name} at ${unixPath} (db=${dbPath})`);
    }
}
//# sourceMappingURL=env-setup.js.map