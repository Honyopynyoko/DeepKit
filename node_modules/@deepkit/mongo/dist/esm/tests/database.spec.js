var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { expect, test } from '@jest/globals';
import 'reflect-metadata';
import { Database } from "@deepkit/orm";
import { MongoDatabaseAdapter } from "../src/adapter";
import { Entity, t } from "@deepkit/type";
test('simple', async () => {
    let Test = class Test {
        constructor(name) {
            this.name = name;
        }
    };
    __decorate([
        t.primary.mongoId,
        __metadata("design:type", String)
    ], Test.prototype, "_id", void 0);
    Test = __decorate([
        Entity('asd'),
        __param(0, t),
        __metadata("design:paramtypes", [String])
    ], Test);
    const database = new Database(new MongoDatabaseAdapter('mongodb://localhost/test'));
    await database.query(Test).deleteMany();
    {
        const item = new Test('asd');
        await database.persist(item);
    }
    {
        expect(await database.query(Test).filter({ name: { $regex: /asd/ } }).has()).toBe(true);
        const item = await database.query(Test).filter({ name: 'asd' }).findOne();
        expect(item).toBeInstanceOf(Test);
        expect(item.name).toBe('asd');
    }
    database.disconnect();
});
test('unit of work', async () => {
    let Test = class Test {
        constructor(name) {
            this.name = name;
        }
    };
    __decorate([
        t.primary.mongoId,
        __metadata("design:type", String)
    ], Test.prototype, "_id", void 0);
    Test = __decorate([
        Entity('asd2'),
        __param(0, t),
        __metadata("design:paramtypes", [String])
    ], Test);
    const database = new Database(new MongoDatabaseAdapter('mongodb://localhost/test'));
    await database.query(Test).deleteMany();
    const session = database.createSession();
    const item = new Test('asd');
    session.add(item);
    await session.commit();
    {
        expect(await session.query(Test).filter({ name: 'asd' }).has()).toBe(true);
        const item = await session.query(Test).filter({ name: 'asd' }).findOne();
        expect(item).toBeInstanceOf(Test);
        expect(item.name).toBe('asd');
    }
    await session.remove(item);
    await session.commit();
    expect(await session.query(Test).filter({ name: 'asd' }).has()).toBe(false);
    database.disconnect();
});
test('repository', async () => {
    let Test = class Test {
        constructor(name) {
            this.name = name;
        }
    };
    __decorate([
        t.primary.mongoId,
        __metadata("design:type", String)
    ], Test.prototype, "_id", void 0);
    Test = __decorate([
        Entity('asd3'),
        __param(0, t),
        __metadata("design:paramtypes", [String])
    ], Test);
    const database = new Database(new MongoDatabaseAdapter('mongodb://localhost/test'));
    await database.query(Test).deleteMany();
    const item = new Test('asda');
    await database.persist(item);
    class TestRepository {
        constructor(database) {
            this.database = database;
        }
        async findById(id) {
            return this.database.query(Test).filter({ _id: id }).findOne();
        }
    }
    const repo = new TestRepository(database);
    const itemFromRepo = await repo.findById(item._id);
    expect(itemFromRepo).toBeInstanceOf(Test);
    expect(itemFromRepo._id).toBe(item._id);
    database.disconnect();
});
test('session', async () => {
    let Test = class Test {
        constructor(name) {
            this.name = name;
        }
    };
    __decorate([
        t.primary.mongoId,
        __metadata("design:type", String)
    ], Test.prototype, "_id", void 0);
    Test = __decorate([
        Entity('asd4'),
        __param(0, t),
        __metadata("design:paramtypes", [String])
    ], Test);
    const database = new Database(new MongoDatabaseAdapter('mongodb://localhost/test'));
    await database.query(Test).deleteMany();
    await database.session(async (session) => {
        const item = new Test('asd');
        session.add(item);
    });
    {
        expect(await database.query(Test).filter({ name: 'asd' }).has()).toBe(true);
        const item = await database.query(Test).filter({ name: 'asd' }).findOne();
        expect(item).toBeInstanceOf(Test);
        expect(item.name).toBe('asd');
    }
    database.disconnect();
});
//# sourceMappingURL=database.spec.js.map