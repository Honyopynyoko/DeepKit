var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { expect, test } from '@jest/globals';
import 'reflect-metadata';
import { Entity, t } from '@deepkit/type';
import { createDatabase } from './utils';
import { getInstanceStateFromItem } from '@deepkit/orm';
let Image = class Image {
    constructor(id, path) {
        this.id = id;
        this.path = path;
        this.users = [];
        this.usersForPictures = [];
    }
};
__decorate([
    t.array(() => User).backReference(),
    __metadata("design:type", Array)
], Image.prototype, "users", void 0);
__decorate([
    t.array(() => User).backReference({ via: () => UserPicture }),
    __metadata("design:type", Array)
], Image.prototype, "usersForPictures", void 0);
Image = __decorate([
    Entity('image'),
    __param(0, t.primary),
    __param(1, t),
    __metadata("design:paramtypes", [Number, String])
], Image);
let User = class User {
    constructor(id, username) {
        this.id = id;
        this.username = username;
    }
};
__decorate([
    t.reference().optional,
    __metadata("design:type", Image)
], User.prototype, "profileImage", void 0);
__decorate([
    t.array(Image).optional.backReference({ via: () => UserPicture }),
    __metadata("design:type", Array)
], User.prototype, "pictures", void 0);
User = __decorate([
    Entity('user'),
    __param(0, t.primary),
    __param(1, t),
    __metadata("design:paramtypes", [Number, String])
], User);
let UserPicture = class UserPicture {
    constructor(user, image) {
    }
};
__decorate([
    t,
    __metadata("design:type", Number)
], UserPicture.prototype, "id", void 0);
UserPicture = __decorate([
    Entity('userImage'),
    __param(0, t.reference()),
    __param(1, t.reference()),
    __metadata("design:paramtypes", [User,
        Image])
], UserPicture);
test('test back reference', async () => {
    const db = await createDatabase('reference a');
    const session = db.createSession();
    const image1 = new Image(1, 'peter.png');
    const peter = new User(2, 'peter');
    peter.profileImage = image1;
    session.add(peter);
    await session.commit();
    expect(getInstanceStateFromItem(peter).isKnownInDatabase()).toBe(true);
    expect(getInstanceStateFromItem(image1).isKnownInDatabase()).toBe(true);
    {
        const images = await session.query(Image).disableIdentityMap().find();
        expect(images[0].id).toBe(1);
        expect(() => images[0].users[0].id).toThrow('Reference Image.users was not populated');
    }
    {
        const images = await session.query(Image).disableIdentityMap().joinWith('users').find();
        expect(images[0].id).toBe(1);
        expect(images[0].users[0].id).toBe(2);
        expect(images[0].users[0].username).toBe('peter');
    }
    {
        session.identityMap.clear();
        const images = await session.query(Image).find();
        expect(images[0].id).toBe(1);
        expect(() => images[0].users[0].id).toThrow('Reference Image.users was not populated');
    }
    {
        session.identityMap.clear();
        const images = await session.query(Image).joinWith('users').find();
        expect(images[0].id).toBe(1);
        expect(images[0].users[0].id).toBe(2);
        expect(images[0].users[0].username).toBe('peter');
    }
});
test('test unlink reference', async () => {
    const db = await createDatabase('reference a');
    const session = db.createSession();
    const image1 = new Image(1, 'peter.png');
    const peter = new User(2, 'peter');
    peter.profileImage = image1;
    session.add(peter);
    await session.commit();
    {
        session.identityMap.clear();
        const users = await session.query(User).find();
        expect(users[0].id).toBe(2);
        expect(users[0].profileImage.id).toBe(1);
    }
    {
        session.identityMap.clear();
        const user = await session.query(User).findOne();
        user.profileImage = undefined;
        //user is managed, so no need to call add
        await session.commit();
        expect(user.profileImage).toBe(undefined);
        {
            session.identityMap.clear();
            const user = await session.query(User).findOne();
            expect(user.profileImage).toBe(undefined);
        }
    }
});
//# sourceMappingURL=references.spec.js.map