"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatabaseRegistry = void 0;
const core_1 = require("@deepkit/core");
const type_1 = require("@deepkit/type");
const database_1 = require("./database");
const path_1 = require("path");
/**
 * Class to register a new database and resolve a schema/type to a database.
 */
class DatabaseRegistry {
    constructor(scopedContext, databaseTypes = [], migrateOnStartup = false) {
        this.scopedContext = scopedContext;
        this.databaseTypes = databaseTypes;
        this.migrateOnStartup = migrateOnStartup;
        this.databaseNameMap = new Map();
        this.databases = [];
        this.databaseMap = new Map();
        this.databaseOptions = new Map();
        this.initialized = false;
        if (!scopedContext)
            throw new Error('no scopedContext');
    }
    setMigrateOnStartup(v) {
        this.migrateOnStartup = v;
    }
    /**
     * Reads database from a path. Imports the given paths
     * and looks for instantiated Database classes. All instantiated Database classes will be returned.
     *
     * This is an alternative way to find Database and entities compared to
     * a config file driven way.
     */
    readDatabase(paths) {
        database_1.Database.registry = [];
        //we dont want to allow bundles to bundle ts-node
        const n = 'ts' + '-node';
        const r = require;
        r(n).register({
            compilerOptions: {
                experimentalDecorators: true
            }
        });
        for (const path of paths) {
            require(path_1.isAbsolute(path) ? path : path_1.join(process.cwd(), path));
        }
        for (const db of database_1.Database.registry) {
            this.databases.push(db);
            const classType = core_1.getClassTypeFromInstance(db);
            this.databaseNameMap.set(db.name, db);
            this.databaseMap.set(classType, db);
            this.databaseTypes.push(classType);
        }
    }
    onShutDown() {
        for (const database of this.databaseMap.values()) {
            database.disconnect();
        }
    }
    addDatabase(database, options = {}) {
        this.databaseTypes.push(database);
        this.databaseOptions.set(database, options);
    }
    getDatabaseTypes() {
        return this.databaseTypes;
    }
    isMigrateOnStartup(database) {
        const options = this.databaseOptions.get(database);
        if (options && options.migrateOnStartup !== undefined)
            return options.migrateOnStartup;
        return this.migrateOnStartup;
    }
    init() {
        if (this.initialized)
            return;
        for (const databaseType of this.databaseTypes) {
            if (this.databaseMap.has(databaseType))
                continue;
            const database = this.scopedContext.get(databaseType);
            for (const classSchema of database.entities) {
                classSchema.data['orm.database'] = database;
            }
            this.databaseNameMap.set(database.name, database);
            this.databaseMap.set(databaseType, database);
            this.databases.push(database);
        }
        this.initialized = true;
    }
    getDatabaseForEntity(entity) {
        const schema = type_1.getClassSchema(entity);
        const database = schema.data['orm.database'];
        if (!database)
            throw new Error(`Class ${schema.getClassName()} is not assigned to a database`);
        return database;
    }
    getDatabases() {
        this.init();
        return this.databases;
    }
    getDatabase(classType) {
        this.init();
        return this.databaseMap.get(classType);
    }
    getDatabaseByName(name) {
        this.init();
        return this.databaseNameMap.get(name);
    }
}
exports.DatabaseRegistry = DatabaseRegistry;
//# sourceMappingURL=database-registry.js.map