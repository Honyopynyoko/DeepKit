import { AbstractClassType, ClassType, CustomError } from '@deepkit/core';
import { ClassSchema, PrimaryKeyFields } from '@deepkit/type';
import { DatabaseAdapter } from './database-adapter';
import { DatabaseSession } from './database-session';
import { QueryDatabaseEmitter, UnitOfWorkDatabaseEmitter } from './event';
import { DatabaseLogger } from './logger';
import { Query } from './query';
import { Entity } from './type';
import { VirtualForeignKeyConstraint } from './virtual-foreign-key-constraint';
import { Stopwatch } from '@deepkit/stopwatch';
/**
 * Hydrates not completely populated item and makes it completely accessible.
 */
export declare function hydrateEntity<T>(item: T): Promise<void>;
export declare class DatabaseError extends CustomError {
}
/**
 * Type guard for a specialised database adapter. Can be used to
 * use special methods from an adapter on a generic Database object.
 *
 * ```
 * const database = new Database(...); //we don't know the adapter
 *
 * if (isDatabaseOf(database, SQLDatabaseAdapter)) {
 *     // cool, we can use `where(sql)` which is only available for SQLDatabaseAdapter
 *     database.query(User).where(sql`id > 2`).find();
 *
 *     //or raw SQL queries
 *     database.raw(sql`SELECT count(*) FROM ${User}`).find();
 * }
 * ```
 */
export declare function isDatabaseOf<T extends DatabaseAdapter>(database: Database<any>, adapterClassType: AbstractClassType<T>): database is Database<T>;
/**
 * Database abstraction. Use createSession() to create a work session with transaction support.
 *
 * Using this class in your code indicates that you can work with common and most basic database semantics.
 * This means that you can use the deepkit/type database API that works across a variety of database engines
 * like MySQL, PostgreSQL, SQLite, and MongoDB.
 */
export declare class Database<ADAPTER extends DatabaseAdapter = DatabaseAdapter> {
    readonly adapter: ADAPTER;
    name: string;
    /**
     * If set, all created Database instances are registered here.
     */
    static registry?: Database[];
    /**
     * The entity schema registry.
     */
    readonly entities: Set<ClassSchema<any>>;
    /**
     * Event API for DatabaseQuery events.
     */
    readonly queryEvents: QueryDatabaseEmitter;
    /**
     * Event API for the unit of work.
     */
    readonly unitOfWorkEvents: UnitOfWorkDatabaseEmitter;
    stopwatch: Stopwatch;
    /**
     * Creates a new DatabaseQuery instance which can be used to query data.
     *  - Entity instances ARE NOT cached or tracked.
     *
     * Use a DatabaseSession (createSession()) with its query() in your workflow to enable
     * identity map.
     *
     * ```typescript
     * const session = database.createSession();
     *
     * const item = await session.query(MyType).findOne();
     * item.name = 'changed';
     * await session.commit(); //only necessary when you changed items received by this session
     * ```
     */
    readonly query: ReturnType<this['adapter']['queryFactory']>['createQuery'];
    readonly raw: ReturnType<this['adapter']['rawFactory']>['create'];
    protected virtualForeignKeyConstraint: VirtualForeignKeyConstraint;
    logger: DatabaseLogger;
    constructor(adapter: ADAPTER, schemas?: (ClassType | ClassSchema)[]);
    static createClass<T extends DatabaseAdapter>(name: string, adapter: T, schemas?: (ClassType | ClassSchema)[]): ClassType<Database<T>>;
    /**
     * Tells the adapter to disconnect. It reconnects automatically when necessary.
     */
    disconnect(force?: boolean): void;
    /**
     * Creates a new database session. This is the preferred way of working with the database
     * and to enjoy all ORM features. Call DatabaseSession.commit to persist changes all at once
     * in the most performant way possible. The creation of a DatabaseSession is very low cost,
     * so creating many or often is the preferred way.
     **
     * All entity instances fetched/stored during this session are cached and tracked automatically.
     *
     * Note: This is not equal to a database transaction. A session means a work block
     * where you need to fetch, change, and save entity instances. Every instance fetched
     * stays in the identity-map of that session and keeps it alive, so make sure
     * to not keep a session for too long (especially not cross requests).

     * @example
     * ```typescript
     * const database = new Database(...);
     *
     * express.on('request', async (req) => {
     *     const session = database.createSession();
     *     const user = session.query(User).filter({id: req.params.id}).findOne();
     *     user.name = req.params.name;
     *     await session.commit(); //session will be garbage collected and should NOT be stored for the next request
     * });
     * ```
     */
    createSession(): DatabaseSession<ADAPTER>;
    /**
     * Executes given callback in a new session and automatically commits it when executed successfully.
     * Automatically does a rollback when callback throws an error. This has the same semantics as `createSession`.
     */
    session<T>(worker: (session: DatabaseSession<ADAPTER>) => Promise<T>): Promise<T>;
    /**
     * Creates a new reference.
     *
     * If you work with a DatabaseSession, use DatabaseSession.getReference instead to
     * maintain object identity.
     *
     * ```
     * const user = database.getReference(User, 1);
     * ```
     */
    getReference<T>(classType: ClassType<T> | ClassSchema<T>, primaryKey: any | PrimaryKeyFields<T>): T;
    /**
     * Registers a new entity to this database.
     * This is mainly used for db migration utilities and active record.
     * If you want to use active record, you have to assign your entities first to a database using this method.
     */
    registerEntity(...entities: (ClassType | ClassSchema)[]): void;
    getEntity(name: string): ClassSchema;
    /**
     * Makes sure the schemas types, indices, uniques, etc are reflected in the database.
     *
     * WARNING: DON'T USE THIS IN PRODUCTION AS THIS CAN CAUSE EASILY DATA LOSS.
     * SEE THE MIGRATION DOCUMENTATION TO UNDERSTAND ITS IMPLICATIONS.
     */
    migrate(): Promise<void>;
    /**
     * Simple direct persist. The persistence layer (batch) inserts or updates the record
     * depending on the state of the given items. This is different to createSession()+add() in a way
     * that `DatabaseSession.add` adds the given items to the queue (which is then committed using commit())
     * while this `database.persist` just simply inserts/updates the given items immediately,
     * completely bypassing the advantages of the unit of work for multiple items.
     *
     * You should prefer the add/remove and commit() workflow to fully utilizing database performance.
     */
    persist(...items: Entity[]): Promise<void>;
    /**
     * Simple direct remove. The persistence layer (batch) removes all given items.
     * This is different to createSession()+remove() in a way that `DatabaseSession.remove` adds the given items to the queue
     * (which is then committed using commit()) while this `database.remove` just simply removes the given items immediately,
     * completely bypassing the advantages of the unit of work for multiple items.
     *
     * You should prefer the add/remove and commit() workflow to fully utilizing database performance.
     */
    remove(...items: Entity[]): Promise<void>;
}
export interface ActiveRecordClassType {
    new (...args: any[]): ActiveRecord;
    getDatabase(): Database<any>;
    registerDatabase(database: Database<any>): void;
    query(): any;
}
export declare function isActiveRecordClassType(entity: any): entity is ActiveRecordClassType;
export declare class ActiveRecord {
    constructor(...args: any[]);
    static getDatabase(): Database<any>;
    static registerDatabase(database: Database<any>): void;
    save(): Promise<void>;
    remove(): Promise<void>;
    static query<T extends typeof ActiveRecord>(this: T): Query<InstanceType<T>>;
    static reference<T extends typeof ActiveRecord>(this: T, primaryKey: any | PrimaryKeyFields<InstanceType<T>>): InstanceType<T>;
}
