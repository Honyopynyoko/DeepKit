"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryDatabaseEmitter = exports.QueryDatabasePatchEvent = exports.QueryDatabaseDeleteEvent = exports.QueryDatabaseEvent = exports.UnitOfWorkDatabaseEmitter = exports.UnitOfWorkUpdateEvent = exports.UnitOfWorkEvent = exports.UnitOfWorkCommitEvent = void 0;
const core_1 = require("@deepkit/core");
class UnitOfWorkCommitEvent extends core_1.AsyncEmitterEvent {
    constructor(databaseSession) {
        super();
        this.databaseSession = databaseSession;
    }
}
exports.UnitOfWorkCommitEvent = UnitOfWorkCommitEvent;
class UnitOfWorkEvent extends core_1.AsyncEmitterEvent {
    constructor(classSchema, databaseSession, items) {
        super();
        this.classSchema = classSchema;
        this.databaseSession = databaseSession;
        this.items = items;
    }
    isSchemaOf(classTypeOrSchema) {
        return this.classSchema.isSchemaOf(classTypeOrSchema);
    }
    getPrimaryKeys() {
        const ids = [];
        const primaryKeyField = this.classSchema.getPrimaryFieldName();
        for (const item of this.items) {
            ids.push(item[primaryKeyField]);
        }
        return ids;
    }
}
exports.UnitOfWorkEvent = UnitOfWorkEvent;
class UnitOfWorkUpdateEvent extends core_1.AsyncEmitterEvent {
    constructor(classSchema, databaseSession, changeSets) {
        super();
        this.classSchema = classSchema;
        this.databaseSession = databaseSession;
        this.changeSets = changeSets;
    }
    isSchemaOf(classTypeOrSchema) {
        return this.classSchema.isSchemaOf(classTypeOrSchema);
    }
}
exports.UnitOfWorkUpdateEvent = UnitOfWorkUpdateEvent;
class UnitOfWorkDatabaseEmitter {
    constructor(parent) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.parent = parent;
        this.onUpdatePre = new core_1.AsyncEventEmitter((_a = this.parent) === null || _a === void 0 ? void 0 : _a.onUpdatePre);
        this.onUpdatePost = new core_1.AsyncEventEmitter((_b = this.parent) === null || _b === void 0 ? void 0 : _b.onUpdatePost);
        this.onInsertPre = new core_1.AsyncEventEmitter((_c = this.parent) === null || _c === void 0 ? void 0 : _c.onInsertPre);
        this.onInsertPost = new core_1.AsyncEventEmitter((_d = this.parent) === null || _d === void 0 ? void 0 : _d.onInsertPost);
        this.onDeletePre = new core_1.AsyncEventEmitter((_e = this.parent) === null || _e === void 0 ? void 0 : _e.onDeletePre);
        this.onDeletePost = new core_1.AsyncEventEmitter((_f = this.parent) === null || _f === void 0 ? void 0 : _f.onDeletePost);
        this.onCommitPre = new core_1.AsyncEventEmitter((_g = this.parent) === null || _g === void 0 ? void 0 : _g.onCommitPre);
    }
    fork() {
        return new UnitOfWorkDatabaseEmitter(this);
    }
}
exports.UnitOfWorkDatabaseEmitter = UnitOfWorkDatabaseEmitter;
class QueryDatabaseEvent extends core_1.AsyncEmitterEvent {
    constructor(databaseSession, classSchema, query) {
        super();
        this.databaseSession = databaseSession;
        this.classSchema = classSchema;
        this.query = query;
    }
    isSchemaOf(classTypeOrSchema) {
        return this.classSchema.isSchemaOf(classTypeOrSchema);
    }
}
exports.QueryDatabaseEvent = QueryDatabaseEvent;
class QueryDatabaseDeleteEvent extends core_1.AsyncEmitterEvent {
    constructor(databaseSession, classSchema, query, deleteResult) {
        super();
        this.databaseSession = databaseSession;
        this.classSchema = classSchema;
        this.query = query;
        this.deleteResult = deleteResult;
    }
    isSchemaOf(classTypeOrSchema) {
        return this.classSchema.isSchemaOf(classTypeOrSchema);
    }
}
exports.QueryDatabaseDeleteEvent = QueryDatabaseDeleteEvent;
class QueryDatabasePatchEvent extends core_1.AsyncEmitterEvent {
    constructor(databaseSession, classSchema, query, patch, patchResult) {
        super();
        this.databaseSession = databaseSession;
        this.classSchema = classSchema;
        this.query = query;
        this.patch = patch;
        this.patchResult = patchResult;
        this.returning = [];
    }
    isSchemaOf(classTypeOrSchema) {
        return this.classSchema.isSchemaOf(classTypeOrSchema);
    }
}
exports.QueryDatabasePatchEvent = QueryDatabasePatchEvent;
class QueryDatabaseEmitter {
    constructor(parent) {
        var _a, _b, _c, _d, _e;
        this.parent = parent;
        /**
         * For all queries related to fetching data like: find, findOne, count, has.
         */
        this.onFetch = new core_1.AsyncEventEmitter((_a = this.parent) === null || _a === void 0 ? void 0 : _a.onDeletePre);
        this.onDeletePre = new core_1.AsyncEventEmitter((_b = this.parent) === null || _b === void 0 ? void 0 : _b.onDeletePre);
        this.onDeletePost = new core_1.AsyncEventEmitter((_c = this.parent) === null || _c === void 0 ? void 0 : _c.onDeletePost);
        this.onPatchPre = new core_1.AsyncEventEmitter((_d = this.parent) === null || _d === void 0 ? void 0 : _d.onPatchPre);
        this.onPatchPost = new core_1.AsyncEventEmitter((_e = this.parent) === null || _e === void 0 ? void 0 : _e.onPatchPost);
    }
    fork() {
        return new QueryDatabaseEmitter(this);
    }
}
exports.QueryDatabaseEmitter = QueryDatabaseEmitter;
//# sourceMappingURL=event.js.map