"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IdentityMap = exports.getInstanceState = exports.getInstanceStateFromItem = exports.getClassState = exports.ClassState = exports.getNormalizedPrimaryKey = void 0;
const type_1 = require("@deepkit/type");
const core_1 = require("@deepkit/core");
const util_1 = require("util");
function getNormalizedPrimaryKey(schema, primaryKey) {
    const primaryFields = schema.getPrimaryFields();
    if (primaryFields.length > 1) {
        if (!core_1.isObject(primaryKey)) {
            throw new Error(`Entity ${schema.getClassName()} has composite primary key. Please provide primary key as object, e.g. {pk1: value, pk2: value2}.`);
        }
        const res = {};
        for (const primaryField of primaryFields) {
            res[primaryField.name] = primaryKey[primaryField.name];
        }
        return res;
    }
    else {
        const first = primaryFields[0];
        if (core_1.isObject(primaryKey) && primaryKey[first.name] !== undefined) {
            return { [first.name]: primaryKey[first.name] };
        }
        else {
            return { [first.name]: primaryKey };
        }
    }
}
exports.getNormalizedPrimaryKey = getNormalizedPrimaryKey;
class ClassState {
    constructor(classSchema) {
        this.classSchema = classSchema;
        this.snapshot = type_1.getConverterForSnapshot(this.classSchema);
        this.primaryKeyExtractor = type_1.getPrimaryKeyExtractor(this.classSchema);
        this.primaryKeyHashGenerator = type_1.getPrimaryKeyHashGenerator(this.classSchema);
        this.simplePrimaryKeyHashGenerator = type_1.getSimplePrimaryKeyHashGenerator(this.classSchema);
        this.changeDetector = type_1.getChangeDetector(this.classSchema);
    }
}
exports.ClassState = ClassState;
function getClassState(classSchema) {
    if (classSchema.data.classState)
        return classSchema.data.classState;
    classSchema.data.classState = new ClassState(classSchema);
    core_1.toFastProperties(classSchema.data);
    return classSchema.data.classState;
}
exports.getClassState = getClassState;
class InstanceState {
    constructor(classState, item) {
        this.classState = classState;
        this.item = item;
        /**
         * Whether current state is known in database.
         */
        this.knownInDatabase = false;
        /**
         * Whether the item was originally from the database (and thus PK are known there).
         */
        this.fromDatabase = false;
    }
    [util_1.inspect.custom]() {
        return `InstanceState<knownInDatabase=${this.knownInDatabase}, fromDatabase=${this.fromDatabase}>`;
    }
    toString() {
        return `knownInDatabase: ${this.knownInDatabase}`;
    }
    getSnapshot() {
        if (!this.snapshot)
            this.snapshot = this.classState.snapshot(this.item);
        return this.snapshot;
    }
    isFromDatabase() {
        return this.fromDatabase;
    }
    isKnownInDatabase() {
        return this.knownInDatabase;
    }
    markAsFromDatabase() {
        this.fromDatabase = true;
    }
    markAsPersisted() {
        this.knownInDatabase = true;
        this.lastPKHash = undefined; //mark it for generation on-demand
        //This is pretty heavy and only necessary when the user works with the objects
        //but that is not always the case. So we need a way to postpone those
        //calls to a place where we know we need them. For example return
        //not the real object but a Proxy and detect write-operations. As soon
        //a write operation is detected, we create a snapshot. Essentially implement copy-on-write,
        //or in our case snapshot-on-write.
        this.snapshot = this.classState.snapshot(this.item);
        if (this.item[type_1.changeSetSymbol])
            this.item[type_1.changeSetSymbol].clear();
    }
    getLastKnownPK() {
        return this.classState.primaryKeyExtractor(this.snapshot);
    }
    getLastKnownPKHash() {
        if (this.lastPKHash === undefined) {
            this.lastPKHash = this.classState.primaryKeyHashGenerator(this.snapshot);
        }
        return this.lastPKHash;
    }
    markAsDeleted() {
        this.knownInDatabase = false;
    }
}
const instanceStateSymbol = Symbol('state');
function getInstanceStateFromItem(item) {
    return getInstanceState(getClassState(type_1.getClassSchema(item)), item);
}
exports.getInstanceStateFromItem = getInstanceStateFromItem;
function getInstanceState(classState, item) {
    //this approach is up to 60-90x faster than a WeakMap
    if (!item['constructor'].prototype.hasOwnProperty(instanceStateSymbol)) {
        Object.defineProperty(item['constructor'].prototype, instanceStateSymbol, {
            writable: true,
            enumerable: false,
            value: null
        });
    }
    if (!item['constructor'].prototype.hasOwnProperty(type_1.changeSetSymbol)) {
        Object.defineProperty(item['constructor'].prototype, type_1.changeSetSymbol, {
            writable: true,
            enumerable: false,
            value: null
        });
    }
    if (!item[instanceStateSymbol]) {
        item[instanceStateSymbol] = new InstanceState(classState, item);
    }
    return item[instanceStateSymbol];
}
exports.getInstanceState = getInstanceState;
class IdentityMap {
    constructor() {
        this.registry = new Map();
    }
    deleteMany(classSchema, pks) {
        const store = this.getStore(classSchema);
        const state = getClassState(classSchema);
        for (const pk of pks) {
            const pkHash = state.primaryKeyHashGenerator(pk);
            let item = store.get(pkHash);
            if (item) {
                store.delete(pkHash);
                getInstanceState(state, item.ref).markAsDeleted();
            }
        }
    }
    deleteManyBySimplePK(classSchema, pks) {
        const store = this.getStore(classSchema);
        const state = getClassState(classSchema);
        for (const pk of pks) {
            const pkHash = state.simplePrimaryKeyHashGenerator(pk);
            let item = store.get(pkHash);
            if (item) {
                store.delete(pkHash);
                getInstanceState(state, item.ref).markAsDeleted();
            }
        }
    }
    clear() {
        this.registry.clear();
    }
    isKnown(item) {
        const classSchema = type_1.getClassSchema(item);
        const store = this.getStore(classSchema);
        const state = getClassState(classSchema);
        const pkHash = getInstanceState(state, item).getLastKnownPKHash();
        return store.has(pkHash);
    }
    storeMany(classSchema, items) {
        if (!classSchema.hasPrimaryFields())
            throw new Error(`Entity ${classSchema.getClassName()} has no primary field defined. Use @f.primary to defined one.`);
        const store = this.getStore(classSchema);
        const state = getClassState(classSchema);
        for (const item of items) {
            const pkHash = state.primaryKeyHashGenerator(item);
            store.set(pkHash, { ref: item, stale: false });
            getInstanceState(state, item).markAsPersisted();
        }
    }
    store(classSchema, item) {
        this.storeMany(classSchema, [item]);
    }
    getByHash(classSchema, pk) {
        const store = this.getStore(classSchema);
        return store.has(pk) ? store.get(pk).ref : undefined;
    }
    getStore(classSchema) {
        const store = this.registry.get(classSchema);
        if (store) {
            return store;
        }
        const newStore = new Map();
        this.registry.set(classSchema, newStore);
        return newStore;
    }
}
exports.IdentityMap = IdentityMap;
//# sourceMappingURL=identity-map.js.map