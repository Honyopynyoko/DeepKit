import { ClassType } from '@deepkit/core';
import { Changes, ChangesInterface, ClassSchema, ExtractPrimaryKeyType, ExtractReferences, PrimaryKeyFields, PropertySchema } from '@deepkit/type';
import { Subject } from 'rxjs';
import { DatabaseAdapter } from './database-adapter';
import { DatabaseSession } from './database-session';
import { DeleteResult, Entity, PatchResult } from './type';
import { FieldName, FlattenIfArray, Replace, Resolve } from './utils';
export declare type SORT_ORDER = 'asc' | 'desc' | any;
export declare type Sort<T extends Entity, ORDER extends SORT_ORDER = SORT_ORDER> = {
    [P in keyof T & string]?: ORDER;
};
export interface DatabaseJoinModel<T, PARENT extends BaseQuery<any>> {
    classSchema: ClassSchema<T>;
    propertySchema: PropertySchema;
    type: 'left' | 'inner' | string;
    populate: boolean;
    as?: string;
    query: JoinDatabaseQuery<T, PARENT>;
    foreignPrimaryKey: PropertySchema;
}
export declare type QuerySelector<T> = {
    $eq?: T;
    $gt?: T;
    $gte?: T;
    $in?: T[];
    $lt?: T;
    $lte?: T;
    $ne?: T;
    $nin?: T[];
    $not?: T extends string ? (QuerySelector<T> | RegExp) : QuerySelector<T>;
    $regex?: T extends string ? (RegExp | string) : never;
    $parameter?: string;
};
export declare type RootQuerySelector<T> = {
    $and?: Array<FilterQuery<T>>;
    $nor?: Array<FilterQuery<T>>;
    $or?: Array<FilterQuery<T>>;
    [key: string]: any;
};
declare type RegExpForString<T> = T extends string ? (RegExp | T) : T;
declare type MongoAltQuery<T> = T extends Array<infer U> ? (T | RegExpForString<U>) : RegExpForString<T>;
export declare type Condition<T> = MongoAltQuery<T> | QuerySelector<MongoAltQuery<T>>;
export declare type FilterQuery<T> = {
    [P in keyof T & string]?: Condition<T[P]>;
} & RootQuerySelector<T>;
export declare class DatabaseQueryModel<T extends Entity, FILTER extends FilterQuery<T> = FilterQuery<T>, SORT extends Sort<T> = Sort<T>> {
    withIdentityMap: boolean;
    filter?: FILTER;
    having?: FILTER;
    groupBy: Set<string>;
    aggregate: Map<string, {
        property: PropertySchema;
        func: string;
    }>;
    select: Set<string>;
    joins: DatabaseJoinModel<any, any>[];
    skip?: number;
    itemsPerPage: number;
    limit?: number;
    parameters: {
        [name: string]: any;
    };
    sort?: SORT;
    readonly change: Subject<void>;
    returning: (keyof T & string)[];
    changed(): void;
    hasSort(): boolean;
    /**
     * Whether limit/skip is activated.
     */
    hasPaging(): boolean;
    setParameters(parameters: {
        [name: string]: any;
    }): void;
    clone(parentQuery: BaseQuery<T>): this;
    /**
     * Whether only a subset of fields are selected.
     */
    isPartial(): boolean;
    /**
     * Whether only a subset of fields are selected.
     */
    isAggregate(): boolean;
    getFirstSelect(): any;
    isSelected(field: string): boolean;
    hasJoins(): boolean;
    hasParameters(): boolean;
}
export declare class ItemNotFound extends Error {
}
export interface QueryClassType<T> {
    create(query: BaseQuery<any>): QueryClassType<T>;
}
export declare class BaseQuery<T extends Entity> {
    readonly classSchema: ClassSchema;
    _: () => T;
    protected createModel<T>(): DatabaseQueryModel<T, FilterQuery<T>, Sort<T, any>>;
    model: DatabaseQueryModel<T>;
    constructor(classSchema: ClassSchema, model?: DatabaseQueryModel<T>);
    groupBy<K extends FieldName<T>[]>(...field: K): this;
    withSum<K extends FieldName<T>, AS extends string>(field: K, as?: AS): Replace<this, Resolve<this> & {
        [K in [AS] as `${AS}`]: number;
    }>;
    withGroupConcat<K extends FieldName<T>, AS extends string>(field: K, as?: AS): Replace<this, Resolve<this> & {
        [C in [AS] as `${AS}`]: T[K][];
    }>;
    withCount<K extends FieldName<T>, AS extends string>(field: K, as?: AS): Replace<this, Resolve<this> & {
        [K in [AS] as `${AS}`]: number;
    }>;
    withMax<K extends FieldName<T>, AS extends string>(field: K, as?: AS): Replace<this, Resolve<this> & {
        [K in [AS] as `${AS}`]: number;
    }>;
    withMin<K extends FieldName<T>, AS extends string>(field: K, as?: AS): Replace<this, Resolve<this> & {
        [K in [AS] as `${AS}`]: number;
    }>;
    withAverage<K extends FieldName<T>, AS extends string>(field: K, as?: AS): Replace<this, Resolve<this> & {
        [K in [AS] as `${AS}`]: number;
    }>;
    aggregateField<K extends FieldName<T>, AS extends string>(field: K, func: string, as?: AS): Replace<this, Resolve<this> & {
        [K in [AS] as `${AS}`]: number;
    }>;
    select<K extends (keyof Resolve<this>)[]>(...select: K): Replace<this, Pick<Resolve<this>, K[number]>>;
    returning(...fields: FieldName<T>[]): this;
    skip(value?: number): this;
    /**
     * Sets the page size when `page(x)` is used.
     */
    itemsPerPage(value: number): this;
    /**
     * Applies limit/skip operations correctly to basically have a paging functionality.
     * Make sure to call itemsPerPage() before you call page.
     */
    page(page: number): this;
    limit(value?: number): this;
    parameter(name: string, value: any): this;
    parameters(parameters: {
        [name: string]: any;
    }): this;
    /**
     * Identity mapping is used to store all created entity instances in a pool.
     * If a query fetches an already known entity instance, the old will be picked.
     * This ensures object instances uniqueness and generally saves CPU circles.
     *
     * This disabled entity tracking, forcing always to create new entity instances.
     */
    disableIdentityMap(): this;
    having(filter?: this['model']['filter']): this;
    filter(filter?: this['model']['filter']): this;
    addFilter<K extends keyof T & string>(name: K, value: FilterQuery<T>[K]): this;
    sort(sort?: this['model']['sort']): this;
    orderBy<K extends FieldName<T>>(field: K, direction?: 'asc' | 'desc'): this;
    clone(): this;
    /**
     * Adds a left join in the filter. Does NOT populate the reference with values.
     * Accessing `field` in the entity (if not optional field) results in an error.
     */
    join<K extends ExtractReferences<T>, ENTITY = FlattenIfArray<T[K]>>(field: K, type?: 'left' | 'inner', populate?: boolean): this;
    /**
     * Adds a left join in the filter. Does NOT populate the reference with values.
     * Accessing `field` in the entity (if not optional field) results in an error.
     * Returns JoinDatabaseQuery to further specify the join, which you need to `.end()`
     */
    useJoin<K extends ExtractReferences<T>, ENTITY = FlattenIfArray<T[K]>>(field: K): JoinDatabaseQuery<ENTITY, this>;
    /**
     * Adds a left join in the filter and populates the result set WITH reference field accordingly.
     */
    joinWith<K extends ExtractReferences<T>>(field: K): this;
    /**
     * Adds a left join in the filter and populates the result set WITH reference field accordingly.
     * Returns JoinDatabaseQuery to further specify the join, which you need to `.end()`
     */
    useJoinWith<K extends ExtractReferences<T>, ENTITY = FlattenIfArray<T[K]>>(field: K): JoinDatabaseQuery<ENTITY, this>;
    getJoin<K extends ExtractReferences<T>, ENTITY = FlattenIfArray<T[K]>>(field: K): JoinDatabaseQuery<ENTITY, this>;
    /**
     * Adds a inner join in the filter and populates the result set WITH reference field accordingly.
     */
    innerJoinWith<K extends ExtractReferences<T>>(field: K): this;
    /**
     * Adds a inner join in the filter and populates the result set WITH reference field accordingly.
     * Returns JoinDatabaseQuery to further specify the join, which you need to `.end()`
     */
    useInnerJoinWith<K extends ExtractReferences<T>, ENTITY = FlattenIfArray<T[K]>>(field: K): JoinDatabaseQuery<ENTITY, this>;
    /**
     * Adds a inner join in the filter. Does NOT populate the reference with values.
     * Accessing `field` in the entity (if not optional field) results in an error.
     */
    innerJoin<K extends ExtractReferences<T>>(field: K): this;
    /**
     * Adds a inner join in the filter. Does NOT populate the reference with values.
     * Accessing `field` in the entity (if not optional field) results in an error.
     * Returns JoinDatabaseQuery to further specify the join, which you need to `.end()`
     */
    useInnerJoin<K extends ExtractReferences<T>, ENTITY = FlattenIfArray<T[K]>>(field: K): JoinDatabaseQuery<ENTITY, this>;
}
export declare abstract class GenericQueryResolver<T, ADAPTER extends DatabaseAdapter = DatabaseAdapter, MODEL extends DatabaseQueryModel<T> = DatabaseQueryModel<T>> {
    protected classSchema: ClassSchema<T>;
    protected session: DatabaseSession<ADAPTER>;
    constructor(classSchema: ClassSchema<T>, session: DatabaseSession<ADAPTER>);
    abstract count(model: MODEL): Promise<number>;
    abstract find(model: MODEL): Promise<T[]>;
    abstract findOneOrUndefined(model: MODEL): Promise<T | undefined>;
    abstract delete(model: MODEL, deleteResult: DeleteResult<T>): Promise<void>;
    abstract patch(model: MODEL, value: Changes<T>, patchResult: PatchResult<T>): Promise<void>;
    abstract has(model: MODEL): Promise<boolean>;
}
export declare type Methods<T> = {
    [K in keyof T]: K extends keyof Query<any> ? never : T[K] extends ((...args: any[]) => any) ? K : never;
}[keyof T];
/**
 * This a generic query abstraction which should supports most basics database interactions.
 *
 * All query implementations should extend this since db agnostic consumers are probably
 * coded against this interface via Database<DatabaseAdapter> which uses this GenericQuery.
 */
export declare class Query<T extends Entity> extends BaseQuery<T> {
    protected databaseSession: DatabaseSession<DatabaseAdapter>;
    protected resolver: GenericQueryResolver<T>;
    protected lifts: ClassType[];
    static is<T extends ClassType<Query<any>>>(v: Query<any>, type: T): v is InstanceType<T>;
    constructor(classSchema: ClassSchema, databaseSession: DatabaseSession<DatabaseAdapter>, resolver: GenericQueryResolver<T>);
    static from<Q extends Query<any> & {
        _: () => T;
    }, T extends ReturnType<InstanceType<B>['_']>, B extends ClassType<Query<any>>>(this: B, query: Q): Replace<InstanceType<B>, Resolve<Q>>;
    lift<B extends ClassType<Query<any>>, T extends ReturnType<InstanceType<B>['_']>, THIS extends Query<any> & {
        _: () => T;
    }>(this: THIS, query: B): Replace<InstanceType<B>, Resolve<this>> & Pick<this, Methods<this>>;
    clone(): this;
    protected callOnFetchEvent(query: this): Promise<this>;
    protected onQueryResolve(query: this): this;
    count(): Promise<number>;
    find(): Promise<Resolve<this>[]>;
    findOneOrUndefined(): Promise<T | undefined>;
    findOne(): Promise<Resolve<this>>;
    deleteMany(): Promise<DeleteResult<T>>;
    deleteOne(): Promise<DeleteResult<T>>;
    protected delete(query: this): Promise<DeleteResult<T>>;
    patchMany(patch: ChangesInterface<T> | Partial<T>): Promise<PatchResult<T>>;
    patchOne(patch: ChangesInterface<T> | Partial<T>): Promise<PatchResult<T>>;
    protected patch(query: this, patch: Partial<T> | ChangesInterface<T>): Promise<PatchResult<T>>;
    has(): Promise<boolean>;
    ids(singleKey?: false): Promise<PrimaryKeyFields<T>[]>;
    ids(singleKey: true): Promise<ExtractPrimaryKeyType<T>[]>;
    findField<K extends FieldName<T>>(name: K): Promise<T[K][]>;
    findOneField<K extends FieldName<T>>(name: K): Promise<T[K]>;
    findOneFieldOrUndefined<K extends FieldName<T>>(name: K): Promise<T[K] | undefined>;
}
export declare class JoinDatabaseQuery<T extends Entity, PARENT extends BaseQuery<any>> extends BaseQuery<T> {
    readonly foreignClassSchema: ClassSchema;
    parentQuery?: PARENT | undefined;
    field?: string | undefined;
    constructor(foreignClassSchema: ClassSchema, parentQuery?: PARENT | undefined, field?: string | undefined);
    clone(parentQuery?: PARENT): this;
    end(): PARENT;
}
export {};
