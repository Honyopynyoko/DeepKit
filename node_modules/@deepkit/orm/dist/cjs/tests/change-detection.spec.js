"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
require("reflect-metadata");
const type_1 = require("@deepkit/type");
const formatter_1 = require("../src/formatter");
const query_1 = require("../src/query");
const database_session_1 = require("../src/database-session");
const memory_db_1 = require("../src/memory-db");
const identity_map_1 = require("../src/identity-map");
const utils_1 = require("../src/utils");
globals_1.test('change-detection', () => {
    class Image {
        constructor() {
            this.id = 0;
            this.data = 'empty';
        }
    }
    __decorate([
        type_1.t.primary,
        __metadata("design:type", Number)
    ], Image.prototype, "id", void 0);
    __decorate([
        type_1.t,
        __metadata("design:type", String)
    ], Image.prototype, "data", void 0);
    let User = class User {
        constructor(username) {
            this.username = username;
            this.id = 0;
        }
    };
    __decorate([
        type_1.t.primary,
        __metadata("design:type", Number)
    ], User.prototype, "id", void 0);
    __decorate([
        type_1.t.reference().optional,
        __metadata("design:type", Image)
    ], User.prototype, "image", void 0);
    User = __decorate([
        __param(0, type_1.t),
        __metadata("design:paramtypes", [String])
    ], User);
    const session = new database_session_1.DatabaseSession(new memory_db_1.MemoryDatabaseAdapter);
    {
        const formatter = new formatter_1.Formatter(type_1.getClassSchema(User), type_1.jsonSerializer);
        const model = new query_1.DatabaseQueryModel();
        const user = formatter.hydrate(model, { username: 'Peter', id: '2' });
        globals_1.expect(user.username).toBe('Peter');
        globals_1.expect(user.id).toBe(2);
        globals_1.expect(user.image).toBeUndefined();
    }
    {
        const formatter = new formatter_1.Formatter(type_1.getClassSchema(User), type_1.jsonSerializer);
        const model = new query_1.DatabaseQueryModel();
        const user = formatter.hydrate(model, { username: 'Peter', id: '2', image: '1' });
        globals_1.expect(user.username).toBe('Peter');
        globals_1.expect(user.id).toBe(2);
        globals_1.expect(user.image).toBeInstanceOf(Image);
        globals_1.expect(user.image.id).toBe(1);
        globals_1.expect(user.image.hasOwnProperty(type_1.getClassSchema(Image).getProperty('data').symbol)).toBe(false);
        globals_1.expect(() => user.image.data).toThrow(`Can not access Image.data since class was not completely hydrated`);
        user.username = 'Bar';
        // expect(buildChangesFromInstance(user)).toMatchObject({ $set: { username: 'Bar' } });
        globals_1.expect(identity_map_1.getClassState(type_1.getClassSchema(user)).classSchema.classType).toBe(User);
        globals_1.expect(identity_map_1.getClassState(type_1.getClassSchema(user.image)).classSchema.classType).toBe(Image);
        globals_1.expect(identity_map_1.getInstanceStateFromItem(user.image).item === user.image).toBe(true);
        globals_1.expect(identity_map_1.getInstanceStateFromItem(user.image).classState.classSchema.classType === Image).toBe(true);
        globals_1.expect(utils_1.buildChangesFromInstance(user.image)).toMatchObject({});
        globals_1.expect(identity_map_1.getInstanceStateFromItem(user.image).item === user.image).toBe(true);
        globals_1.expect(identity_map_1.getInstanceStateFromItem(user.image).classState.classSchema.classType === Image).toBe(true);
        user.image.data = 'changed';
        globals_1.expect(user.image.data).toBe('changed');
        console.log('----------------------------');
        globals_1.expect(utils_1.buildChangesFromInstance(user.image)).toMatchObject({ $set: { data: 'changed' } });
        //changing user.image.data doesnt trigger for user
        globals_1.expect(utils_1.buildChangesFromInstance(user)).toMatchObject({ $set: { username: 'Bar' } });
        user.image.id = 233;
        globals_1.expect(utils_1.buildChangesFromInstance(user)).toMatchObject({ $set: { username: 'Bar', image: user.image } });
        user.image.id = 1;
        globals_1.expect(utils_1.buildChangesFromInstance(user)).toMatchObject({ $set: { username: 'Bar' } });
        user.image = session.getReference(Image, 2);
        globals_1.expect(utils_1.buildChangesFromInstance(user)).toMatchObject({ $set: { username: 'Bar', image: user.image } });
        user.image = session.getReference(Image, 1);
        globals_1.expect(utils_1.buildChangesFromInstance(user)).toMatchObject({ $set: { username: 'Bar' } });
        user.image = undefined;
        globals_1.expect(utils_1.buildChangesFromInstance(user)).toMatchObject({ $set: { username: 'Bar', image: undefined } });
    }
});
globals_1.test('change-detection string', () => {
    const s = type_1.t.schema({
        username: type_1.t.string,
    });
    const item = type_1.jsonSerializer.for(s).deserialize({ username: 'Peter' });
    identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
    item.username = 'Alex';
    globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { username: 'Alex' } });
});
globals_1.test('change-detection number', () => {
    const s = type_1.t.schema({
        position: type_1.t.number,
    });
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ position: 1 });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        item.position = 2;
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { position: 2 } });
    }
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ position: 1 });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        type_1.atomicChange(item).increase('position', 5);
        globals_1.expect(item.position).toBe(6);
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $inc: { position: 5 } });
    }
});
globals_1.test('change-detection array', () => {
    const s = type_1.t.schema({
        id: type_1.t.number,
        tags: type_1.t.array(type_1.t.string).optional
    });
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, tags: ['a', 'b', 'c'] });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        item.tags[0] = '000';
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: ['000', 'b', 'c'] } });
    }
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, tags: ['a', 'b', 'c'] });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        item.tags.splice(1, 1); //remove b
        globals_1.expect(item.tags).toEqual(['a', 'c']);
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: ['a', 'c'] } });
        item.tags = undefined;
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: undefined } });
    }
});
globals_1.test('change-detection object', () => {
    const s = type_1.t.schema({
        id: type_1.t.number,
        tags: type_1.t.map(type_1.t.boolean).optional
    });
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, tags: { a: true, b: true } });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
        item.tags.b = false;
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: { a: true, b: false } } });
    }
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, tags: { a: true, b: true } });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        delete item.tags.b;
        globals_1.expect(item.tags).toMatchObject({ a: true });
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: { a: true } } });
        item.tags = undefined;
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: undefined } });
    }
});
globals_1.test('change-detection union', () => {
    const s = type_1.t.schema({
        id: type_1.t.number,
        tags: type_1.t.union(type_1.t.schema({
            type: type_1.t.literal('a'),
            name: type_1.t.string,
        }), type_1.t.schema({
            type: type_1.t.literal('b'),
            size: type_1.t.number,
        })).optional
    });
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, tags: { type: 'a', name: 'peter' } });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
        item.tags = { type: 'b', size: 5 };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: { type: 'b', size: 5 } } });
        item.tags = undefined;
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: undefined } });
    }
});
globals_1.test('change-detection enum', () => {
    let MyEnum;
    (function (MyEnum) {
        MyEnum[MyEnum["start"] = 0] = "start";
        MyEnum[MyEnum["running"] = 1] = "running";
        MyEnum[MyEnum["stopped"] = 2] = "stopped";
    })(MyEnum || (MyEnum = {}));
    const s = type_1.t.schema({
        id: type_1.t.number,
        enum: type_1.t.enum(MyEnum).optional
    });
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, enum: MyEnum.running });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
        item.enum = MyEnum.stopped;
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { enum: MyEnum.stopped } });
        item.enum = undefined;
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { enum: undefined } });
    }
});
globals_1.test('change-detection arrayBuffer', () => {
    const s = type_1.t.schema({
        id: type_1.t.number,
        buffer: type_1.t.type(ArrayBuffer)
    });
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, buffer: new ArrayBuffer(10) });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
        new Uint8Array(item.buffer)[5] = 5;
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { buffer: item.buffer } });
        new Uint8Array(item.buffer)[5] = 0;
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
    }
});
globals_1.test('change-detection typedArray', () => {
    const s = type_1.t.schema({
        id: type_1.t.number,
        buffer: type_1.t.type(Uint16Array)
    });
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, buffer: new Uint16Array(10) });
        globals_1.expect(item.buffer.byteLength).toBe(20);
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
        item.buffer[4] = 5;
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { buffer: item.buffer } });
        item.buffer[4] = 0;
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
    }
});
globals_1.test('change-detection array in array', () => {
    const s = type_1.t.schema({
        id: type_1.t.number,
        tags: type_1.t.array(type_1.t.array(type_1.t.string))
    });
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, tags: [['a', 'b'], ['c']] });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
        item.tags = [];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: item.tags } });
        item.tags = [['a'], ['c']];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: item.tags } });
        item.tags = [['a', 'b'], []];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: item.tags } });
        item.tags = [['a', 'b'], ['c']];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
        item.tags = [['a', 'b'], ['d']];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: item.tags } });
    }
});
globals_1.test('change-detection array in object', () => {
    const s = type_1.t.schema({
        id: type_1.t.number,
        tags: type_1.t.map(type_1.t.array(type_1.t.string))
    });
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, tags: { foo: ['a', 'b'], bar: ['c'] } });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
        item.tags = {};
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: item.tags } });
        item.tags = { foo: ['a'] };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: item.tags } });
        item.tags = { foo: ['a', 'b'], bar: ['d'] };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: item.tags } });
        item.tags = { foo: ['a', 'b'], bar: ['c'] };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
    }
});
globals_1.test('change-detection object in object', () => {
    const s = type_1.t.schema({
        id: type_1.t.number,
        tags: type_1.t.map(type_1.t.map(type_1.t.boolean))
    });
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, tags: { foo: { a: true }, bar: { b: false } } });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
        item.tags = {};
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: item.tags } });
        item.tags = { foo: { a: true }, bar: { b: true } };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: item.tags } });
        item.tags = { foo: { a: true }, bar: {} };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: item.tags } });
        item.tags = { foo: { a: true }, bar: { b: false } };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
        item.tags = { foo: {}, bar: { b: false } };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: item.tags } });
        item.tags = { foo: { a: true } };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { tags: item.tags } });
    }
});
globals_1.test('change-detection class', () => {
    const s = type_1.t.schema({
        id: type_1.t.number,
        config: type_1.t.type({
            a: type_1.t.string.optional,
            b: type_1.t.string.optional,
        })
    });
    globals_1.expect(s.getProperty('config').getResolvedClassSchema().getProperty('a').type).toBe('string');
    globals_1.expect(s.getProperty('config').getResolvedClassSchema().getProperty('b').type).toBe('string');
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, config: { a: 'foo', b: 'bar' } });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
        item.config = { a: 'bar', b: 'bar' };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { config: item.config } });
        item.config = { a: undefined, b: 'bar' };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { config: item.config } });
        item.config = { a: 'foo', b: 'bar2' };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { config: item.config } });
        item.config = { a: 'foo', b: 'bar' };
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
    }
});
globals_1.test('change-detection class in array', () => {
    const s = type_1.t.schema({
        id: type_1.t.number,
        config: type_1.t.array({
            name: type_1.t.string,
            value: type_1.t.string,
        })
    });
    globals_1.expect(s.getProperty('config').getSubType().getResolvedClassSchema().getProperty('name').type).toBe('string');
    globals_1.expect(s.getProperty('config').getSubType().getResolvedClassSchema().getProperty('value').type).toBe('string');
    {
        const item = type_1.jsonSerializer.for(s).deserialize({ id: 1, config: [{ name: 'foo', value: 'bar' }, { name: 'foo2', value: 'bar2' }] });
        identity_map_1.getInstanceStateFromItem(item).markAsPersisted();
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
        item.config = [{ name: 'foo', value: 'bar' }];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { config: item.config } });
        item.config = [{ name: 'foo2', value: 'bar2' }];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { config: item.config } });
        item.config = [{ name: 'foo3', value: 'bar' }, { name: 'foo2', value: 'bar2' }];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { config: item.config } });
        item.config = [{ name: 'foo', value: 'bar' }, { name: 'foo4', value: 'bar2' }];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { config: item.config } });
        item.config = [{ name: 'foo4', value: 'bar2' }];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { config: item.config } });
        item.config = [];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { config: item.config } });
        item.config = [{ name: 'foo', value: 'bar' }, { name: 'foo2', value: 'bar2' }, { name: 'foo3', value: 'bar3' }];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({ $set: { config: item.config } });
        item.config = [{ name: 'foo', value: 'bar' }, { name: 'foo2', value: 'bar2' }];
        globals_1.expect(utils_1.buildChangesFromInstance(item)).toMatchObject({});
    }
});
//# sourceMappingURL=change-detection.spec.js.map