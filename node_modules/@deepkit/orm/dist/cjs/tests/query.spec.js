"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const type_1 = require("@deepkit/type");
const globals_1 = require("@jest/globals");
const conditional_type_checks_1 = require("conditional-type-checks");
const database_1 = require("../src/database");
const memory_db_1 = require("../src/memory-db");
const query_1 = require("../src/query");
globals_1.test('query select', async () => {
    const s = type_1.t.schema({
        id: type_1.t.number.primary,
        username: type_1.t.string
    }, { name: 'User' });
    conditional_type_checks_1.assert(true);
    const database = new database_1.Database(new memory_db_1.MemoryDatabaseAdapter());
    await database.persist(type_1.plainToClass(s, { id: 0, username: 'Peter' }));
    await database.persist(type_1.plainToClass(s, { id: 0, username: 'Peter' }));
    {
        const item = await database.query(s).findOne();
        globals_1.expect(item.username).toBe('Peter');
        conditional_type_checks_1.assert(true);
        conditional_type_checks_1.assert(true);
    }
    {
        const item = await database.query(s).select('username').findOne();
        globals_1.expect(item.username).toBe('Peter');
        conditional_type_checks_1.assert(false);
        conditional_type_checks_1.assert(false);
        conditional_type_checks_1.assert(true);
    }
});
globals_1.test('query lift', async () => {
    const s = type_1.t.schema({
        id: type_1.t.number.primary,
        username: type_1.t.string,
        openBillings: type_1.t.number.default(0),
    }, { name: 'User' });
    const database = new database_1.Database(new memory_db_1.MemoryDatabaseAdapter());
    const q = database.query(s);
    await database.persist(type_1.plainToClass(s, { id: 0, username: 'foo' }));
    await database.persist(type_1.plainToClass(s, { id: 1, username: 'bar', openBillings: 5 }));
    class MyBase extends query_1.Query {
        constructor() {
            super(...arguments);
            this.world = 'world';
        }
        hello() {
            return this.world;
        }
    }
    class UserQuery extends MyBase {
        findAllUserNames() {
            return this.findField('username');
        }
        //query classes should be able to infer the actual used class
        //so specialized routines could be executed (e.g. for SQL queries)
        detectMemoryQuery() {
            return this instanceof memory_db_1.MemoryQuery;
        }
    }
    class BilligQuery extends query_1.Query {
        due() {
            return this.addFilter('openBillings', { $gt: 0 });
        }
    }
    class OverwriteHello extends query_1.Query {
        hello() {
            return 'nope';
        }
    }
    globals_1.expect(query_1.Query.is(q, UserQuery)).toBe(false);
    globals_1.expect(query_1.Query.is(q.lift(UserQuery), UserQuery)).toBe(true);
    globals_1.expect(query_1.Query.is(q.lift(UserQuery), MyBase)).toBe(true);
    globals_1.expect(q.isMemoryDb()).toBe(true);
    globals_1.expect(q.lift(UserQuery).isMemoryDb()).toBe(true);
    globals_1.expect(q.lift(UserQuery).detectMemoryQuery()).toBe(true);
    globals_1.expect(q.lift(UserQuery).hello()).toBe('world');
    globals_1.expect(q.lift(UserQuery).lift(BilligQuery).hello()).toBe('world');
    globals_1.expect(q.lift(UserQuery).lift(OverwriteHello).hello()).toBe('nope');
    globals_1.expect(query_1.Query.is(q.lift(UserQuery).lift(OverwriteHello), MyBase)).toBe(true);
    globals_1.expect(query_1.Query.is(q.lift(UserQuery).lift(OverwriteHello), OverwriteHello)).toBe(true);
    {
        const items = await q.lift(UserQuery).find();
        conditional_type_checks_1.assert(true);
    }
    {
        const items = await q.lift(UserQuery).find();
        conditional_type_checks_1.assert(true);
    }
    {
        const items = await q.lift(UserQuery).select('id').find();
        conditional_type_checks_1.assert(true);
    }
    {
        const items = await UserQuery.from(q).find();
        conditional_type_checks_1.assert(true);
    }
    {
        const items = await UserQuery.from(q).select('id').find();
        conditional_type_checks_1.assert(true);
    }
    {
        const names = await UserQuery.from(q).findAllUserNames();
        globals_1.expect(names).toEqual(['foo', 'bar']);
    }
    {
        const names = await q.lift(UserQuery).findAllUserNames();
        globals_1.expect(names).toEqual(['foo', 'bar']);
    }
    {
        const lifted = q.lift(UserQuery).lift(BilligQuery);
        conditional_type_checks_1.assert(true);
    }
    // {
    //     const lifted = BilligQuery.from(UserQuery.from(q));
    //     assert<IsExact<UserQuery<any>['findAllUserNames'], typeof lifted['findAllUserNames']>>(true);
    // }
    {
        const items = await UserQuery.from(q).filter({ username: 'foo' }).findAllUserNames();
        globals_1.expect(items).toEqual(['foo']);
        conditional_type_checks_1.assert(true);
    }
    {
        const items = await q.lift(UserQuery).filter({ username: 'foo' }).findAllUserNames();
        globals_1.expect(items).toEqual(['foo']);
        conditional_type_checks_1.assert(true);
    }
    {
        const items = await q.lift(UserQuery).lift(BilligQuery).findAllUserNames();
        globals_1.expect(items).toEqual(['foo', 'bar']);
        conditional_type_checks_1.assert(true);
    }
    {
        const items = await q.lift(UserQuery).lift(BilligQuery).due().findAllUserNames();
        globals_1.expect(items).toEqual(['bar']);
        conditional_type_checks_1.assert(true);
    }
});
// test('query aggregate', async () => {
//     const product = t.schema({
//         id: t.number.primary,
//         category: t.string,
//         title: t.string,
//         price: t.integer,
//         rating: t.integer.default(0),
//     }, { name: 'Product' });
//     const database = new Database(new MemoryDatabaseAdapter());
//     database.query(product).find();
//     const query = database.query(product) as any;
//     query.groupBy('category').sum('sum').find();
//     query.groupBy('category').count('id').find();
//     query.groupBy('category').groupConcat('id').find();
//     query.groupBy('category').min('rating').find();
//     query.groupBy('category').avg('rating').find();
//     query.groupBy('category').max('rating').find();
//     // await database.persist(plainToClass(s, { id: 0, username: 'Peter' }));
// });
//# sourceMappingURL=query.spec.js.map