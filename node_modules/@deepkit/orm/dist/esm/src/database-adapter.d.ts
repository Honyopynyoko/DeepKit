import { Entity } from './type';
import { AbstractClassType } from '@deepkit/core';
import { ClassSchema, ItemChanges, PrimaryKeyFields } from '@deepkit/type';
import { Query } from './query';
import { DatabaseSession } from './database-session';
export declare abstract class DatabaseAdapterQueryFactory {
    abstract createQuery<T extends Entity>(classType: AbstractClassType<T> | ClassSchema<T>): Query<T>;
}
export interface DatabasePersistenceChangeSet<T> {
    changes: ItemChanges<T>;
    item: T;
    primaryKey: PrimaryKeyFields<T>;
}
export declare abstract class DatabasePersistence {
    abstract remove<T extends Entity>(classSchema: ClassSchema<T>, items: T[]): Promise<void>;
    abstract insert<T extends Entity>(classSchema: ClassSchema<T>, items: T[]): Promise<void>;
    abstract update<T extends Entity>(classSchema: ClassSchema<T>, changeSets: DatabasePersistenceChangeSet<T>[]): Promise<void>;
    /**
     * When DatabasePersistence instance is not used anymore, this function will be called.
     * Good place to release a connection for example.
     */
    abstract release(): void;
}
export declare class RawFactory<A extends Array<any>> {
    create(...args: A): any;
}
/**
 * A generic database adapter you can use if the API of `Query` is sufficient.
 *
 * You can specify a more specialized adapter like MysqlDatabaseAdapter/MongoDatabaseAdapter with special API for MySQL/Mongo.
 */
export declare abstract class DatabaseAdapter {
    abstract queryFactory(session: DatabaseSession<this>): DatabaseAdapterQueryFactory;
    rawFactory(session: DatabaseSession<this>): RawFactory<any>;
    abstract createPersistence(session: DatabaseSession<this>): DatabasePersistence;
    abstract disconnect(force?: boolean): void;
    abstract migrate(classSchemas: ClassSchema[]): Promise<void>;
    abstract getName(): string;
    abstract getSchemaName(): string;
    abstract isNativeForeignKeyConstraintSupported(): boolean;
}
