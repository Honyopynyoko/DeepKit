import type { DatabaseAdapter, DatabasePersistence } from './database-adapter';
import { Entity } from './type';
import { ClassType, CustomError } from '@deepkit/core';
import { ClassSchema, GlobalStore, PrimaryKeyFields } from '@deepkit/type';
import { IdentityMap } from './identity-map';
import { HydratorFn } from './formatter';
import { QueryDatabaseEmitter, UnitOfWorkDatabaseEmitter } from './event';
import { DatabaseLogger } from './logger';
import { Stopwatch } from '@deepkit/stopwatch';
export declare class DatabaseSessionRound<ADAPTER extends DatabaseAdapter> {
    protected session: DatabaseSession<any>;
    protected identityMap: IdentityMap;
    protected emitter: UnitOfWorkDatabaseEmitter;
    logger: DatabaseLogger;
    protected addQueue: Set<Entity>;
    protected removeQueue: Set<Entity>;
    protected inCommit: boolean;
    protected committed: boolean;
    protected global: GlobalStore;
    constructor(session: DatabaseSession<any>, identityMap: IdentityMap, emitter: UnitOfWorkDatabaseEmitter, logger: DatabaseLogger);
    isInCommit(): boolean;
    isCommitted(): boolean;
    add(...items: Entity[]): void;
    protected getReferenceDependencies<T extends Entity>(item: T): Entity[];
    remove(...items: Entity[]): void;
    commit(persistence: DatabasePersistence): Promise<void>;
    protected doDelete(persistence: DatabasePersistence): Promise<void>;
    protected doPersist(persistence: DatabasePersistence): Promise<void>;
}
export declare class SessionClosedException extends CustomError {
}
export interface DatabaseSessionHookConstructor<C> {
    new <T extends DatabaseSession<DatabaseAdapter>>(session: T): C;
}
export interface DatabaseSessionHook<T extends DatabaseSession<DatabaseAdapter>> {
}
export declare class DatabaseTransaction {
    id: number;
    constructor(id: number);
}
export declare class DatabaseSession<ADAPTER extends DatabaseAdapter> {
    readonly adapter: ADAPTER;
    readonly unitOfWorkEmitter: UnitOfWorkDatabaseEmitter;
    readonly queryEmitter: QueryDatabaseEmitter;
    logger: DatabaseLogger;
    stopwatch: Stopwatch;
    readonly id: number;
    withIdentityMap: boolean;
    /**
     * When this session belongs to a transaction, then this is set.
     * All connection handlers should make sure that when a query/persistence object
     * requests a connection, it should always be the same for a given transaction.
     * (that's how transaction work). The connection between a transaction
     * and connection should be unlinked when the transaction commits/rollbacks.
     */
    transaction?: DatabaseTransaction;
    readonly identityMap: IdentityMap;
    /**
     * Creates a new DatabaseQuery instance which can be used to query and manipulate data.
     */
    readonly query: ReturnType<this['adapter']['queryFactory']>['createQuery'];
    readonly raw: ReturnType<this['adapter']['rawFactory']>['create'];
    protected rounds: DatabaseSessionRound<ADAPTER>[];
    protected commitDepth: number;
    protected inCommit: boolean;
    protected currentPersistence?: DatabasePersistence;
    constructor(adapter: ADAPTER, unitOfWorkEmitter?: UnitOfWorkDatabaseEmitter, queryEmitter?: QueryDatabaseEmitter, logger?: DatabaseLogger, stopwatch?: Stopwatch);
    from<T>(hook: DatabaseSessionHookConstructor<T>): T;
    /**
     * Creates or returns an existing reference.
     *
     * If no instance is known in the identity map, it creates a proxy reference (where only primary keys are populated).
     * You can work with this entity instance to assign new references, but reading for not-hydrated values is not possible.
     * Writing not-hydrated is possible and lead to a change in the change-detection. Completely hydrate the object using
     * the `hydrateEntity` function.
     *
     * ```
     * const user = session.getReference(User, 1);
     * ```
     */
    getReference<T>(classType: ClassType<T> | ClassSchema<T>, primaryKey: any | PrimaryKeyFields<T>): T;
    protected getCurrentRound(): DatabaseSessionRound<ADAPTER>;
    protected enterNewRound(): void;
    /**
     * Adds a single or multiple to the to add/update queue. Use session.commit() to persist all queued items to the database.
     *
     * This works like Git: you add files, and later commit all in one batch.
     */
    add(...items: Entity[]): void;
    /**
     * Adds a item to the remove queue. Use session.commit() to remove queued items from the database all at once.
     */
    remove(...items: Entity[]): void;
    reset(): void;
    getHydrator(): HydratorFn;
    hydrateEntity<T extends object>(item: T): Promise<void>;
    commit<T>(): Promise<void>;
}
