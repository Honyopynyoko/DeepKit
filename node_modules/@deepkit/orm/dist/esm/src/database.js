/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { CustomError, getClassName } from '@deepkit/core';
import { getClassSchema, getReferenceInfo, isReferenceHydrated } from '@deepkit/type';
import { DatabaseSession } from './database-session';
import { QueryDatabaseEmitter, UnitOfWorkDatabaseEmitter } from './event';
import { getNormalizedPrimaryKey } from './identity-map';
import { DatabaseLogger } from './logger';
import { getReference } from './reference';
import { VirtualForeignKeyConstraint } from './virtual-foreign-key-constraint';
import { Stopwatch } from '@deepkit/stopwatch';
/**
 * Hydrates not completely populated item and makes it completely accessible.
 */
export async function hydrateEntity(item) {
    const info = getReferenceInfo(item);
    if (info && isReferenceHydrated(item))
        return;
    if (info && info.hydrator) {
        await info.hydrator(item);
        return;
    }
    throw new Error(`Given object is not a reference from a database session and thus can not be hydrated.`);
}
export class DatabaseError extends CustomError {
}
/**
 * Type guard for a specialised database adapter. Can be used to
 * use special methods from an adapter on a generic Database object.
 *
 * ```
 * const database = new Database(...); //we don't know the adapter
 *
 * if (isDatabaseOf(database, SQLDatabaseAdapter)) {
 *     // cool, we can use `where(sql)` which is only available for SQLDatabaseAdapter
 *     database.query(User).where(sql`id > 2`).find();
 *
 *     //or raw SQL queries
 *     database.raw(sql`SELECT count(*) FROM ${User}`).find();
 * }
 * ```
 */
export function isDatabaseOf(database, adapterClassType) {
    return database.adapter instanceof adapterClassType;
}
/**
 * Database abstraction. Use createSession() to create a work session with transaction support.
 *
 * Using this class in your code indicates that you can work with common and most basic database semantics.
 * This means that you can use the deepkit/type database API that works across a variety of database engines
 * like MySQL, PostgreSQL, SQLite, and MongoDB.
 */
export class Database {
    constructor(adapter, schemas = []) {
        this.adapter = adapter;
        this.name = 'default';
        /**
         * The entity schema registry.
         */
        this.entities = new Set();
        /**
         * Event API for DatabaseQuery events.
         */
        this.queryEvents = new QueryDatabaseEmitter();
        /**
         * Event API for the unit of work.
         */
        this.unitOfWorkEvents = new UnitOfWorkDatabaseEmitter();
        this.stopwatch = new Stopwatch();
        this.virtualForeignKeyConstraint = new VirtualForeignKeyConstraint(this);
        this.logger = new DatabaseLogger();
        if (Database.registry)
            Database.registry.push(this);
        this.query = (classType) => {
            const session = this.createSession();
            session.withIdentityMap = false;
            return session.query(classType);
        };
        this.raw = (...args) => {
            const session = this.createSession();
            session.withIdentityMap = false;
            if (!session.raw)
                throw new Error('Adapter has no raw mode');
            return session.raw(...args);
        };
        this.registerEntity(...schemas);
        if (!this.adapter.isNativeForeignKeyConstraintSupported()) {
            this.unitOfWorkEvents.onDeletePost.subscribe(async (event) => {
                await this.virtualForeignKeyConstraint.onUoWDelete(event);
            });
            this.unitOfWorkEvents.onUpdatePost.subscribe(async (event) => {
                await this.virtualForeignKeyConstraint.onUoWUpdate(event);
            });
            this.queryEvents.onPatchPost.subscribe(async (event) => {
                await this.virtualForeignKeyConstraint.onQueryPatch(event);
            });
            this.queryEvents.onDeletePost.subscribe(async (event) => {
                await this.virtualForeignKeyConstraint.onQueryDelete(event);
            });
        }
    }
    static createClass(name, adapter, schemas = []) {
        return class extends Database {
            constructor(oAdapter = adapter, oSchemas = schemas) {
                super(oAdapter, oSchemas);
                this.name = name;
            }
        };
    }
    /**
     * Tells the adapter to disconnect. It reconnects automatically when necessary.
     */
    disconnect(force) {
        this.adapter.disconnect(force);
    }
    /**
     * Creates a new database session. This is the preferred way of working with the database
     * and to enjoy all ORM features. Call DatabaseSession.commit to persist changes all at once
     * in the most performant way possible. The creation of a DatabaseSession is very low cost,
     * so creating many or often is the preferred way.
     **
     * All entity instances fetched/stored during this session are cached and tracked automatically.
     *
     * Note: This is not equal to a database transaction. A session means a work block
     * where you need to fetch, change, and save entity instances. Every instance fetched
     * stays in the identity-map of that session and keeps it alive, so make sure
     * to not keep a session for too long (especially not cross requests).

     * @example
     * ```typescript
     * const database = new Database(...);
     *
     * express.on('request', async (req) => {
     *     const session = database.createSession();
     *     const user = session.query(User).filter({id: req.params.id}).findOne();
     *     user.name = req.params.name;
     *     await session.commit(); //session will be garbage collected and should NOT be stored for the next request
     * });
     * ```
     */
    createSession() {
        return new DatabaseSession(this.adapter, this.unitOfWorkEvents, this.queryEvents, this.logger, this.stopwatch);
    }
    /**
     * Executes given callback in a new session and automatically commits it when executed successfully.
     * Automatically does a rollback when callback throws an error. This has the same semantics as `createSession`.
     */
    async session(worker) {
        const session = this.createSession();
        const res = await worker(session);
        await session.commit();
        return res;
    }
    /**
     * Creates a new reference.
     *
     * If you work with a DatabaseSession, use DatabaseSession.getReference instead to
     * maintain object identity.
     *
     * ```
     * const user = database.getReference(User, 1);
     * ```
     */
    getReference(classType, primaryKey) {
        const schema = getClassSchema(classType);
        const pk = getNormalizedPrimaryKey(schema, primaryKey);
        return getReference(schema, pk);
    }
    /**
     * Registers a new entity to this database.
     * This is mainly used for db migration utilities and active record.
     * If you want to use active record, you have to assign your entities first to a database using this method.
     */
    registerEntity(...entities) {
        for (const entity of entities) {
            const schema = getClassSchema(entity);
            this.entities.add(schema);
            schema.data['orm.database'] = this;
            if (isActiveRecordClassType(entity))
                entity.registerDatabase(this);
        }
    }
    getEntity(name) {
        for (const entity of this.entities.values()) {
            if (entity.getName() === name)
                return entity;
        }
        throw new Error(`No entity with name ${name} registered in database ${this.name}`);
    }
    /**
     * Makes sure the schemas types, indices, uniques, etc are reflected in the database.
     *
     * WARNING: DON'T USE THIS IN PRODUCTION AS THIS CAN CAUSE EASILY DATA LOSS.
     * SEE THE MIGRATION DOCUMENTATION TO UNDERSTAND ITS IMPLICATIONS.
     */
    async migrate() {
        await this.adapter.migrate([...this.entities.values()]);
    }
    /**
     * Simple direct persist. The persistence layer (batch) inserts or updates the record
     * depending on the state of the given items. This is different to createSession()+add() in a way
     * that `DatabaseSession.add` adds the given items to the queue (which is then committed using commit())
     * while this `database.persist` just simply inserts/updates the given items immediately,
     * completely bypassing the advantages of the unit of work for multiple items.
     *
     * You should prefer the add/remove and commit() workflow to fully utilizing database performance.
     */
    async persist(...items) {
        const session = this.createSession();
        session.add(...items);
        await session.commit();
    }
    /**
     * Simple direct remove. The persistence layer (batch) removes all given items.
     * This is different to createSession()+remove() in a way that `DatabaseSession.remove` adds the given items to the queue
     * (which is then committed using commit()) while this `database.remove` just simply removes the given items immediately,
     * completely bypassing the advantages of the unit of work for multiple items.
     *
     * You should prefer the add/remove and commit() workflow to fully utilizing database performance.
     */
    async remove(...items) {
        const session = this.createSession();
        session.remove(...items);
        await session.commit();
    }
}
export function isActiveRecordClassType(entity) {
    return 'function' === entity.getDatabase || 'function' === entity.registerDatabase || 'function' === entity.query;
}
export class ActiveRecord {
    constructor(...args) {
    }
    static getDatabase() {
        const database = getClassSchema(this).data['orm.database'];
        if (!database)
            throw new Error(`No database assigned to ${getClassName(this)}. Use Database.registerEntity(${getClassName(this)}) first.`);
        return database;
    }
    static registerDatabase(database) {
        getClassSchema(this).data['orm.database'] = database;
    }
    async save() {
        const db = this.constructor.getDatabase();
        await db.persist(this);
    }
    async remove() {
        const db = this.constructor.getDatabase();
        await db.remove(this);
    }
    static query() {
        return this.getDatabase().query(this);
    }
    static reference(primaryKey) {
        return this.getDatabase().getReference(this, primaryKey);
    }
}
//# sourceMappingURL=database.js.map