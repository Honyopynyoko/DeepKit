/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { getClassSchema } from '@deepkit/type';
import { Query } from '../query';
const deletedAtName = 'deletedAt';
export class SoftDeleteSession {
    constructor(session) {
        this.session = session;
        this.deletedBy = new Map();
        this.restoreItems = [];
        session.unitOfWorkEmitter.onDeletePre.subscribe(event => {
            const deletedBy = this.deletedBy.get(event.classSchema);
            if (!deletedBy)
                return;
            for (const item of event.items) {
                item.deletedBy = deletedBy;
            }
        });
        session.unitOfWorkEmitter.onCommitPre.subscribe(event => {
            for (const item of this.restoreItems) {
                item.deletedAt = undefined;
                item.deletedBy = undefined;
            }
            event.databaseSession.add(...this.restoreItems);
            this.restoreItems.length = 0;
        });
    }
    setDeletedBy(classType, deletedBy) {
        this.deletedBy.set(getClassSchema(classType), deletedBy);
        return this;
    }
    restore(item) {
        this.restoreItems.push(item);
        return this;
    }
}
export class SoftDeleteQuery extends Query {
    constructor() {
        super(...arguments);
        this.includeSoftDeleted = false;
    }
    clone() {
        const c = super.clone();
        c.includeSoftDeleted = this.includeSoftDeleted;
        c.setDeletedBy = this.setDeletedBy;
        return c;
    }
    /**
     * Enables fetching, updating, and deleting of soft-deleted records.
     */
    withSoftDeleted() {
        const m = this.clone();
        m.includeSoftDeleted = true;
        return m;
    }
    /**
     * Includes only soft deleted records.
     */
    isSoftDeleted() {
        const m = this.clone();
        m.includeSoftDeleted = true;
        return m.addFilter('deletedAt', { $ne: undefined });
    }
    deletedBy(value) {
        const c = this.clone();
        c.setDeletedBy = value;
        return c;
    }
    async restoreOne() {
        const patch = { [deletedAtName]: undefined };
        if (this.classSchema.hasProperty('deletedBy'))
            patch['deletedBy'] = undefined;
        await this.withSoftDeleted().patchOne(patch);
    }
    async restoreMany() {
        const patch = { [deletedAtName]: undefined };
        if (this.classSchema.hasProperty('deletedBy'))
            patch['deletedBy'] = undefined;
        await this.withSoftDeleted().patchMany(patch);
    }
    async hardDeleteOne() {
        await this.withSoftDeleted().deleteOne();
    }
    async hardDeleteMany() {
        await this.withSoftDeleted().deleteMany();
    }
}
export class SoftDelete {
    constructor(database) {
        this.database = database;
        this.listeners = new Map();
    }
    enable(...classSchemaOrTypes) {
        for (const type of classSchemaOrTypes)
            this.enableForSchema(type);
    }
    disable(...classSchemaOrTypes) {
        for (const type of classSchemaOrTypes)
            this.disableForSchema(type);
    }
    disableForSchema(classSchemaOrType) {
        const schema = getClassSchema(classSchemaOrType);
        const listener = this.listeners.get(schema);
        if (listener) {
            listener.queryFetch.unsubscribe();
            listener.queryPatch.unsubscribe();
            listener.queryDelete.unsubscribe();
            listener.uowDelete.unsubscribe();
            this.listeners.delete(schema);
        }
    }
    enableForSchema(classSchemaOrType) {
        const schema = getClassSchema(classSchemaOrType);
        const hasDeletedBy = schema.hasProperty('deletedBy');
        if (!schema.hasProperty(deletedAtName)) {
            throw new Error(`Entity ${schema.getClassName()} has no ${deletedAtName} property. Please define one as type '${deletedAtName}: t.date.optional'`);
        }
        function queryFilter(event) {
            //this is for each query method: count, find, findOne(), etc.
            //we don't change SoftDeleteQuery instances as they operate on the raw records without filter
            if (Query.is(event.query, SoftDeleteQuery) && event.query.includeSoftDeleted === true)
                return;
            if (event.classSchema !== schema)
                return; //do nothing
            //attach the filter to exclude deleted records
            event.query = event.query.addFilter(deletedAtName, undefined);
        }
        const queryFetch = this.database.queryEvents.onFetch.subscribe(queryFilter);
        const queryPatch = this.database.queryEvents.onPatchPre.subscribe(queryFilter);
        const queryDelete = this.database.queryEvents.onDeletePre.subscribe(async (event) => {
            if (event.classSchema !== schema)
                return; //do nothing
            //we don't change SoftDeleteQuery instances as they operate on the raw records without filter
            if (Query.is(event.query, SoftDeleteQuery) && event.query.includeSoftDeleted === true)
                return;
            //stop actual query delete query
            event.stop();
            const patch = { [deletedAtName]: new Date };
            if (hasDeletedBy && Query.is(event.query, SoftDeleteQuery) && event.query.setDeletedBy !== undefined) {
                patch.deletedBy = event.query.setDeletedBy;
            }
            await event.query.patchMany(patch);
        });
        const uowDelete = this.database.unitOfWorkEvents.onDeletePre.subscribe(async (event) => {
            if (event.classSchema !== schema)
                return; //do nothing
            //stop actual query delete query
            event.stop();
            //instead of removing, we move it into the current session (creating a new SessionRound)
            //to let the current commit know we want to rather update it, instead of deleting.
            for (const item of event.items) {
                item[deletedAtName] = new Date;
            }
            //this creates a new SessionRound, and commits automatically once the current is done (in the same transaction).
            event.databaseSession.add(...event.items);
        });
        this.listeners.set(schema, { queryFetch, queryPatch, queryDelete, uowDelete });
    }
}
//# sourceMappingURL=soft-delete.js.map