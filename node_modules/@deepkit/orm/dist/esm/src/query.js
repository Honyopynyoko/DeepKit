/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { empty } from '@deepkit/core';
import { Changes, getSimplePrimaryKeyHashGenerator, getSingleTableInheritanceTypeValue } from '@deepkit/type';
import { Subject } from 'rxjs';
import { QueryDatabaseDeleteEvent, QueryDatabaseEvent, QueryDatabasePatchEvent } from './event';
import { FrameCategory } from '@deepkit/stopwatch';
export class DatabaseQueryModel {
    constructor() {
        this.withIdentityMap = true;
        this.groupBy = new Set();
        this.aggregate = new Map();
        this.select = new Set();
        this.joins = [];
        this.itemsPerPage = 50;
        this.parameters = {};
        this.change = new Subject();
        this.returning = [];
    }
    changed() {
        this.change.next();
    }
    hasSort() {
        return this.sort !== undefined;
    }
    /**
     * Whether limit/skip is activated.
     */
    hasPaging() {
        return this.limit !== undefined || this.skip !== undefined;
    }
    setParameters(parameters) {
        for (const [i, v] of Object.entries(parameters)) {
            this.parameters[i] = v;
        }
    }
    clone(parentQuery) {
        const constructor = this.constructor;
        const m = new constructor();
        m.filter = this.filter && { ...this.filter };
        m.having = this.having && { ...this.having };
        m.withIdentityMap = this.withIdentityMap;
        m.select = new Set(this.select);
        m.groupBy = new Set(this.groupBy);
        m.aggregate = new Map(this.aggregate);
        m.parameters = { ...this.parameters };
        m.joins = this.joins.map((v) => {
            return {
                classSchema: v.classSchema,
                propertySchema: v.propertySchema,
                type: v.type,
                populate: v.populate,
                query: v.query.clone(parentQuery),
                foreignPrimaryKey: v.foreignPrimaryKey,
            };
        });
        for (const join of m.joins) {
            join.query.model.parameters = m.parameters;
        }
        m.skip = this.skip;
        m.limit = this.limit;
        m.itemsPerPage = this.itemsPerPage;
        m.sort = this.sort ? { ...this.sort } : undefined;
        return m;
    }
    /**
     * Whether only a subset of fields are selected.
     */
    isPartial() {
        return this.select.size > 0 || this.groupBy.size > 0 || this.aggregate.size > 0;
    }
    /**
     * Whether only a subset of fields are selected.
     */
    isAggregate() {
        return this.groupBy.size > 0 || this.aggregate.size > 0;
    }
    getFirstSelect() {
        return this.select.values().next().value;
    }
    isSelected(field) {
        return this.select.has(field);
    }
    hasJoins() {
        return this.joins.length > 0;
    }
    hasParameters() {
        return !empty(this.parameters);
    }
}
export class ItemNotFound extends Error {
}
export class BaseQuery {
    constructor(classSchema, model) {
        this.classSchema = classSchema;
        this.model = model || this.createModel();
    }
    createModel() {
        return new DatabaseQueryModel();
    }
    groupBy(...field) {
        const c = this.clone();
        c.model.groupBy = new Set([...field]);
        return c;
    }
    withSum(field, as) {
        return this.aggregateField(field, 'sum', as);
    }
    withGroupConcat(field, as) {
        return this.aggregateField(field, 'group_concat', as);
    }
    withCount(field, as) {
        return this.aggregateField(field, 'count', as);
    }
    withMax(field, as) {
        return this.aggregateField(field, 'max', as);
    }
    withMin(field, as) {
        return this.aggregateField(field, 'min', as);
    }
    withAverage(field, as) {
        return this.aggregateField(field, 'avg', as);
    }
    aggregateField(field, func, as) {
        const c = this.clone();
        as || (as = field);
        c.model.aggregate.set(as, { property: this.classSchema.getProperty(field), func });
        return c;
    }
    select(...select) {
        const c = this.clone();
        c.model.select = new Set([...select]);
        return c;
    }
    returning(...fields) {
        const c = this.clone();
        c.model.returning.push(...fields);
        return c;
    }
    skip(value) {
        const c = this.clone();
        c.model.skip = value;
        return c;
    }
    /**
     * Sets the page size when `page(x)` is used.
     */
    itemsPerPage(value) {
        const c = this.clone();
        c.model.itemsPerPage = value;
        return c;
    }
    /**
     * Applies limit/skip operations correctly to basically have a paging functionality.
     * Make sure to call itemsPerPage() before you call page.
     */
    page(page) {
        const c = this.clone();
        const skip = (page * c.model.itemsPerPage) - c.model.itemsPerPage;
        c.model.skip = skip;
        c.model.limit = c.model.itemsPerPage;
        return c;
    }
    limit(value) {
        const c = this.clone();
        c.model.limit = value;
        return c;
    }
    parameter(name, value) {
        const c = this.clone();
        c.model.parameters[name] = value;
        return c;
    }
    parameters(parameters) {
        const c = this.clone();
        c.model.parameters = parameters;
        return c;
    }
    /**
     * Identity mapping is used to store all created entity instances in a pool.
     * If a query fetches an already known entity instance, the old will be picked.
     * This ensures object instances uniqueness and generally saves CPU circles.
     *
     * This disabled entity tracking, forcing always to create new entity instances.
     */
    disableIdentityMap() {
        const c = this.clone();
        c.model.withIdentityMap = false;
        return c;
    }
    having(filter) {
        const c = this.clone();
        c.model.having = filter;
        return c;
    }
    filter(filter) {
        const c = this.clone();
        if (filter && !Object.keys(filter).length)
            filter = undefined;
        if (filter instanceof this.classSchema.classType) {
            const primaryKey = this.classSchema.getPrimaryField();
            c.model.filter = { [primaryKey.name]: filter[primaryKey.name] };
        }
        else {
            c.model.filter = filter;
        }
        return c;
    }
    addFilter(name, value) {
        const c = this.clone();
        if (!c.model.filter)
            c.model.filter = {};
        c.model.filter[name] = value;
        //todo: when c.model.filter is a complex object with $and/$or, we need to adjust accordingly.
        return c;
    }
    sort(sort) {
        const c = this.clone();
        c.model.sort = sort;
        return c;
    }
    orderBy(field, direction = 'asc') {
        const c = this.clone();
        if (!c.model.sort)
            c.model.sort = {};
        c.model.sort[field] = direction;
        return c;
    }
    clone() {
        const cloned = new this['constructor'](this.classSchema);
        cloned.model = this.model.clone(cloned);
        return cloned;
    }
    /**
     * Adds a left join in the filter. Does NOT populate the reference with values.
     * Accessing `field` in the entity (if not optional field) results in an error.
     */
    join(field, type = 'left', populate = false) {
        const propertySchema = this.classSchema.getProperty(field);
        if (!propertySchema.isReference && !propertySchema.backReference) {
            throw new Error(`Field ${field} is not marked as reference. Use @t.reference()`);
        }
        const c = this.clone();
        const query = new JoinDatabaseQuery(propertySchema.getResolvedClassSchema(), c, field);
        query.model.parameters = c.model.parameters;
        c.model.joins.push({
            propertySchema, query, populate, type,
            foreignPrimaryKey: propertySchema.getResolvedClassSchema().getPrimaryField(),
            classSchema: this.classSchema,
        });
        return c;
    }
    /**
     * Adds a left join in the filter. Does NOT populate the reference with values.
     * Accessing `field` in the entity (if not optional field) results in an error.
     * Returns JoinDatabaseQuery to further specify the join, which you need to `.end()`
     */
    useJoin(field) {
        const c = this.join(field, 'left');
        return c.model.joins[c.model.joins.length - 1].query;
    }
    /**
     * Adds a left join in the filter and populates the result set WITH reference field accordingly.
     */
    joinWith(field) {
        return this.join(field, 'left', true);
    }
    /**
     * Adds a left join in the filter and populates the result set WITH reference field accordingly.
     * Returns JoinDatabaseQuery to further specify the join, which you need to `.end()`
     */
    useJoinWith(field) {
        const c = this.join(field, 'left', true);
        return c.model.joins[c.model.joins.length - 1].query;
    }
    getJoin(field) {
        for (const join of this.model.joins) {
            if (join.propertySchema.name === field)
                return join.query;
        }
        throw new Error(`No join fo reference ${field} added.`);
    }
    /**
     * Adds a inner join in the filter and populates the result set WITH reference field accordingly.
     */
    innerJoinWith(field) {
        return this.join(field, 'inner', true);
    }
    /**
     * Adds a inner join in the filter and populates the result set WITH reference field accordingly.
     * Returns JoinDatabaseQuery to further specify the join, which you need to `.end()`
     */
    useInnerJoinWith(field) {
        const c = this.join(field, 'inner', true);
        return c.model.joins[c.model.joins.length - 1].query;
    }
    /**
     * Adds a inner join in the filter. Does NOT populate the reference with values.
     * Accessing `field` in the entity (if not optional field) results in an error.
     */
    innerJoin(field) {
        return this.join(field, 'inner');
    }
    /**
     * Adds a inner join in the filter. Does NOT populate the reference with values.
     * Accessing `field` in the entity (if not optional field) results in an error.
     * Returns JoinDatabaseQuery to further specify the join, which you need to `.end()`
     */
    useInnerJoin(field) {
        const c = this.join(field, 'inner');
        return c.model.joins[c.model.joins.length - 1].query;
    }
}
export class GenericQueryResolver {
    constructor(classSchema, session) {
        this.classSchema = classSchema;
        this.session = session;
    }
}
/**
 * This a generic query abstraction which should supports most basics database interactions.
 *
 * All query implementations should extend this since db agnostic consumers are probably
 * coded against this interface via Database<DatabaseAdapter> which uses this GenericQuery.
 */
export class Query extends BaseQuery {
    constructor(classSchema, databaseSession, resolver) {
        super(classSchema);
        this.databaseSession = databaseSession;
        this.resolver = resolver;
        this.lifts = [];
        this.model.withIdentityMap = databaseSession.withIdentityMap;
    }
    static is(v, type) {
        return v.lifts.includes(type) || v instanceof type;
    }
    static from(query) {
        const result = (new this(query.classSchema, query.databaseSession, query.resolver));
        result.model = query.model.clone(result);
        return result;
    }
    lift(query) {
        const base = this['constructor'];
        //we create a custom class to have our own prototype
        const clazz = class extends base {
        };
        let obj = query;
        const wasSet = {};
        const lifts = [];
        do {
            if (obj === Query)
                break;
            lifts.push(obj);
            for (const i of Object.getOwnPropertyNames(obj.prototype)) {
                if (i === 'constructor')
                    continue;
                if (wasSet[i])
                    continue;
                Object.defineProperty(clazz.prototype, i, {
                    configurable: true,
                    writable: true,
                    value: obj.prototype[i],
                });
                wasSet[i] = true;
            }
        } while (obj = Object.getPrototypeOf(obj));
        const cloned = new clazz(this.classSchema, this.databaseSession, this.resolver);
        const lift = new query(this.classSchema, this.databaseSession, this.resolver, this.model);
        for (const i in this) {
            (cloned)[i] = this[i];
        }
        for (const i in lift) {
            (cloned)[i] = lift[i];
        }
        cloned.model = this.model.clone(cloned);
        cloned.lifts = this.lifts;
        cloned.lifts.push(...lifts);
        return cloned;
    }
    clone() {
        const cloned = new this['constructor'](this.classSchema, this.databaseSession, this.resolver);
        cloned.model = this.model.clone(cloned);
        cloned.lifts = this.lifts;
        return cloned;
    }
    async callOnFetchEvent(query) {
        const hasEvents = this.databaseSession.queryEmitter.onFetch.hasSubscriptions();
        if (!hasEvents)
            return query;
        const event = new QueryDatabaseEvent(this.databaseSession, this.classSchema, query);
        await this.databaseSession.queryEmitter.onFetch.emit(event);
        return event.query;
    }
    onQueryResolve(query) {
        if (query.classSchema.singleTableInheritance && query.classSchema.superClass) {
            const discriminant = query.classSchema.superClass.getSingleTableInheritanceDiscriminant();
            const value = query.classSchema.getProperty(discriminant.name).getDefaultValue() || getSingleTableInheritanceTypeValue(query.classSchema);
            return query.addFilter(discriminant.name, value);
        }
        return query;
    }
    async count() {
        const query = this.onQueryResolve(await this.callOnFetchEvent(this));
        return await query.resolver.count(query.model);
    }
    async find() {
        if (!this.databaseSession.stopwatch.active) {
            const query = this.onQueryResolve(await this.callOnFetchEvent(this));
            return await query.resolver.find(query.model);
        }
        const frame = this.databaseSession.stopwatch.start(this.classSchema.getClassName() + ': Find', FrameCategory.database);
        try {
            const query = this.onQueryResolve(await this.callOnFetchEvent(this));
            return await query.resolver.find(query.model);
        }
        finally {
            frame.end();
        }
    }
    async findOneOrUndefined() {
        const query = this.onQueryResolve(await this.callOnFetchEvent(this.limit(1)));
        return await query.resolver.findOneOrUndefined(query.model);
    }
    async findOne() {
        const query = this.onQueryResolve(await this.callOnFetchEvent(this.limit(1)));
        const item = await query.resolver.findOneOrUndefined(query.model);
        if (!item)
            throw new ItemNotFound(`Item ${this.classSchema.getClassName()} not found`);
        return item;
    }
    async deleteMany() {
        return await this.delete(this);
    }
    async deleteOne() {
        return await this.delete(this.limit(1));
    }
    async delete(query) {
        const hasEvents = this.databaseSession.queryEmitter.onDeletePre.hasSubscriptions() || this.databaseSession.queryEmitter.onDeletePost.hasSubscriptions();
        const deleteResult = {
            modified: 0,
            primaryKeys: []
        };
        if (!hasEvents) {
            query = this.onQueryResolve(query);
            await this.resolver.delete(query.model, deleteResult);
            this.databaseSession.identityMap.deleteManyBySimplePK(this.classSchema, deleteResult.primaryKeys);
            return deleteResult;
        }
        const event = new QueryDatabaseDeleteEvent(this.databaseSession, this.classSchema, query, deleteResult);
        if (this.databaseSession.queryEmitter.onDeletePre.hasSubscriptions()) {
            await this.databaseSession.queryEmitter.onDeletePre.emit(event);
            if (event.stopped)
                return deleteResult;
        }
        //whe need to use event.query in case someone overwrite it
        event.query = this.onQueryResolve(event.query);
        await event.query.resolver.delete(event.query.model, deleteResult);
        this.databaseSession.identityMap.deleteManyBySimplePK(this.classSchema, deleteResult.primaryKeys);
        if (deleteResult.primaryKeys.length && this.databaseSession.queryEmitter.onDeletePost.hasSubscriptions()) {
            await this.databaseSession.queryEmitter.onDeletePost.emit(event);
            if (event.stopped)
                return deleteResult;
        }
        return deleteResult;
    }
    async patchMany(patch) {
        return this.patch(this, patch);
    }
    async patchOne(patch) {
        return this.patch(this.limit(1), patch);
    }
    async patch(query, patch) {
        const changes = new Changes({
            $set: patch.$set || {},
            $inc: patch.$inc,
            $unset: patch.$unset,
        });
        for (const property of this.classSchema.getProperties()) {
            if (property.name in patch) {
                changes.set(property.name, patch[property.name]);
            }
        }
        const patchResult = {
            modified: 0,
            returning: {},
            primaryKeys: []
        };
        if (changes.empty)
            return patchResult;
        const hasEvents = this.databaseSession.queryEmitter.onPatchPre.hasSubscriptions() || this.databaseSession.queryEmitter.onPatchPost.hasSubscriptions();
        if (!hasEvents) {
            query = this.onQueryResolve(query);
            await this.resolver.patch(query.model, changes, patchResult);
            return patchResult;
        }
        const event = new QueryDatabasePatchEvent(this.databaseSession, this.classSchema, query, changes, patchResult);
        if (this.databaseSession.queryEmitter.onPatchPre.hasSubscriptions()) {
            await this.databaseSession.queryEmitter.onPatchPre.emit(event);
            if (event.stopped)
                return patchResult;
        }
        for (const field of event.returning) {
            if (!event.query.model.returning.includes(field))
                event.query.model.returning.push(field);
        }
        //whe need to use event.query in case someone overwrite it
        query = this.onQueryResolve(query);
        await event.query.resolver.patch(event.query.model, changes, patchResult);
        if (query.model.withIdentityMap) {
            const pkHashGenerator = getSimplePrimaryKeyHashGenerator(this.classSchema);
            for (let i = 0; i < patchResult.primaryKeys.length; i++) {
                const item = this.databaseSession.identityMap.getByHash(this.classSchema, pkHashGenerator(patchResult.primaryKeys[i]));
                if (!item)
                    continue;
                if (changes.$set)
                    for (const name in changes.$set) {
                        item[name] = changes.$set[name];
                    }
                for (const name in patchResult.returning) {
                    item[name] = patchResult.returning[name][i];
                }
            }
        }
        if (this.databaseSession.queryEmitter.onPatchPost.hasSubscriptions()) {
            await this.databaseSession.queryEmitter.onPatchPost.emit(event);
            if (event.stopped)
                return patchResult;
        }
        return patchResult;
    }
    async has() {
        return await this.count() > 0;
    }
    async ids(singleKey = false) {
        const pks = this.classSchema.getPrimaryFields().map(v => v.name);
        if (singleKey && pks.length > 1) {
            throw new Error(`Entity ${this.classSchema.getClassName()} has more than one primary key`);
        }
        if (singleKey) {
            const pkName = pks[0];
            return (await this.clone().select(...pks).find()).map(v => v[pkName]);
        }
        return await this.clone().select(...pks).find();
    }
    async findField(name) {
        const items = await this.select(name).find();
        return items.map(v => v[name]);
    }
    async findOneField(name) {
        const item = await this.select(name).findOne();
        return item[name];
    }
    async findOneFieldOrUndefined(name) {
        const item = await this.select(name).findOneOrUndefined();
        if (item)
            return item[name];
        return;
    }
}
export class JoinDatabaseQuery extends BaseQuery {
    constructor(foreignClassSchema, parentQuery, field) {
        super(foreignClassSchema);
        this.foreignClassSchema = foreignClassSchema;
        this.parentQuery = parentQuery;
        this.field = field;
    }
    clone(parentQuery) {
        const c = super.clone();
        c.parentQuery = parentQuery || this.parentQuery;
        c.field = this.field;
        return c;
    }
    end() {
        if (!this.parentQuery)
            throw new Error('Join has no parent query');
        if (!this.field)
            throw new Error('Join has no field');
        //the parentQuery has not the updated JoinDatabaseQuery stuff, we need to move it now to there
        this.parentQuery.getJoin(this.field).model = this.model;
        return this.parentQuery;
    }
}
//# sourceMappingURL=query.js.map