"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const type_1 = require("@deepkit/type");
const globals_1 = require("@jest/globals");
require("reflect-metadata");
const model_1 = require("../src/model");
const client_direct_1 = require("../src/client/client-direct");
const entity_state_1 = require("../src/client/entity-state");
const decorators_1 = require("../src/decorators");
const kernel_1 = require("../src/server/kernel");
globals_1.test('EntitySubjectStore multi', () => {
    let MyModel = class MyModel {
        constructor(id = 0) {
            this.id = id;
            this.version = 0;
        }
    };
    __decorate([
        type_1.t,
        __metadata("design:type", Number)
    ], MyModel.prototype, "version", void 0);
    MyModel = __decorate([
        __param(0, type_1.t),
        __metadata("design:paramtypes", [Number])
    ], MyModel);
    const store = new entity_state_1.EntitySubjectStore(type_1.getClassSchema(MyModel));
    const m1 = new MyModel(1);
    store.register(m1);
    globals_1.expect(store.isRegistered(1)).toBe(true);
    const fork1 = store.createFork(1);
    const fork2 = store.createFork(1);
    const fork3 = store.createFork(1);
    globals_1.expect(fork1.value).toBe(m1);
    globals_1.expect(fork2.value).toBe(m1);
    globals_1.expect(fork3.value).toBe(m1);
    globals_1.expect(store.getForkCount(1)).toBe(3);
    fork3.unsubscribe();
    globals_1.expect(store.getForkCount(1)).toBe(2);
    const m2 = new MyModel(1);
    store.onSet(1, m2);
    globals_1.expect(fork1.value).toBe(m2);
    globals_1.expect(fork2.value).toBe(m2);
    globals_1.expect(fork3.value).toBe(m1); //fork3 is unsubscribed, so it doesnt get the update
    fork2.unsubscribe();
    fork1.unsubscribe();
    globals_1.expect(store.isRegistered(1)).toBe(false);
});
globals_1.test('controller', async () => {
    class Config {
        constructor() {
            this.timeout = 0;
            this.logs = true;
        }
    }
    __decorate([
        type_1.t,
        __metadata("design:type", Number)
    ], Config.prototype, "timeout", void 0);
    __decorate([
        type_1.t,
        __metadata("design:type", Boolean)
    ], Config.prototype, "logs", void 0);
    let MyModel = class MyModel {
        constructor(id) {
            this.id = id;
            this.version = 0;
            this.title = 'foo';
            this.config = new Config;
        }
    };
    __decorate([
        type_1.t,
        __metadata("design:type", Number)
    ], MyModel.prototype, "version", void 0);
    __decorate([
        type_1.t,
        __metadata("design:type", String)
    ], MyModel.prototype, "title", void 0);
    __decorate([
        type_1.t,
        __metadata("design:type", Config)
    ], MyModel.prototype, "config", void 0);
    MyModel = __decorate([
        type_1.entity.name('collection/simple/model'),
        __param(0, type_1.t),
        __metadata("design:paramtypes", [Number])
    ], MyModel);
    class Controller {
        constructor(connection) {
            this.connection = connection;
        }
        async getModel(id) {
            const model = new MyModel(id);
            model.title = 'foo';
            const subject = new model_1.EntitySubject(model);
            return subject;
        }
        async getModelWithChange(id) {
            const model = new MyModel(id);
            const subject = new model_1.EntitySubject(model);
            setTimeout(() => {
                this.connection.createMessageBuilder()
                    .composite(model_1.RpcTypes.Entity)
                    .add(model_1.RpcTypes.EntityPatch, model_1.rpcEntityPatch, {
                    entityName: type_1.getClassSchema(MyModel).getName(),
                    id: model.id,
                    version: model.version + 1,
                    patch: { $set: { title: 'bar', config: type_1.plainToClass(Config, { timeout: 44, logs: false }) } }
                }).send();
            }, 10);
            return subject;
        }
    }
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number]),
        __metadata("design:returntype", Promise)
    ], Controller.prototype, "getModel", null);
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number]),
        __metadata("design:returntype", Promise)
    ], Controller.prototype, "getModelWithChange", null);
    const kernel = new class extends kernel_1.RpcKernel {
        createConnection(writer) {
            let connection;
            const injector = {
                get(classType) {
                    return new classType(connection);
                }
            };
            connection = new kernel_1.RpcKernelConnection(writer, this.connections, this.controllers, this.security, injector || this.injector, this.peerExchange);
            return connection;
        }
    };
    kernel.registerController('myController', Controller);
    const client = new client_direct_1.DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const m1 = await controller.getModel(55);
        globals_1.expect(m1).toBeInstanceOf(model_1.EntitySubject);
        globals_1.expect(m1.value).toBeInstanceOf(MyModel);
        globals_1.expect(m1.value.id).toBe(55);
        globals_1.expect(m1.value.title).toBe('foo');
        const m2 = await controller.getModel(55);
        globals_1.expect(m2).toBeInstanceOf(model_1.EntitySubject);
        globals_1.expect(m2.value).toBeInstanceOf(MyModel);
        globals_1.expect(m2.value.id).toBe(55);
        globals_1.expect(m2.value.title).toBe('foo');
        globals_1.expect(m2.value).toBe(m1.value);
        globals_1.expect(m2).not.toBe(m1);
        const m3 = await controller.getModel(1231325);
        globals_1.expect(m3).toBeInstanceOf(model_1.EntitySubject);
        globals_1.expect(m3.value).toBeInstanceOf(MyModel);
        globals_1.expect(m3.value).not.toBe(m1.value);
        globals_1.expect(m3.value.title).toBe('foo');
        globals_1.expect(m3.value.id).toBe(1231325);
    }
    {
        const m1 = await controller.getModelWithChange(55);
        globals_1.expect(m1).toBeInstanceOf(model_1.EntitySubject);
        globals_1.expect(m1.value).toBeInstanceOf(MyModel);
        globals_1.expect(m1.value.id).toBe(55);
        globals_1.expect(m1.value.title).toBe('foo');
        globals_1.expect(m1.value.config).toBeInstanceOf(Config);
        globals_1.expect(m1.value.config.timeout).toBe(0);
        globals_1.expect(m1.value.config.logs).toBe(true);
        await m1.nextStateChange;
        globals_1.expect(m1.value.title).toBe('bar');
        globals_1.expect(m1.value.config).toBeInstanceOf(Config);
        globals_1.expect(m1.value.config.timeout).toBe(44);
        globals_1.expect(m1.value.config.logs).toBe(false);
    }
});
//# sourceMappingURL=entity-state.spec.js.map