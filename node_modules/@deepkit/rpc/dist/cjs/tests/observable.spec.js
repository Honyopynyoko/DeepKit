"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@deepkit/core");
const type_1 = require("@deepkit/type");
const globals_1 = require("@jest/globals");
require("reflect-metadata");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const client_direct_1 = require("../src/client/client-direct");
const decorators_1 = require("../src/decorators");
const kernel_1 = require("../src/server/kernel");
globals_1.test('observable basics', async () => {
    let MyModel = class MyModel {
        constructor(name) {
            this.name = name;
        }
    };
    MyModel = __decorate([
        type_1.entity.name('model'),
        __param(0, type_1.t),
        __metadata("design:paramtypes", [String])
    ], MyModel);
    class Controller {
        strings() {
            return new rxjs_1.Observable((observer) => {
                observer.next('first');
                observer.next('second');
                observer.next('third');
                observer.complete();
            });
        }
        errors() {
            return new rxjs_1.Observable((observer) => {
                observer.error(new Error('Jupp'));
            });
        }
        myModel() {
            return new rxjs_1.Observable((observer) => {
                observer.next(new MyModel('Peter'));
                observer.complete();
            });
        }
    }
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", rxjs_1.Observable)
    ], Controller.prototype, "strings", null);
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", rxjs_1.Observable)
    ], Controller.prototype, "errors", null);
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", rxjs_1.Observable)
    ], Controller.prototype, "myModel", null);
    const kernel = new kernel_1.RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new client_direct_1.DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const o = await controller.strings();
        globals_1.expect(o).toBeInstanceOf(rxjs_1.Observable);
        const firstValue = await o.pipe(operators_1.first()).toPromise();
        globals_1.expect(firstValue).toBe('first');
        const secondValue = await o.pipe(operators_1.take(2)).toPromise();
        globals_1.expect(secondValue).toBe('second');
        const thirdValue = await o.pipe(operators_1.take(3)).toPromise();
        globals_1.expect(thirdValue).toBe('third');
        const lastValue = await o.toPromise();
        globals_1.expect(lastValue).toBe('third');
    }
    {
        const o = await controller.errors();
        globals_1.expect(o).toBeInstanceOf(rxjs_1.Observable);
        await globals_1.expect(o.toPromise()).rejects.toThrowError(Error);
        await globals_1.expect(o.toPromise()).rejects.toThrowError('Jupp');
    }
    {
        const o = await controller.myModel();
        globals_1.expect(o).toBeInstanceOf(rxjs_1.Observable);
        const model = await o.toPromise();
        globals_1.expect(model).toBeInstanceOf(MyModel);
        globals_1.expect(model.name).toBe('Peter');
    }
    {
        await globals_1.expect(controller.unknownMethod()).rejects.toThrowError('Action unknown unknownMethod');
    }
});
globals_1.test('Subject', async () => {
    class Controller {
        strings() {
            const subject = new rxjs_1.Subject();
            (async () => {
                await core_1.sleep(0.1);
                subject.next('first');
                subject.next('second');
                subject.complete();
            })();
            return subject;
        }
    }
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", rxjs_1.Subject)
    ], Controller.prototype, "strings", null);
    const kernel = new kernel_1.RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new client_direct_1.DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const o = await controller.strings();
        globals_1.expect(o).toBeInstanceOf(rxjs_1.Subject);
        const lastValue = await o.toPromise();
        globals_1.expect(lastValue).toBe('second');
    }
});
globals_1.test('subject unsubscribes automatically when connection closes', async () => {
    let unsubscribed = false;
    class Controller {
        strings() {
            const subject = new rxjs_1.Subject();
            subject.subscribe().add(() => {
                unsubscribed = true;
            });
            return subject;
        }
    }
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", rxjs_1.Subject)
    ], Controller.prototype, "strings", null);
    const kernel = new kernel_1.RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new client_direct_1.DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const o = await controller.strings();
        globals_1.expect(o).toBeInstanceOf(rxjs_1.Subject);
        globals_1.expect(unsubscribed).toBe(false);
        o.unsubscribe();
        await core_1.sleep(0);
        globals_1.expect(unsubscribed).toBe(true);
    }
    {
        unsubscribed = false;
        const o = await controller.strings();
        globals_1.expect(o).toBeInstanceOf(rxjs_1.Subject);
        globals_1.expect(unsubscribed).toBe(false);
        client.disconnect();
        await core_1.sleep(0);
        globals_1.expect(unsubscribed).toBe(true);
    }
});
globals_1.test('observable unsubscribes automatically when connection closes', async () => {
    let unsubscribed = false;
    class Controller {
        strings() {
            return new rxjs_1.Observable((observer) => {
                return {
                    unsubscribe() {
                        unsubscribed = true;
                    }
                };
            });
        }
    }
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", rxjs_1.Observable)
    ], Controller.prototype, "strings", null);
    const kernel = new kernel_1.RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new client_direct_1.DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const o = (await controller.strings()).subscribe(() => { });
        globals_1.expect(o).toBeInstanceOf(rxjs_1.Subscription);
        globals_1.expect(unsubscribed).toBe(false);
        o.unsubscribe();
        await core_1.sleep(0);
        globals_1.expect(unsubscribed).toBe(true);
    }
    {
        unsubscribed = false;
        const o = (await controller.strings()).subscribe(() => { });
        globals_1.expect(o).toBeInstanceOf(rxjs_1.Subscription);
        globals_1.expect(unsubscribed).toBe(false);
        client.disconnect();
        await core_1.sleep(0);
        globals_1.expect(unsubscribed).toBe(true);
    }
});
globals_1.test('observable different next type', async () => {
    class WrongModel {
        constructor() {
            this.id = 0;
        }
    }
    __decorate([
        type_1.t,
        __metadata("design:type", Number)
    ], WrongModel.prototype, "id", void 0);
    let MyModel = class MyModel {
        constructor() {
            this.id = 0;
        }
    };
    __decorate([
        type_1.t,
        __metadata("design:type", Number)
    ], MyModel.prototype, "id", void 0);
    MyModel = __decorate([
        type_1.entity.name('observable/differentytype')
    ], MyModel);
    class Controller {
        constructor() {
            this.subject = new rxjs_1.BehaviorSubject(undefined);
        }
        getSubject() {
            if (this.subject)
                this.subject.complete();
            this.subject = new rxjs_1.BehaviorSubject(undefined);
            return this.subject;
        }
        triggerCorrect() {
            this.subject.next(type_1.plainToClass(MyModel, { id: 2 }));
        }
        triggerPlain() {
            this.subject.next({ id: 2 });
        }
        triggerWrongModel() {
            this.subject.next(new WrongModel());
        }
    }
    __decorate([
        decorators_1.rpc.action(),
        type_1.t.generic(MyModel),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", rxjs_1.BehaviorSubject)
    ], Controller.prototype, "getSubject", null);
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "triggerCorrect", null);
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "triggerPlain", null);
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "triggerWrongModel", null);
    const kernel = new kernel_1.RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new client_direct_1.DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const subject = await controller.getSubject();
        globals_1.expect(subject.value).toBe(undefined);
        await controller.triggerCorrect();
        globals_1.expect(subject.value).toBeInstanceOf(MyModel);
        globals_1.expect(subject.value).toEqual({ id: 2 });
    }
    {
        const subject = await controller.getSubject();
        globals_1.expect(subject.value).toBe(undefined);
        await controller.triggerPlain();
        globals_1.expect(subject.value).toEqual(undefined);
    }
    {
        const subject = await controller.getSubject();
        globals_1.expect(subject.value).toBe(undefined);
        await controller.triggerWrongModel();
        globals_1.expect(subject.value).toEqual(undefined);
    }
});
globals_1.test('Behavior', async () => {
    class Controller {
        initial() {
            return new rxjs_1.BehaviorSubject('initial');
        }
        strings() {
            const subject = new rxjs_1.BehaviorSubject('initial');
            (async () => {
                await core_1.sleep(0.1);
                subject.next('first');
                subject.next('second');
                subject.complete();
            })();
            return subject;
        }
    }
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", rxjs_1.BehaviorSubject)
    ], Controller.prototype, "initial", null);
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", rxjs_1.BehaviorSubject)
    ], Controller.prototype, "strings", null);
    const kernel = new kernel_1.RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new client_direct_1.DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const o = await controller.initial();
        globals_1.expect(o).toBeInstanceOf(rxjs_1.BehaviorSubject);
        globals_1.expect(o.getValue()).toBe('initial');
    }
    {
        const o = await controller.strings();
        globals_1.expect(o).toBeInstanceOf(rxjs_1.BehaviorSubject);
        const lastValue = await o.toPromise();
        globals_1.expect(lastValue).toBe('second');
    }
});
globals_1.test('make sure base assumption about Subject is right', async () => {
    {
        const subject = new rxjs_1.Subject();
        let teardown = false;
        subject.subscribe().add(() => {
            teardown = true;
        });
        subject.unsubscribe();
        globals_1.expect(teardown).toBe(false);
    }
    {
        const subject = new rxjs_1.Subject();
        let teardown = false;
        subject.subscribe().add(() => {
            teardown = true;
        });
        subject.complete();
        globals_1.expect(teardown).toBe(true);
    }
});
globals_1.test('observable complete', async () => {
    let active = false;
    class Controller {
        numberGenerator(max) {
            return new rxjs_1.Observable((observer) => {
                let done = false;
                let i = 0;
                active = true;
                (async () => {
                    while (!done && i <= max) {
                        observer.next(i++);
                        await core_1.sleep(0.02);
                    }
                    active = false;
                    observer.complete();
                })();
                return {
                    unsubscribe() {
                        done = true;
                        active = false;
                    }
                };
            });
        }
    }
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number]),
        __metadata("design:returntype", rxjs_1.Observable)
    ], Controller.prototype, "numberGenerator", null);
    const kernel = new kernel_1.RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new client_direct_1.DirectClient(kernel);
    const controller = client.controller('myController');
    {
        //make sure the assumption that unsubscribe() is even called when the observer calls complete() himself.
        let unsubscribedCalled = false;
        const o = new rxjs_1.Observable((observer) => {
            unsubscribedCalled = false;
            observer.next(1);
            observer.complete();
            return {
                unsubscribe() {
                    unsubscribedCalled = true;
                }
            };
        });
        {
            const lastValue = await o.toPromise();
            globals_1.expect(lastValue).toBe(1);
            globals_1.expect(unsubscribedCalled).toBe(true);
        }
        {
            const lastValue = await new Promise((resolve) => {
                let l = undefined;
                o.subscribe((value) => {
                    l = value;
                }, () => { }, () => {
                    resolve(l);
                });
            });
            globals_1.expect(lastValue).toBe(1);
            globals_1.expect(unsubscribedCalled).toBe(true);
        }
    }
    {
        const o = await controller.numberGenerator(10);
        globals_1.expect(o).toBeInstanceOf(rxjs_1.Observable);
        const lastValue = await o.toPromise();
        globals_1.expect(lastValue).toBe(10);
        globals_1.expect(active).toBe(false);
    }
    {
        const o = await controller.numberGenerator(10000);
        globals_1.expect(o).toBeInstanceOf(rxjs_1.Observable);
        const complete = new rxjs_1.BehaviorSubject(0);
        const sub = o.subscribe(complete);
        await core_1.sleep(0.1); //provide some time to generate some numbers
        globals_1.expect(active).toBe(true);
        sub.unsubscribe(); //this calls unsubscribe() in the observer. We don't know when this happens from client PoV
        await core_1.sleep(0.01); //provide some time to handle it
        globals_1.expect(active).toBe(false);
        globals_1.expect(complete.value).toBeGreaterThan(1);
        globals_1.expect(complete.value).toBeLessThan(10000);
    }
});
//# sourceMappingURL=observable.spec.js.map