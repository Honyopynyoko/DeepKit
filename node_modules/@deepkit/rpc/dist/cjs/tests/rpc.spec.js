"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const type_1 = require("@deepkit/type");
const globals_1 = require("@jest/globals");
require("reflect-metadata");
const writer_1 = require("../src/writer");
const client_direct_1 = require("../src/client/client-direct");
const decorators_1 = require("../src/decorators");
const protocol_1 = require("../src/protocol");
const kernel_1 = require("../src/server/kernel");
const model_1 = require("../src/model");
const bson_1 = require("@deepkit/bson");
globals_1.test('readUint32LE', () => {
    {
        const writer = new bson_1.Writer(bson_1.createBuffer(8));
        writer.writeUint32(545);
        const view = new DataView(writer.buffer.buffer, writer.buffer.byteOffset);
        globals_1.expect(view.getUint32(0, true)).toBe(545);
        globals_1.expect(protocol_1.readUint32LE(writer.buffer)).toBe(545);
    }
    {
        const writer = new bson_1.Writer(bson_1.createBuffer(8));
        writer.writeUint32(94388585);
        globals_1.expect(protocol_1.readUint32LE(writer.buffer)).toBe(94388585);
    }
});
globals_1.test('protocol basics', () => {
    const schema = type_1.t.schema({
        name: type_1.t.string
    });
    {
        const message = protocol_1.createRpcMessage(1024, 123);
        const parsed = protocol_1.readRpcMessage(message);
        globals_1.expect(parsed.id).toBe(1024);
        globals_1.expect(parsed.type).toBe(123);
        globals_1.expect(parsed.composite).toBe(false);
        globals_1.expect(parsed.routeType).toBe(0 /* client */);
        globals_1.expect(parsed.bodySize).toBe(0);
        globals_1.expect(() => parsed.parseBody(schema)).toThrowError('no body');
    }
    {
        const message = protocol_1.createRpcMessage(1024, 130, schema, { name: 'foo' });
        const parsed = protocol_1.readRpcMessage(message);
        globals_1.expect(parsed.id).toBe(1024);
        globals_1.expect(parsed.type).toBe(130);
        globals_1.expect(parsed.composite).toBe(false);
        globals_1.expect(parsed.routeType).toBe(0 /* client */);
        const body = parsed.parseBody(schema);
        globals_1.expect(body.name).toBe('foo');
    }
    {
        const message = protocol_1.createRpcMessage(1024, 130, schema, { name: 'foo' }, 1 /* server */);
        const parsed = protocol_1.readRpcMessage(message);
        globals_1.expect(parsed.id).toBe(1024);
        globals_1.expect(parsed.type).toBe(130);
        globals_1.expect(parsed.composite).toBe(false);
        globals_1.expect(parsed.routeType).toBe(1 /* server */);
    }
    {
        const peerSource = Buffer.alloc(16);
        peerSource[0] = 22;
        const message = protocol_1.createRpcMessagePeer(1024, 130, peerSource, 'myPeer', schema, { name: 'foo' });
        const parsed = protocol_1.readRpcMessage(message);
        globals_1.expect(parsed.id).toBe(1024);
        globals_1.expect(parsed.type).toBe(130);
        globals_1.expect(parsed.composite).toBe(false);
        globals_1.expect(parsed.getPeerId()).toBe('myPeer');
        const body = parsed.parseBody(schema);
        globals_1.expect(body.name).toBe('foo');
    }
    {
        const source = Buffer.alloc(16);
        source[0] = 16;
        const destination = Buffer.alloc(16);
        destination[0] = 20;
        const message = protocol_1.createRpcMessageSourceDest(1024, 130, source, destination, schema, { name: 'foo' });
        const parsed = protocol_1.readRpcMessage(message);
        globals_1.expect(parsed.id).toBe(1024);
        globals_1.expect(parsed.type).toBe(130);
        globals_1.expect(parsed.composite).toBe(false);
        globals_1.expect(parsed.getSource()[0]).toBe(16);
        globals_1.expect(parsed.getDestination()[0]).toBe(20);
        const body = parsed.parseBody(schema);
        globals_1.expect(body.name).toBe('foo');
    }
});
globals_1.test('protocol composite', () => {
    const schema = type_1.t.schema({
        name: type_1.t.string
    });
    {
        const message = protocol_1.createRpcCompositeMessage(1024, 33, [{ type: 4, schema, body: { name: 'foo' } }]);
        const parsed = protocol_1.readRpcMessage(message);
        globals_1.expect(parsed.id).toBe(1024);
        globals_1.expect(parsed.type).toBe(33);
        globals_1.expect(parsed.composite).toBe(true);
        globals_1.expect(parsed.routeType).toBe(0 /* client */);
        globals_1.expect(() => parsed.parseBody(schema)).toThrow('Composite message can not be read directly');
        const messages = parsed.getBodies();
        globals_1.expect(messages.length).toBe(1);
        globals_1.expect(messages[0].type).toBe(4);
        globals_1.expect(messages[0].bodySize).toBeGreaterThan(10);
        globals_1.expect(messages[0].parseBody(schema).name).toBe('foo');
    }
    {
        const message = protocol_1.createRpcCompositeMessage(1024, 5, [{ type: 4 }, { type: 5, schema, body: { name: 'foo' } }]);
        const parsed = protocol_1.readRpcMessage(message);
        globals_1.expect(parsed.id).toBe(1024);
        globals_1.expect(parsed.type).toBe(5);
        globals_1.expect(parsed.composite).toBe(true);
        globals_1.expect(parsed.routeType).toBe(0 /* client */);
        globals_1.expect(() => parsed.parseBody(schema)).toThrow('Composite message can not be read directly');
        const messages = parsed.getBodies();
        globals_1.expect(messages.length).toBe(2);
        globals_1.expect(messages[0].type).toBe(4);
        globals_1.expect(messages[0].bodySize).toBe(0);
        globals_1.expect(() => messages[0].parseBody(schema)).toThrow('no body');
        globals_1.expect(messages[1].type).toBe(5);
        globals_1.expect(messages[1].bodySize).toBeGreaterThan(10);
        globals_1.expect(messages[1].parseBody(schema).name).toBe('foo');
    }
    {
        const message = protocol_1.createRpcCompositeMessage(1024, 6, [{ type: 4, schema, body: { name: 'foo' } }, {
                type: 12,
                schema,
                body: { name: 'bar' }
            }]);
        const parsed = protocol_1.readRpcMessage(message);
        globals_1.expect(parsed.id).toBe(1024);
        globals_1.expect(parsed.type).toBe(6);
        globals_1.expect(parsed.composite).toBe(true);
        globals_1.expect(parsed.routeType).toBe(0 /* client */);
        globals_1.expect(() => parsed.parseBody(schema)).toThrow('Composite message can not be read directly');
        const messages = parsed.getBodies();
        globals_1.expect(messages.length).toBe(2);
        globals_1.expect(messages[0].type).toBe(4);
        globals_1.expect(messages[0].parseBody(schema).name).toBe('foo');
        globals_1.expect(messages[1].type).toBe(12);
        globals_1.expect(messages[1].parseBody(schema).name).toBe('bar');
    }
    {
        const source = Buffer.alloc(16);
        source[0] = 16;
        const destination = Buffer.alloc(16);
        destination[0] = 20;
        const message = protocol_1.createRpcCompositeMessageSourceDest(1024, source, destination, 55, [{
                type: 4,
                schema,
                body: { name: 'foo' }
            }, { type: 12, schema, body: { name: 'bar' } }]);
        const parsed = protocol_1.readRpcMessage(message);
        globals_1.expect(parsed.id).toBe(1024);
        globals_1.expect(parsed.type).toBe(55);
        globals_1.expect(parsed.composite).toBe(true);
        globals_1.expect(parsed.routeType).toBe(2 /* sourceDest */);
        globals_1.expect(parsed.getSource()[0]).toBe(16);
        globals_1.expect(parsed.getDestination()[0]).toBe(20);
        globals_1.expect(() => parsed.parseBody(schema)).toThrow('Composite message can not be read directly');
        const messages = parsed.getBodies();
        globals_1.expect(messages.length).toBe(2);
        globals_1.expect(messages[0].type).toBe(4);
        globals_1.expect(messages[0].parseBody(schema).name).toBe('foo');
        globals_1.expect(messages[1].type).toBe(12);
        globals_1.expect(messages[1].parseBody(schema).name).toBe('bar');
    }
});
globals_1.test('rpc kernel handshake', async () => {
    const kernel = new kernel_1.RpcKernel();
    const client = new client_direct_1.DirectClient(kernel);
    await client.connect();
    globals_1.expect(client.getId()).toBeInstanceOf(Uint8Array);
    globals_1.expect(client.getId().byteLength).toBe(16);
});
globals_1.test('rpc kernel', async () => {
    class Controller {
        action(value) {
            return value;
        }
        sum(a, b) {
            return a + b;
        }
    }
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", String)
    ], Controller.prototype, "action", null);
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number, Number]),
        __metadata("design:returntype", Number)
    ], Controller.prototype, "sum", null);
    const kernel = new kernel_1.RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new client_direct_1.DirectClient(kernel);
    const controller = client.controller('myController');
    globals_1.expect(await controller.action('foo')).toBe('foo');
    globals_1.expect(await controller.action('foo2')).toBe('foo2');
    globals_1.expect(await controller.action('foo3')).toBe('foo3');
    globals_1.expect(await controller.sum(2, 5)).toBe(7);
    globals_1.expect(await controller.sum(5, 5)).toBe(10);
    globals_1.expect(await controller.sum(10000000, 10000000)).toBe(20000000);
});
globals_1.test('rpc peer', async () => {
    const kernel = new kernel_1.RpcKernel();
    const client1 = new client_direct_1.DirectClient(kernel);
    class Controller {
        action(value) {
            return value;
        }
    }
    __decorate([
        decorators_1.rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", String)
    ], Controller.prototype, "action", null);
    await client1.registerAsPeer('peer1');
    client1.registerPeerController('foo', Controller);
    const client2 = new client_direct_1.DirectClient(kernel);
    const controller = client2.peer('peer1').controller('foo');
    const res = await controller.action('bar');
    globals_1.expect(res).toBe('bar');
});
globals_1.test('message reader', async () => {
    const messages = [];
    const reader = new protocol_1.RpcBufferReader(Array.prototype.push.bind(messages));
    let buffer;
    {
        messages.length = 0;
        buffer = Buffer.alloc(8);
        buffer.writeUInt32LE(8);
        reader.feed(buffer);
        globals_1.expect(reader.emptyBuffer()).toBe(true);
        globals_1.expect(messages.length).toBe(1);
        globals_1.expect(messages[0].readUInt32LE()).toBe(8);
    }
    {
        messages.length = 0;
        buffer = Buffer.alloc(500000);
        buffer.writeUInt32LE(1000000);
        reader.feed(buffer);
        buffer = Buffer.alloc(500000);
        reader.feed(buffer);
        globals_1.expect(reader.emptyBuffer()).toBe(true);
        globals_1.expect(messages.length).toBe(1);
        globals_1.expect(messages[0].readUInt32LE()).toBe(1000000);
    }
    {
        messages.length = 0;
        buffer = Buffer.alloc(0);
        reader.feed(buffer);
        buffer = Buffer.alloc(8);
        buffer.writeUInt32LE(8);
        reader.feed(buffer);
        globals_1.expect(reader.emptyBuffer()).toBe(true);
        globals_1.expect(messages.length).toBe(1);
        globals_1.expect(messages[0].readUInt32LE()).toBe(8);
    }
    {
        messages.length = 0;
        buffer = Buffer.alloc(18);
        buffer.writeUInt32LE(8);
        buffer.writeUInt32LE(10, 8);
        reader.feed(buffer);
        globals_1.expect(reader.emptyBuffer()).toBe(true);
        globals_1.expect(messages.length).toBe(2);
        globals_1.expect(messages[0].readUInt32LE()).toBe(8);
        globals_1.expect(messages[1].readUInt32LE()).toBe(10);
    }
    {
        messages.length = 0;
        buffer = Buffer.alloc(22);
        buffer.writeUInt32LE(8);
        buffer.writeUInt32LE(10, 8);
        buffer.writeUInt32LE(20, 18);
        reader.feed(buffer);
        buffer = Buffer.alloc(16);
        reader.feed(buffer);
        globals_1.expect(reader.emptyBuffer()).toBe(true);
        globals_1.expect(messages.length).toBe(3);
        globals_1.expect(messages[0].readUInt32LE()).toBe(8);
        globals_1.expect(messages[1].readUInt32LE()).toBe(10);
        globals_1.expect(messages[2].readUInt32LE()).toBe(20);
    }
    {
        messages.length = 0;
        buffer = Buffer.alloc(8);
        buffer.writeUInt32LE(8);
        reader.feed(buffer);
        reader.feed(buffer);
        globals_1.expect(reader.emptyBuffer()).toBe(true);
        globals_1.expect(messages.length).toBe(2);
        globals_1.expect(messages[0].readUInt32LE()).toBe(8);
        globals_1.expect(messages[1].readUInt32LE()).toBe(8);
    }
    {
        messages.length = 0;
        buffer = Buffer.alloc(4);
        buffer.writeUInt32LE(8);
        reader.feed(buffer);
        buffer = Buffer.alloc(4);
        reader.feed(buffer);
        globals_1.expect(reader.emptyBuffer()).toBe(true);
        globals_1.expect(messages.length).toBe(1);
        globals_1.expect(messages[0].readUInt32LE()).toBe(8);
    }
    {
        messages.length = 0;
        let buffer = Buffer.alloc(4);
        buffer.writeUInt32LE(30);
        reader.feed(buffer);
        buffer = Buffer.alloc(26);
        reader.feed(buffer);
        buffer = Buffer.alloc(8);
        buffer.writeUInt32LE(8);
        reader.feed(buffer);
        globals_1.expect(reader.emptyBuffer()).toBe(true);
        globals_1.expect(messages.length).toBe(2);
        globals_1.expect(messages[0].readUInt32LE()).toBe(30);
        globals_1.expect(messages[1].readUInt32LE()).toBe(8);
    }
});
globals_1.test('message chunks', async () => {
    const messages = [];
    const reader = new protocol_1.RpcMessageReader(v => messages.push(v));
    const schema = type_1.t.schema({
        v: type_1.t.string,
    });
    const bigString = 'x'.repeat(1000000); //1mb
    const buffers = [];
    const writer = new writer_1.RpcMessageWriter({
        write(b) {
            buffers.push(b);
            reader.feed(protocol_1.createRpcMessage(2, model_1.RpcTypes.ChunkAck)); //confirm chunk, this is done automatically in the kernel
            reader.feed(b); //echo back
        },
        close() { }
    }, reader);
    const message = protocol_1.createRpcMessage(2, model_1.RpcTypes.ResponseActionSimple, schema, { v: bigString });
    await writer.writeFull(message);
    globals_1.expect(buffers.length).toBe(11); //total size is 1_000_025, chunk is 100k, so we have 11 packages
    globals_1.expect(protocol_1.readRpcMessage(buffers[0]).id).toBe(2);
    globals_1.expect(protocol_1.readRpcMessage(buffers[0]).type).toBe(model_1.RpcTypes.Chunk);
    globals_1.expect(protocol_1.readRpcMessage(buffers[10]).id).toBe(2);
    globals_1.expect(protocol_1.readRpcMessage(buffers[10]).type).toBe(model_1.RpcTypes.Chunk);
    globals_1.expect(messages.length).toBe(1);
    const lastReceivedMessage = messages[0];
    globals_1.expect(lastReceivedMessage.id).toBe(2);
    globals_1.expect(lastReceivedMessage.type).toBe(model_1.RpcTypes.ResponseActionSimple);
    const body = lastReceivedMessage.parseBody(schema);
    globals_1.expect(body.v).toBe(bigString);
});
globals_1.test('message progress', async () => {
    const messages = [];
    const reader = new protocol_1.RpcMessageReader(v => messages.push(v));
    const schema = type_1.t.schema({
        v: type_1.t.string,
    });
    const bigString = 'x'.repeat(1000000); //1mb
    const writer = new writer_1.RpcMessageWriter({
        write(b) {
            reader.feed(protocol_1.createRpcMessage(2, model_1.RpcTypes.ChunkAck)); //confirm chunk, this is done automatically in the kernel
            reader.feed(b); //echo
        },
        close() {
        }
    }, reader);
    const message = protocol_1.createRpcMessage(2, model_1.RpcTypes.ResponseActionSimple, schema, { v: bigString });
    const progress = new writer_1.Progress();
    reader.registerProgress(2, progress.download);
    await writer.writeFull(message, progress.upload);
    await progress.upload.finished;
    globals_1.expect(progress.upload.done).toBe(true);
    globals_1.expect(progress.upload.isStopped).toBe(true);
    globals_1.expect(progress.upload.current).toBe(1000025);
    globals_1.expect(progress.upload.total).toBe(1000025);
    globals_1.expect(progress.upload.stats).toBe(11); //since 11 packages
    await progress.download.finished;
    globals_1.expect(progress.download.done).toBe(true);
    globals_1.expect(progress.download.isStopped).toBe(true);
    globals_1.expect(progress.download.current).toBe(1000025);
    globals_1.expect(progress.download.total).toBe(1000025);
    globals_1.expect(progress.download.stats).toBe(11); //since 11 packages
    const lastReceivedMessage = messages[0];
    const body = lastReceivedMessage.parseBody(schema);
    globals_1.expect(body.v).toBe(bigString);
});
//# sourceMappingURL=rpc.spec.js.map