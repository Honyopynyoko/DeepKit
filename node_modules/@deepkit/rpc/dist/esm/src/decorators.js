/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { createClassDecoratorContext, createPropertyDecoratorContext, getClassSchema, mergeDecorator, } from '@deepkit/type';
class RpcController {
    constructor() {
        this.actions = new Map();
    }
    getPath() {
        return this.definition ? this.definition.path : this.name || '';
    }
}
export class RpcAction {
    constructor() {
        this.groups = [];
    }
}
class RpcClass {
    constructor() {
        this.t = new RpcController;
    }
    controller(nameOrDefinition) {
        if ('string' === typeof nameOrDefinition) {
            this.t.name = nameOrDefinition;
        }
        else {
            this.t.definition = nameOrDefinition;
        }
    }
    addAction(name, action) {
        this.t.actions.set(name, action);
    }
}
export const rpcClass = createClassDecoratorContext(RpcClass);
class RpcProperty {
    constructor() {
        this.t = new RpcAction;
    }
    onDecorator(classType, property) {
        this.t.name = property;
        this.t.classType = classType;
        rpcClass.addAction(property, this.t)(classType);
    }
    action() {
    }
    group(...groups) {
        this.t.groups.push(...groups);
    }
}
export const rpcProperty = createPropertyDecoratorContext(RpcProperty);
export const rpc = mergeDecorator(rpcClass, rpcProperty);
export function getActionParameters(target, method) {
    return getClassSchema(target).getMethodProperties(method);
}
export function getActions(target) {
    var _a, _b;
    return (_b = (_a = rpcClass._fetch(target)) === null || _a === void 0 ? void 0 : _a.actions) !== null && _b !== void 0 ? _b : new Map;
}
//# sourceMappingURL=decorators.js.map