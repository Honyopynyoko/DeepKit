var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { entity, getClassSchema, plainToClass, t } from '@deepkit/type';
import { expect, test } from '@jest/globals';
import 'reflect-metadata';
import { EntitySubject, rpcEntityPatch, RpcTypes } from '../src/model';
import { DirectClient } from '../src/client/client-direct';
import { EntitySubjectStore } from '../src/client/entity-state';
import { rpc } from '../src/decorators';
import { RpcKernel, RpcKernelConnection } from '../src/server/kernel';
test('EntitySubjectStore multi', () => {
    let MyModel = class MyModel {
        constructor(id = 0) {
            this.id = id;
            this.version = 0;
        }
    };
    __decorate([
        t,
        __metadata("design:type", Number)
    ], MyModel.prototype, "version", void 0);
    MyModel = __decorate([
        __param(0, t),
        __metadata("design:paramtypes", [Number])
    ], MyModel);
    const store = new EntitySubjectStore(getClassSchema(MyModel));
    const m1 = new MyModel(1);
    store.register(m1);
    expect(store.isRegistered(1)).toBe(true);
    const fork1 = store.createFork(1);
    const fork2 = store.createFork(1);
    const fork3 = store.createFork(1);
    expect(fork1.value).toBe(m1);
    expect(fork2.value).toBe(m1);
    expect(fork3.value).toBe(m1);
    expect(store.getForkCount(1)).toBe(3);
    fork3.unsubscribe();
    expect(store.getForkCount(1)).toBe(2);
    const m2 = new MyModel(1);
    store.onSet(1, m2);
    expect(fork1.value).toBe(m2);
    expect(fork2.value).toBe(m2);
    expect(fork3.value).toBe(m1); //fork3 is unsubscribed, so it doesnt get the update
    fork2.unsubscribe();
    fork1.unsubscribe();
    expect(store.isRegistered(1)).toBe(false);
});
test('controller', async () => {
    class Config {
        constructor() {
            this.timeout = 0;
            this.logs = true;
        }
    }
    __decorate([
        t,
        __metadata("design:type", Number)
    ], Config.prototype, "timeout", void 0);
    __decorate([
        t,
        __metadata("design:type", Boolean)
    ], Config.prototype, "logs", void 0);
    let MyModel = class MyModel {
        constructor(id) {
            this.id = id;
            this.version = 0;
            this.title = 'foo';
            this.config = new Config;
        }
    };
    __decorate([
        t,
        __metadata("design:type", Number)
    ], MyModel.prototype, "version", void 0);
    __decorate([
        t,
        __metadata("design:type", String)
    ], MyModel.prototype, "title", void 0);
    __decorate([
        t,
        __metadata("design:type", Config)
    ], MyModel.prototype, "config", void 0);
    MyModel = __decorate([
        entity.name('collection/simple/model'),
        __param(0, t),
        __metadata("design:paramtypes", [Number])
    ], MyModel);
    class Controller {
        constructor(connection) {
            this.connection = connection;
        }
        async getModel(id) {
            const model = new MyModel(id);
            model.title = 'foo';
            const subject = new EntitySubject(model);
            return subject;
        }
        async getModelWithChange(id) {
            const model = new MyModel(id);
            const subject = new EntitySubject(model);
            setTimeout(() => {
                this.connection.createMessageBuilder()
                    .composite(RpcTypes.Entity)
                    .add(RpcTypes.EntityPatch, rpcEntityPatch, {
                    entityName: getClassSchema(MyModel).getName(),
                    id: model.id,
                    version: model.version + 1,
                    patch: { $set: { title: 'bar', config: plainToClass(Config, { timeout: 44, logs: false }) } }
                }).send();
            }, 10);
            return subject;
        }
    }
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number]),
        __metadata("design:returntype", Promise)
    ], Controller.prototype, "getModel", null);
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number]),
        __metadata("design:returntype", Promise)
    ], Controller.prototype, "getModelWithChange", null);
    const kernel = new class extends RpcKernel {
        createConnection(writer) {
            let connection;
            const injector = {
                get(classType) {
                    return new classType(connection);
                }
            };
            connection = new RpcKernelConnection(writer, this.connections, this.controllers, this.security, injector || this.injector, this.peerExchange);
            return connection;
        }
    };
    kernel.registerController('myController', Controller);
    const client = new DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const m1 = await controller.getModel(55);
        expect(m1).toBeInstanceOf(EntitySubject);
        expect(m1.value).toBeInstanceOf(MyModel);
        expect(m1.value.id).toBe(55);
        expect(m1.value.title).toBe('foo');
        const m2 = await controller.getModel(55);
        expect(m2).toBeInstanceOf(EntitySubject);
        expect(m2.value).toBeInstanceOf(MyModel);
        expect(m2.value.id).toBe(55);
        expect(m2.value.title).toBe('foo');
        expect(m2.value).toBe(m1.value);
        expect(m2).not.toBe(m1);
        const m3 = await controller.getModel(1231325);
        expect(m3).toBeInstanceOf(EntitySubject);
        expect(m3.value).toBeInstanceOf(MyModel);
        expect(m3.value).not.toBe(m1.value);
        expect(m3.value.title).toBe('foo');
        expect(m3.value.id).toBe(1231325);
    }
    {
        const m1 = await controller.getModelWithChange(55);
        expect(m1).toBeInstanceOf(EntitySubject);
        expect(m1.value).toBeInstanceOf(MyModel);
        expect(m1.value.id).toBe(55);
        expect(m1.value.title).toBe('foo');
        expect(m1.value.config).toBeInstanceOf(Config);
        expect(m1.value.config.timeout).toBe(0);
        expect(m1.value.config.logs).toBe(true);
        await m1.nextStateChange;
        expect(m1.value.title).toBe('bar');
        expect(m1.value.config).toBeInstanceOf(Config);
        expect(m1.value.config.timeout).toBe(44);
        expect(m1.value.config.logs).toBe(false);
    }
});
//# sourceMappingURL=entity-state.spec.js.map