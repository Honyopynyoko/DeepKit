var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { sleep } from '@deepkit/core';
import { entity, plainToClass, t } from '@deepkit/type';
import { expect, test } from '@jest/globals';
import 'reflect-metadata';
import { BehaviorSubject, Observable, Subject, Subscription } from 'rxjs';
import { first, take } from 'rxjs/operators';
import { DirectClient } from '../src/client/client-direct';
import { rpc } from '../src/decorators';
import { RpcKernel } from '../src/server/kernel';
test('observable basics', async () => {
    let MyModel = class MyModel {
        constructor(name) {
            this.name = name;
        }
    };
    MyModel = __decorate([
        entity.name('model'),
        __param(0, t),
        __metadata("design:paramtypes", [String])
    ], MyModel);
    class Controller {
        strings() {
            return new Observable((observer) => {
                observer.next('first');
                observer.next('second');
                observer.next('third');
                observer.complete();
            });
        }
        errors() {
            return new Observable((observer) => {
                observer.error(new Error('Jupp'));
            });
        }
        myModel() {
            return new Observable((observer) => {
                observer.next(new MyModel('Peter'));
                observer.complete();
            });
        }
    }
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Observable)
    ], Controller.prototype, "strings", null);
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Observable)
    ], Controller.prototype, "errors", null);
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Observable)
    ], Controller.prototype, "myModel", null);
    const kernel = new RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const o = await controller.strings();
        expect(o).toBeInstanceOf(Observable);
        const firstValue = await o.pipe(first()).toPromise();
        expect(firstValue).toBe('first');
        const secondValue = await o.pipe(take(2)).toPromise();
        expect(secondValue).toBe('second');
        const thirdValue = await o.pipe(take(3)).toPromise();
        expect(thirdValue).toBe('third');
        const lastValue = await o.toPromise();
        expect(lastValue).toBe('third');
    }
    {
        const o = await controller.errors();
        expect(o).toBeInstanceOf(Observable);
        await expect(o.toPromise()).rejects.toThrowError(Error);
        await expect(o.toPromise()).rejects.toThrowError('Jupp');
    }
    {
        const o = await controller.myModel();
        expect(o).toBeInstanceOf(Observable);
        const model = await o.toPromise();
        expect(model).toBeInstanceOf(MyModel);
        expect(model.name).toBe('Peter');
    }
    {
        await expect(controller.unknownMethod()).rejects.toThrowError('Action unknown unknownMethod');
    }
});
test('Subject', async () => {
    class Controller {
        strings() {
            const subject = new Subject();
            (async () => {
                await sleep(0.1);
                subject.next('first');
                subject.next('second');
                subject.complete();
            })();
            return subject;
        }
    }
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Subject)
    ], Controller.prototype, "strings", null);
    const kernel = new RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const o = await controller.strings();
        expect(o).toBeInstanceOf(Subject);
        const lastValue = await o.toPromise();
        expect(lastValue).toBe('second');
    }
});
test('subject unsubscribes automatically when connection closes', async () => {
    let unsubscribed = false;
    class Controller {
        strings() {
            const subject = new Subject();
            subject.subscribe().add(() => {
                unsubscribed = true;
            });
            return subject;
        }
    }
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Subject)
    ], Controller.prototype, "strings", null);
    const kernel = new RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const o = await controller.strings();
        expect(o).toBeInstanceOf(Subject);
        expect(unsubscribed).toBe(false);
        o.unsubscribe();
        await sleep(0);
        expect(unsubscribed).toBe(true);
    }
    {
        unsubscribed = false;
        const o = await controller.strings();
        expect(o).toBeInstanceOf(Subject);
        expect(unsubscribed).toBe(false);
        client.disconnect();
        await sleep(0);
        expect(unsubscribed).toBe(true);
    }
});
test('observable unsubscribes automatically when connection closes', async () => {
    let unsubscribed = false;
    class Controller {
        strings() {
            return new Observable((observer) => {
                return {
                    unsubscribe() {
                        unsubscribed = true;
                    }
                };
            });
        }
    }
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Observable)
    ], Controller.prototype, "strings", null);
    const kernel = new RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const o = (await controller.strings()).subscribe(() => { });
        expect(o).toBeInstanceOf(Subscription);
        expect(unsubscribed).toBe(false);
        o.unsubscribe();
        await sleep(0);
        expect(unsubscribed).toBe(true);
    }
    {
        unsubscribed = false;
        const o = (await controller.strings()).subscribe(() => { });
        expect(o).toBeInstanceOf(Subscription);
        expect(unsubscribed).toBe(false);
        client.disconnect();
        await sleep(0);
        expect(unsubscribed).toBe(true);
    }
});
test('observable different next type', async () => {
    class WrongModel {
        constructor() {
            this.id = 0;
        }
    }
    __decorate([
        t,
        __metadata("design:type", Number)
    ], WrongModel.prototype, "id", void 0);
    let MyModel = class MyModel {
        constructor() {
            this.id = 0;
        }
    };
    __decorate([
        t,
        __metadata("design:type", Number)
    ], MyModel.prototype, "id", void 0);
    MyModel = __decorate([
        entity.name('observable/differentytype')
    ], MyModel);
    class Controller {
        constructor() {
            this.subject = new BehaviorSubject(undefined);
        }
        getSubject() {
            if (this.subject)
                this.subject.complete();
            this.subject = new BehaviorSubject(undefined);
            return this.subject;
        }
        triggerCorrect() {
            this.subject.next(plainToClass(MyModel, { id: 2 }));
        }
        triggerPlain() {
            this.subject.next({ id: 2 });
        }
        triggerWrongModel() {
            this.subject.next(new WrongModel());
        }
    }
    __decorate([
        rpc.action(),
        t.generic(MyModel),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", BehaviorSubject)
    ], Controller.prototype, "getSubject", null);
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "triggerCorrect", null);
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "triggerPlain", null);
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Controller.prototype, "triggerWrongModel", null);
    const kernel = new RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const subject = await controller.getSubject();
        expect(subject.value).toBe(undefined);
        await controller.triggerCorrect();
        expect(subject.value).toBeInstanceOf(MyModel);
        expect(subject.value).toEqual({ id: 2 });
    }
    {
        const subject = await controller.getSubject();
        expect(subject.value).toBe(undefined);
        await controller.triggerPlain();
        expect(subject.value).toEqual(undefined);
    }
    {
        const subject = await controller.getSubject();
        expect(subject.value).toBe(undefined);
        await controller.triggerWrongModel();
        expect(subject.value).toEqual(undefined);
    }
});
test('Behavior', async () => {
    class Controller {
        initial() {
            return new BehaviorSubject('initial');
        }
        strings() {
            const subject = new BehaviorSubject('initial');
            (async () => {
                await sleep(0.1);
                subject.next('first');
                subject.next('second');
                subject.complete();
            })();
            return subject;
        }
    }
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", BehaviorSubject)
    ], Controller.prototype, "initial", null);
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", BehaviorSubject)
    ], Controller.prototype, "strings", null);
    const kernel = new RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new DirectClient(kernel);
    const controller = client.controller('myController');
    {
        const o = await controller.initial();
        expect(o).toBeInstanceOf(BehaviorSubject);
        expect(o.getValue()).toBe('initial');
    }
    {
        const o = await controller.strings();
        expect(o).toBeInstanceOf(BehaviorSubject);
        const lastValue = await o.toPromise();
        expect(lastValue).toBe('second');
    }
});
test('make sure base assumption about Subject is right', async () => {
    {
        const subject = new Subject();
        let teardown = false;
        subject.subscribe().add(() => {
            teardown = true;
        });
        subject.unsubscribe();
        expect(teardown).toBe(false);
    }
    {
        const subject = new Subject();
        let teardown = false;
        subject.subscribe().add(() => {
            teardown = true;
        });
        subject.complete();
        expect(teardown).toBe(true);
    }
});
test('observable complete', async () => {
    let active = false;
    class Controller {
        numberGenerator(max) {
            return new Observable((observer) => {
                let done = false;
                let i = 0;
                active = true;
                (async () => {
                    while (!done && i <= max) {
                        observer.next(i++);
                        await sleep(0.02);
                    }
                    active = false;
                    observer.complete();
                })();
                return {
                    unsubscribe() {
                        done = true;
                        active = false;
                    }
                };
            });
        }
    }
    __decorate([
        rpc.action(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number]),
        __metadata("design:returntype", Observable)
    ], Controller.prototype, "numberGenerator", null);
    const kernel = new RpcKernel();
    kernel.registerController('myController', Controller);
    const client = new DirectClient(kernel);
    const controller = client.controller('myController');
    {
        //make sure the assumption that unsubscribe() is even called when the observer calls complete() himself.
        let unsubscribedCalled = false;
        const o = new Observable((observer) => {
            unsubscribedCalled = false;
            observer.next(1);
            observer.complete();
            return {
                unsubscribe() {
                    unsubscribedCalled = true;
                }
            };
        });
        {
            const lastValue = await o.toPromise();
            expect(lastValue).toBe(1);
            expect(unsubscribedCalled).toBe(true);
        }
        {
            const lastValue = await new Promise((resolve) => {
                let l = undefined;
                o.subscribe((value) => {
                    l = value;
                }, () => { }, () => {
                    resolve(l);
                });
            });
            expect(lastValue).toBe(1);
            expect(unsubscribedCalled).toBe(true);
        }
    }
    {
        const o = await controller.numberGenerator(10);
        expect(o).toBeInstanceOf(Observable);
        const lastValue = await o.toPromise();
        expect(lastValue).toBe(10);
        expect(active).toBe(false);
    }
    {
        const o = await controller.numberGenerator(10000);
        expect(o).toBeInstanceOf(Observable);
        const complete = new BehaviorSubject(0);
        const sub = o.subscribe(complete);
        await sleep(0.1); //provide some time to generate some numbers
        expect(active).toBe(true);
        sub.unsubscribe(); //this calls unsubscribe() in the observer. We don't know when this happens from client PoV
        await sleep(0.01); //provide some time to handle it
        expect(active).toBe(false);
        expect(complete.value).toBeGreaterThan(1);
        expect(complete.value).toBeLessThan(10000);
    }
});
//# sourceMappingURL=observable.spec.js.map