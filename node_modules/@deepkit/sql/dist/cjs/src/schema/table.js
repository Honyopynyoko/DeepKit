"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatabaseComparator = exports.DatabaseDiff = exports.TableComparator = exports.TableDiff = exports.ForeignKeyComparator = exports.IndexComparator = exports.ColumnComparator = exports.ColumnDiff = exports.ColumnPropertyDiff = exports.ForeignKey = exports.Index = exports.Column = exports.Table = exports.DatabaseModel = void 0;
const core_1 = require("@deepkit/core");
const hash_1 = require("../hash");
class DatabaseModel {
    constructor(tables = []) {
        this.tables = tables;
        this.schemaName = '';
        this.schemaMap = new Map();
    }
    getTableForSchema(schema) {
        const table = this.schemaMap.get(schema);
        if (!table)
            throw new Error(`No table for entity ${schema.getName()}`);
        return table;
    }
    addTable(name) {
        const table = new Table(name);
        this.tables.push(table);
        return table;
    }
    getTable(name, schemaName) {
        const table = this.tables.find(v => v.isName(name, schemaName));
        if (!table)
            throw new Error(`Could not find table ${name} in schema ${schemaName}`);
        return table;
    }
    getTableNames() {
        return this.tables.map(v => v.getName());
    }
    getTableForFull(fullName, schemaDelimiter) {
        let name = fullName.includes(schemaDelimiter) ? fullName.split(schemaDelimiter)[0] : fullName;
        let schemaName = fullName.includes(schemaDelimiter) ? fullName.split(schemaDelimiter)[1] : '';
        return this.getTable(name, schemaName);
    }
    hasTable(name, schemaName) {
        return this.tables.some(v => v.isName(name, schemaName));
    }
}
exports.DatabaseModel = DatabaseModel;
class Table {
    constructor(name) {
        this.name = name;
        this.schemaName = '';
        this.alias = '';
        this.columnForProperty = new Map;
        this.columns = [];
        this.indices = [];
        this.foreignKeys = [];
    }
    isName(name, schemaName) {
        if (schemaName && schemaName !== this.schemaName)
            return false;
        return this.name === name;
    }
    getName() {
        return this.name;
    }
    getFullName(schemaDelimiter) {
        return (this.schemaName ? this.schemaName + schemaDelimiter : '') + this.name;
    }
    addColumn(name, property) {
        const column = new Column(this, name);
        this.columns.push(column);
        if (property)
            this.columnForProperty.set(property, column);
        return column;
    }
    addIndex(name, unique = false) {
        const index = new Index(this, name, unique);
        this.indices.push(index);
        return index;
    }
    addForeignKey(name, foreignTable) {
        const foreignKey = new ForeignKey(this, name, foreignTable);
        this.foreignKeys.push(foreignKey);
        return foreignKey;
    }
    hasColumn(name) {
        return this.columns.some(v => v.name === name);
    }
    getColumn(name) {
        const column = this.columns.find(v => v.name === name);
        if (!column)
            throw new Error(`Column ${name} not found at table ${this.name}`);
        return column;
    }
    getColumnForProperty(property) {
        const column = this.columnForProperty.get(property);
        if (!column)
            throw new Error(`Column ${property.name} not found at table ${this.name}`);
        return column;
    }
    getPrimaryKeys() {
        return this.columns.filter(v => v.isPrimaryKey);
    }
    getAutoIncrements() {
        return this.columns.filter(v => v.isAutoIncrement);
    }
    getIndices() {
        return this.indices.filter(v => !v.isUnique);
    }
    getIndex(name) {
        return this.indices.find(v => v.getName() === name);
    }
    getUnices() {
        return this.indices.filter(v => v.isUnique);
    }
    hasPrimaryKey() {
        return this.getPrimaryKeys().length > 0;
    }
    hasCompositePrimaryKey() {
        return this.getPrimaryKeys().length > 1;
    }
    getForeignKeyOfLocalColumn(column) {
        for (const foreignKey of this.foreignKeys) {
            if (foreignKey.localColumns.includes(column))
                return foreignKey;
        }
        return;
    }
    hasIndexByName(name) {
        for (const index of this.indices) {
            if (name && index.name === name)
                return true;
        }
        return false;
    }
    hasIndex(columns, unique = false) {
        //the order in index is important, so we don't mess with that.
        const indexName = columns.map(v => v.name).join(',');
        for (const index of this.indices) {
            if (index.isUnique !== unique)
                continue;
            const thisIndexName = index.columns.map(v => v.name).join(',');
            if (thisIndexName === indexName)
                return true;
        }
        return false;
    }
}
exports.Table = Table;
class Column {
    constructor(table, name //real column name (probably transformed to snake case, or something)
    ) {
        this.table = table;
        this.name = name;
        this.description = '';
        this.isNotNull = false;
        this.isPrimaryKey = false;
        this.isAutoIncrement = false;
    }
    getName() {
        return this.name;
    }
    getFullName() {
        return this.table.getName() + '.' + this.getName();
    }
    getSizeDefinition() {
        if (undefined === this.size)
            return '';
        if (undefined !== this.scale)
            return `(${this.size}, ${this.scale})`;
        return `(${this.size})`;
    }
}
exports.Column = Column;
class Index {
    constructor(table, name, isUnique = false) {
        this.table = table;
        this.name = name;
        this.isUnique = isUnique;
        this.columns = [];
        this.spatial = false;
        this.partial = false;
        this.size = 0;
    }
    getName() {
        if (!this.name) {
            const hash = [];
            for (const column of this.columns)
                hash.push(column.name + '/' + column.size);
            const prefix = this.isUnique ? 'u' : 'i';
            return this.table.getName() + '_' + prefix + hash_1.cyrb53(hash.join('|'));
        }
        return this.name;
    }
    hasColumn(columnName) {
        return this.columns.some(v => v.getName() === columnName);
    }
    addColumn(columnName) {
        this.columns.push(this.table.getColumn(columnName));
    }
    valueOf() {
        return `${this.isUnique ? 'UNIQUE INDEX' : 'INDEX'} ${this.getName()} COLUMNS(${this.columns.map(v => v.getName())})`;
    }
}
exports.Index = Index;
class ForeignKey {
    constructor(table, name, foreign) {
        this.table = table;
        this.name = name;
        this.foreign = foreign;
        this.localColumns = [];
        this.foreignColumns = [];
        this.onUpdate = 'CASCADE';
        this.onDelete = 'CASCADE';
    }
    getName() {
        if (!this.name) {
            const hash = [];
            for (const column of this.localColumns)
                hash.push(column.name + '/' + column.size);
            for (const column of this.foreignColumns)
                hash.push(column.name + '/' + column.size);
            return this.table.getName() + '_fk' + hash_1.cyrb53(hash.join('|'));
        }
        return this.name;
    }
    addReference(localColumnName, foreignColumnName) {
        this.localColumns.push(this.table.getColumn(localColumnName));
        this.foreignColumns.push(this.foreign.getColumn(foreignColumnName));
    }
    getColumnMapping() {
        const res = [];
        for (let i = 0; i < this.localColumns.length; i++) {
            res.push([this.localColumns[i], this.foreignColumns[i]]);
        }
        return res;
    }
    valueOf() {
        return `fk=${this.getName()} to ${this.foreign.getName()} (${this.getColumnMapping().map(([from, to]) => `${from.getName()}=>${to.getName()}`)})`;
    }
}
exports.ForeignKey = ForeignKey;
class ColumnPropertyDiff {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
exports.ColumnPropertyDiff = ColumnPropertyDiff;
class ColumnDiff {
    constructor(from, to, changedProperties = new Map()) {
        this.from = from;
        this.to = to;
        this.changedProperties = changedProperties;
    }
    valueOf() {
        const res = [];
        for (const [key, value] of this.changedProperties.entries()) {
            res.push(`${key}: ${JSON.stringify(value.from)}=>${JSON.stringify(value.to)}`);
        }
        return res.join(',');
    }
}
exports.ColumnDiff = ColumnDiff;
class ColumnComparator {
    static computeDiff(from, to) {
        const diff = ColumnComparator.compareColumns(from, to);
        return diff.size ? new ColumnDiff(from, to, diff) : undefined;
    }
    static compareColumns(from, to) {
        const changedProperties = new Map();
        if (from.scale !== to.scale)
            changedProperties.set('scale', new ColumnPropertyDiff(from.scale, to.scale));
        if (from.size !== to.size)
            changedProperties.set('size', new ColumnPropertyDiff(from.size, to.size));
        if (from.isNotNull !== to.isNotNull)
            changedProperties.set('isNotNull', new ColumnPropertyDiff(from.isNotNull, to.isNotNull));
        if (from.isAutoIncrement !== to.isAutoIncrement)
            changedProperties.set('isAutoIncrement', new ColumnPropertyDiff(from.isAutoIncrement, to.isAutoIncrement));
        if (from.defaultValue !== to.defaultValue)
            changedProperties.set('defaultValue', new ColumnPropertyDiff(from.defaultValue, to.defaultValue));
        return changedProperties;
    }
}
exports.ColumnComparator = ColumnComparator;
class IndexComparator {
    static computeDiff(from, to) {
        //check if order has changed.
        const fromColumnNames = from.columns.map(v => v.name).join(',').toLowerCase();
        const toColumnNames = to.columns.map(v => v.name).join(',').toLowerCase();
        if (fromColumnNames !== toColumnNames)
            return true;
        return from.isUnique !== to.isUnique;
    }
}
exports.IndexComparator = IndexComparator;
class ForeignKeyComparator {
    static computeDiff(from, to) {
        if (from.foreign.getName() !== to.foreign.getName())
            return true;
        const fromFkLocalFields = from.localColumns.map(v => v.name).join(',').toLowerCase();
        const toFkLocalFields = to.localColumns.map(v => v.name).join(',').toLowerCase();
        if (fromFkLocalFields !== toFkLocalFields)
            return true;
        const fromFkForeignFields = from.localColumns.map(v => v.name).join(',').toLowerCase();
        const toFkForeignFields = to.localColumns.map(v => v.name).join(',').toLowerCase();
        if (fromFkForeignFields !== toFkForeignFields)
            return true;
        if (from.onUpdate.toLowerCase() !== to.onUpdate.toLowerCase())
            return true;
        if (from.onDelete.toLowerCase() !== to.onDelete.toLowerCase())
            return true;
        return false;
    }
}
exports.ForeignKeyComparator = ForeignKeyComparator;
class TableDiff {
    constructor(from, to) {
        this.from = from;
        this.to = to;
        this.addedColumns = [];
        this.removedColumns = [];
        this.modifiedColumns = [];
        this.renamedColumns = [];
        this.addedPKColumns = [];
        this.removedPKColumns = [];
        this.renamedPKColumns = [];
        this.addedIndices = [];
        this.removedIndices = [];
        this.modifiedIndices = [];
        this.addedFKs = [];
        this.modifiedFKs = [];
        this.removedFKs = [];
    }
    hasModifiedPk() {
        return this.addedPKColumns.length > 0 || this.renamedPKColumns.length > 0 || this.removedPKColumns.length > 0;
    }
    toString() {
        let lines = [];
        lines.push(`  ${this.from.getName()}:`);
        if (this.addedColumns.length) {
            lines.push('   addedColumns:');
            for (const field of this.addedColumns)
                lines.push(`     ${field.getName()}:`);
        }
        if (this.removedColumns.length) {
            lines.push('   removedColumns:');
            for (const field of this.removedColumns)
                lines.push(`     ${field.getName()}:`);
        }
        if (this.renamedColumns.length) {
            lines.push('   renamedColumns:');
            for (const [from, to] of this.renamedColumns)
                lines.push(`     ${from.getName()} -> ${to.getName()}`);
        }
        if (this.modifiedColumns.length) {
            lines.push('   modifiedColumns:');
            for (const diff of this.modifiedColumns)
                lines.push(`     ${diff.from.getName()}=>${diff.to.getName()} ${diff.valueOf()}`);
        }
        if (this.addedPKColumns.length) {
            lines.push('   addedPKColumns:');
            for (const field of this.addedPKColumns)
                lines.push(`     ${field.getName()}:`);
        }
        if (this.removedPKColumns.length) {
            lines.push('   removedPKColumns:');
            for (const field of this.removedPKColumns)
                lines.push(`     ${field.getName()}:`);
        }
        if (this.renamedPKColumns.length) {
            lines.push('   renamedPKColumns:');
            for (const [from, to] of this.renamedPKColumns)
                lines.push(`     ${from.getName()} -> ${to.getName()}`);
        }
        if (this.addedFKs.length) {
            lines.push('   addedFKs:');
            for (const fk of this.addedFKs)
                lines.push(`     ${fk.valueOf()}`);
        }
        if (this.modifiedFKs.length) {
            lines.push('   modifiedFKs:');
            for (const [from, to] of this.modifiedFKs) {
                lines.push(`     ${from.getName()} => ${to.getName()}`);
                lines.push(`        ${from.getName()}: ${from.valueOf()}`);
                lines.push(`        ${to.getName()}: ${to.valueOf()}`);
            }
        }
        if (this.removedFKs.length) {
            lines.push('   removedFKs:');
            for (const fk of this.removedFKs)
                lines.push(`     ${fk.getName()}`);
        }
        if (this.addedIndices.length) {
            lines.push('   addedIndices:');
            for (const index of this.addedIndices)
                lines.push(`     ${index.valueOf()}`);
        }
        if (this.removedIndices.length) {
            lines.push('   removedIndices:');
            for (const index of this.removedIndices)
                lines.push(`     ${index.valueOf()}`);
        }
        if (this.modifiedIndices.length) {
            lines.push('   modifiedIndices:');
            for (const [from, to] of this.modifiedIndices) {
                lines.push(`     ${from.getName()} => ${to.getName()}`);
                lines.push(`        ${from.getName()}: ${from.valueOf()}`);
                lines.push(`        ${to.getName()}: ${to.valueOf()}`);
            }
        }
        return lines.join('\n');
    }
}
exports.TableDiff = TableDiff;
class TableComparator {
    constructor(from, to) {
        this.from = from;
        this.to = to;
        this.diff = new TableDiff(from, to);
    }
    static computeDiff(from, to) {
        const tc = new this(from, to);
        let differences = 0;
        differences += tc.compareColumns();
        differences += tc.comparePrimaryKeys();
        differences += tc.compareIndices();
        differences += tc.compareFKs();
        return differences ? tc.diff : undefined;
    }
    compareColumns() {
        const fromColumns = this.from.columns;
        const toColumns = this.to.columns;
        let differences = 0;
        // check for new columns in $toEntity
        for (const column of toColumns) {
            if (!this.from.hasColumn(column.name)) {
                this.diff.addedColumns.push(column);
                differences++;
            }
        }
        // check for removed columns in $toEntity
        for (const column of fromColumns) {
            if (!this.to.hasColumn(column.name)) {
                this.diff.removedColumns.push(column);
                differences++;
            }
        }
        // check for column differences
        for (const fromColumn of fromColumns) {
            if (this.to.hasColumn(fromColumn.name)) {
                const toColumn = this.to.getColumn(fromColumn.name);
                const diff = ColumnComparator.computeDiff(fromColumn, toColumn);
                if (!diff)
                    continue;
                this.diff.modifiedColumns.push(diff);
                differences++;
            }
        }
        // check for column renamings
        for (const addedColumn of this.diff.addedColumns.values()) {
            for (const removedColumn of this.diff.removedColumns.values()) {
                if (!ColumnComparator.computeDiff(addedColumn, removedColumn)) {
                    // no difference except the name, that's probably a renaming
                    this.diff.renamedColumns.push([removedColumn, addedColumn]);
                    core_1.arrayRemoveItem(this.diff.addedColumns, addedColumn);
                    core_1.arrayRemoveItem(this.diff.removedColumns, removedColumn);
                    differences--;
                    // skip to the next added column
                    break;
                }
            }
        }
        return differences;
    }
    comparePrimaryKeys() {
        const fromColumns = this.from.getPrimaryKeys();
        const toColumns = this.from.getPrimaryKeys();
        let differences = 0;
        // check for new columns in $toEntity
        for (const column of toColumns) {
            if (!this.from.hasColumn(column.name)) {
                this.diff.addedPKColumns.push(column);
                differences++;
            }
        }
        // check for removed columns in $toEntity
        for (const column of fromColumns) {
            if (!this.to.hasColumn(column.name)) {
                this.diff.removedPKColumns.push(column);
                differences++;
            }
        }
        // check for column renamings
        for (const addedColumn of this.diff.addedPKColumns.values()) {
            for (const removedColumn of this.diff.removedPKColumns.values()) {
                if (!ColumnComparator.computeDiff(addedColumn, removedColumn)) {
                    // no difference except the name, that's probably a renaming
                    this.diff.renamedPKColumns.push([removedColumn, addedColumn]);
                    core_1.arrayRemoveItem(this.diff.addedPKColumns, addedColumn);
                    core_1.arrayRemoveItem(this.diff.removedPKColumns, removedColumn);
                    differences--;
                    // skip to the next added column
                    break;
                }
            }
        }
        return differences;
    }
    compareIndices() {
        let differences = 0;
        const fromIndices = this.from.indices.slice();
        const toIndices = this.to.indices.slice();
        for (const fromIndex of fromIndices.slice()) {
            for (const toIndex of toIndices.slice()) {
                if (fromIndex.getName() === toIndex.getName()) {
                    if (IndexComparator.computeDiff(fromIndex, toIndex)) {
                        //same name, but different columns
                        this.diff.modifiedIndices.push([fromIndex, toIndex]);
                        differences++;
                    }
                    core_1.arrayRemoveItem(fromIndices, fromIndex);
                    core_1.arrayRemoveItem(toIndices, toIndex);
                }
            }
        }
        for (const fromIndex of fromIndices) {
            this.diff.removedIndices.push(fromIndex);
            differences++;
        }
        for (const toIndex of toIndices) {
            this.diff.addedIndices.push(toIndex);
            differences++;
        }
        return differences;
    }
    compareFKs() {
        let differences = 0;
        const fromForeignKeys = this.from.foreignKeys.slice();
        const toForeignKys = this.to.foreignKeys.slice();
        for (const fromFK of fromForeignKeys.slice()) {
            for (const toFK of toForeignKys.slice()) {
                if (fromFK.getName() === toFK.getName()) {
                    if (ForeignKeyComparator.computeDiff(fromFK, toFK)) {
                        //same name, but different columns
                        this.diff.modifiedFKs.push([fromFK, toFK]);
                        differences++;
                    }
                    core_1.arrayRemoveItem(fromForeignKeys, fromFK);
                    core_1.arrayRemoveItem(toForeignKys, toFK);
                }
            }
        }
        for (const fromFK of fromForeignKeys) {
            this.diff.removedFKs.push(fromFK);
            differences++;
        }
        for (const toFK of toForeignKys) {
            this.diff.addedFKs.push(toFK);
            differences++;
        }
        return differences;
    }
}
exports.TableComparator = TableComparator;
class DatabaseDiff {
    constructor(from, to) {
        this.from = from;
        this.to = to;
        this.addedTables = [];
        this.removedTables = [];
        this.modifiedTables = [];
        this.renamedTables = [];
    }
    forTable(table) {
        this.addedTables = this.addedTables.filter(v => v.name === table.name);
        this.removedTables = this.removedTables.filter(v => v.name === table.name);
        this.modifiedTables = this.modifiedTables.filter(v => v.to.name === table.name);
        this.renamedTables = this.renamedTables.filter(([from, to]) => to.name === table.name);
    }
    getDiff(table) {
        return this.modifiedTables.find(v => v.to.name === table.name);
    }
}
exports.DatabaseDiff = DatabaseDiff;
class DatabaseComparator {
    constructor(from, to) {
        this.from = from;
        this.to = to;
        this.withRemoveTable = true;
        this.withRenaming = true;
        this.diff = new DatabaseDiff(from, to);
    }
    static computeDiff(from, to) {
        const dc = new this(from, to);
        let differences = 0;
        differences = dc.compareTables();
        return differences ? dc.diff : undefined;
    }
    compareTables() {
        let differences = 0;
        for (const table of this.to.tables) {
            if (!this.from.hasTable(table.getName())) {
                this.diff.addedTables.push(table);
                differences++;
            }
        }
        if (this.withRemoveTable) {
            for (const table of this.from.tables) {
                if (!this.to.hasTable(table.getName())) {
                    this.diff.removedTables.push(table);
                    differences++;
                }
            }
        }
        for (const table of this.from.tables) {
            if (this.to.hasTable(table.getName())) {
                const to = this.to.getTable(table.getName());
                const diff = TableComparator.computeDiff(table, to);
                if (!diff)
                    continue;
                this.diff.modifiedTables.push(diff);
                differences++;
            }
        }
        //check for renamings
        if (this.withRenaming) {
            for (const addedTable of this.diff.addedTables.slice()) {
                for (const removedTable of this.diff.removedTables.slice()) {
                    if (!TableComparator.computeDiff(addedTable, removedTable)) {
                        //no difference except the name, that's probably a renaming
                        core_1.arrayRemoveItem(this.diff.addedTables, addedTable);
                        core_1.arrayRemoveItem(this.diff.removedTables, removedTable);
                        this.diff.renamedTables.push([removedTable, addedTable]);
                        break;
                    }
                }
            }
        }
        return differences;
    }
}
exports.DatabaseComparator = DatabaseComparator;
//# sourceMappingURL=table.js.map