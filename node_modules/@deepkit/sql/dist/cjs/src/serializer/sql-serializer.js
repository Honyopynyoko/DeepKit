"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.uuid4Stringify = exports.uuid4Binary = exports.sqlSerializer = exports.hexTable = void 0;
const core_1 = require("@deepkit/core");
const type_1 = require("@deepkit/type");
exports.hexTable = [];
for (let i = 0; i < 256; i++) {
    exports.hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);
}
exports.sqlSerializer = new class extends type_1.jsonSerializer.fork('sql') {
};
function uuid4Binary(u) {
    return 'string' === typeof u ? Buffer.from(u.replace(/-/g, ''), 'hex') : Buffer.alloc(0);
}
exports.uuid4Binary = uuid4Binary;
function uuid4Stringify(buffer) {
    return exports.hexTable[buffer[0]] + exports.hexTable[buffer[1]] + exports.hexTable[buffer[2]] + exports.hexTable[buffer[3]]
        + '-'
        + exports.hexTable[buffer[4]] + exports.hexTable[buffer[5]]
        + '-'
        + exports.hexTable[buffer[6]] + exports.hexTable[buffer[7]]
        + '-'
        + exports.hexTable[buffer[8]] + exports.hexTable[buffer[9]]
        + '-'
        + exports.hexTable[buffer[10]] + exports.hexTable[buffer[11]] + exports.hexTable[buffer[12]] + exports.hexTable[buffer[13]] + exports.hexTable[buffer[14]] + exports.hexTable[buffer[15]];
}
exports.uuid4Stringify = uuid4Stringify;
exports.sqlSerializer.fromClass.register('undefined', (property, state) => {
    //sql does not support 'undefined' as column type, so we convert automatically to null
    state.addSetter(`null`);
});
exports.sqlSerializer.fromClass.register('null', (property, state) => {
    //sql does not support 'undefined' as column type, so we convert automatically to null
    state.addSetter(`null`);
});
exports.sqlSerializer.toClass.register('null', (property, state) => {
    //sql does not support 'undefined' as column type, so we store always null. depending on the property definition
    //we convert back to undefined or keep it null
    if (property.isOptional)
        return state.addSetter(`undefined`);
    if (property.isNullable)
        return state.addSetter(`null`);
});
exports.sqlSerializer.toClass.register('undefined', (property, state) => {
    //sql does not support 'undefined' as column type, so we store always null. depending on the property definition
    //we convert back to undefined or keep it null
    if (property.isOptional)
        return state.addSetter(`undefined`);
    if (property.isNullable)
        return state.addSetter(`null`);
});
//SQL escape does the job.
exports.sqlSerializer.fromClass.register('date', (property, state) => {
    state.addSetter(`${state.accessor}`);
});
exports.sqlSerializer.toClass.register('uuid', (property, state) => {
    state.setContext({ uuid4Stringify });
    state.addCodeForSetter(`
        try {
            ${state.setter} = 'string' === typeof ${state.accessor} ? ${state.accessor} : uuid4Stringify(${state.accessor});
        } catch (error) {
            throw new TypeError('Invalid UUID v4 given in property ${property.name}: ' + error);
        }
        `);
});
exports.sqlSerializer.fromClass.register('uuid', (property, state) => {
    state.setContext({ uuid4Binary });
    state.addCodeForSetter(`
        try {
            ${state.setter} = uuid4Binary(${state.accessor});
        } catch (error) {
            throw new TypeError('Invalid UUID v4 given in property ${property.name}: ' + error);
        }
        `);
});
exports.sqlSerializer.toClass.prepend('class', (property, state) => {
    //when property is a reference, then we stored in the database the actual primary key and used this
    //field as foreignKey. This makes it necessary to convert it differently (concretely we treat it as the primary)
    const classSchema = type_1.getClassSchema(property.resolveClassType);
    //note: jsonSerializer already calls JSON.parse if data is a string
    if (property.isReference) {
        const primary = classSchema.getPrimaryField();
        state.addCodeForSetter(type_1.getDataConverterJS(state.setter, state.accessor, primary, state.serializerCompilers, state.rootContext, state.jitStack));
        state.forceEnd();
    }
    return;
});
exports.sqlSerializer.fromClass.prepend('class', (property, state) => {
    //When property is a reference we store the actual primary (as foreign key) of the referenced instance instead of the actual instance.
    //This way we implemented basically relations in the database
    const classSchema = type_1.getClassSchema(property.resolveClassType);
    if (property.isReference) {
        const classType = state.setVariable('classType', property.resolveClassType);
        state.rootContext.set('isObject', core_1.isObject);
        const primary = classSchema.getPrimaryField();
        state.addCodeForSetter(`
            if (isObject(${state.accessor})) {
                ${type_1.getDataConverterJS(state.setter, `${state.accessor}.${primary.name}`, primary, state.serializerCompilers, state.rootContext, state.jitStack)}
            } else {
                //we treat the input as if the user gave the primary key directly
                ${type_1.getDataConverterJS(state.setter, `${state.accessor}`, primary, state.serializerCompilers, state.rootContext, state.jitStack)}
            }
            `);
        state.forceEnd();
    }
});
exports.sqlSerializer.fromClass.append('class', (property, state) => {
    if (property.isReference)
        return;
    //we don't stringify non-root properties
    if (property.parent)
        return;
    //we need to convert the structure to JSON-string after it has been converted to JSON values from the previous compiler
    //but only on root properties.
    state.setContext({ stringify: JSON.stringify });
    state.addSetter(`_depth === 1 ? stringify(${state.accessor}) : ${state.accessor}`);
});
exports.sqlSerializer.toClass.prepend('class', (property, state) => {
    //when property is a reference, then we stored in the database the actual primary key and used this
    //field as foreignKey. This makes it necessary to convert it differently (concretely we treat it as the primary)
    const classSchema = type_1.getClassSchema(property.resolveClassType);
    //note: jsonSerializer already calls JSON.parse if data is a string
    if (property.isReference) {
        const primary = classSchema.getPrimaryField();
        state.addCodeForSetter(type_1.getDataConverterJS(state.setter, state.accessor, primary, state.serializerCompilers, state.rootContext, state.jitStack));
        state.forceEnd();
    }
    return;
});
exports.sqlSerializer.fromClass.register('array', (property, state) => {
    if (property.isReference)
        return;
    //we don't stringify non-root properties
    if (property.parent)
        return;
    //we need to convert the structure to JSON-string after it has been converted to JSON values from the previous compiler
    //but only on root properties.
    state.setContext({ stringify: JSON.stringify });
    state.addSetter(`_depth === 1 ? stringify(${state.accessor}) : ${state.accessor}`);
});
exports.sqlSerializer.toClass.prepend('array', (property, state) => {
    if (property.parent)
        return;
    state.addSetter(`'string' === typeof ${state.accessor} ? JSON.parse(${state.accessor}) : ${state.accessor}`);
});
exports.sqlSerializer.fromClass.append('map', (property, state) => {
    //we don't stringify non-root properties
    if (property.parent)
        return;
    //we need to convert the structure to JSON-string after it has been converted to JSON values from the previous compiler
    //but only on root properties.
    state.setContext({ stringify: JSON.stringify });
    state.addSetter(`_depth === 1 ? stringify(${state.accessor}) : ${state.accessor}`);
});
exports.sqlSerializer.toClass.prepend('map', (property, state) => {
    if (property.parent)
        return;
    state.addSetter(`'string' === typeof ${state.accessor} ? JSON.parse(${state.accessor}) : ${state.accessor}`);
});
exports.sqlSerializer.fromClass.registerForBinary((property, state) => {
    state.setContext({ typedArrayToBuffer: type_1.typedArrayToBuffer });
    state.addSetter(`typedArrayToBuffer(${state.accessor})`);
});
exports.sqlSerializer.toClass.registerForBinary((property, state) => {
    state.setContext({ typedArrayNamesMap: type_1.typedArrayNamesMap, nodeBufferToTypedArray: type_1.nodeBufferToTypedArray });
    state.addSetter(`nodeBufferToTypedArray(${state.accessor}, typedArrayNamesMap.get('${property.type}'))`);
});
exports.sqlSerializer.toClass.register('arrayBuffer', (property, state) => {
    state.setContext({ nodeBufferToArrayBuffer: type_1.nodeBufferToArrayBuffer });
    state.addSetter(`nodeBufferToArrayBuffer(${state.accessor})`);
});
//
// sqlSerializer.fromClass.register('arrayBuffer', (property: PropertySchema, state: CompilerState) => {
//     state.setContext({ Buffer });
//     state.addSetter(`Buffer.from(${state.accessor})`);
// });
//# sourceMappingURL=sql-serializer.js.map