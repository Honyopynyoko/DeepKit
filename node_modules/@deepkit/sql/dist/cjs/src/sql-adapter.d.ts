import { BaseQuery, Database, DatabaseAdapter, DatabaseAdapterQueryFactory, DatabaseLogger, DatabasePersistence, DatabasePersistenceChangeSet, DatabaseQueryModel, DatabaseSession, DatabaseTransaction, DeleteResult, Entity, FilterQuery, GenericQueryResolver, PatchResult, Query, RawFactory, Replace, Resolve, SORT_ORDER } from '@deepkit/orm';
import { ClassType } from '@deepkit/core';
import { Changes, ClassSchema } from '@deepkit/type';
import { DefaultPlatform, SqlPlaceholderStrategy } from './platform/default-platform';
import { SqlFormatter } from './sql-formatter';
export declare type SORT_TYPE = SORT_ORDER | {
    $meta: 'textScore';
};
export declare type DEEP_SORT<T extends Entity> = {
    [P in keyof T]?: SORT_TYPE;
} & {
    [P: string]: SORT_TYPE;
};
export declare class SQLQueryModel<T extends Entity> extends DatabaseQueryModel<T, FilterQuery<T>, DEEP_SORT<T>> {
    where?: SqlQuery;
    sqlSelect?: SqlQuery;
    clone(parentQuery: BaseQuery<T>): this;
    isPartial(): boolean;
}
export declare abstract class SQLStatement {
    abstract get(params?: any[]): Promise<any>;
    abstract all(params?: any[]): Promise<any[]>;
    abstract release(): void;
}
export declare abstract class SQLConnection {
    protected connectionPool: SQLConnectionPool;
    protected logger: DatabaseLogger;
    released: boolean;
    constructor(connectionPool: SQLConnectionPool, logger?: DatabaseLogger);
    release(): void;
    abstract prepare(sql: string): Promise<SQLStatement>;
    /**
     * Runs a single SQL query.
     */
    abstract run(sql: string, params?: any[]): Promise<any>;
    abstract getChanges(): Promise<number>;
    execAndReturnSingle(sql: string, params?: any[]): Promise<any>;
    execAndReturnAll(sql: string, params?: any[]): Promise<any>;
}
export declare abstract class SQLConnectionPool {
    protected activeConnections: number;
    /**
     * Reserves an existing or new connection. It's important to call `.release()` on it when
     * done. When release is not called a resource leak occurs and server crashes.
     */
    abstract getConnection(logger?: DatabaseLogger, transaction?: DatabaseTransaction): Promise<SQLConnection>;
    getActiveConnections(): number;
    release(connection: SQLConnection): void;
}
export declare class SQLQueryResolver<T extends Entity> extends GenericQueryResolver<T> {
    protected connectionPool: SQLConnectionPool;
    protected platform: DefaultPlatform;
    protected tableId: (schema: ClassSchema<any>) => string;
    protected quoteIdentifier: (id: string) => string;
    protected quote: (value: any) => string;
    constructor(connectionPool: SQLConnectionPool, platform: DefaultPlatform, classSchema: ClassSchema<T>, session: DatabaseSession<DatabaseAdapter>);
    protected createFormatter(withIdentityMap?: boolean): SqlFormatter;
    protected getTableIdentifier(schema: ClassSchema): string;
    count(model: SQLQueryModel<T>): Promise<number>;
    delete(model: SQLQueryModel<T>, deleteResult: DeleteResult<T>): Promise<void>;
    find(model: SQLQueryModel<T>): Promise<T[]>;
    findOneOrUndefined(model: SQLQueryModel<T>): Promise<T | undefined>;
    has(model: SQLQueryModel<T>): Promise<boolean>;
    patch(model: SQLQueryModel<T>, changes: Changes<T>, patchResult: PatchResult<T>): Promise<void>;
}
declare type QueryPart = string | SqlQuery | SqlQueryParameter | SQLQueryIdentifier;
export declare class SqlQueryParameter {
    value: any;
    constructor(value: any);
}
export declare class SQLQueryIdentifier {
    id: any;
    constructor(id: any);
}
export declare function identifier(id: string): SQLQueryIdentifier;
export declare class SqlQuery {
    parts: ReadonlyArray<QueryPart>;
    constructor(parts: ReadonlyArray<QueryPart>);
    clone(): SqlQuery;
    convertToSQL(platform: DefaultPlatform, placeholderStrategy: SqlPlaceholderStrategy, tableName?: string): {
        sql: string;
        params: any[];
    };
}
export declare function sql(strings: TemplateStringsArray, ...params: ReadonlyArray<any>): SqlQuery;
export declare class SQLDatabaseQuery<T extends Entity> extends Query<T> {
    protected databaseSession: DatabaseSession<DatabaseAdapter>;
    protected resolver: SQLQueryResolver<T>;
    model: SQLQueryModel<T>;
    constructor(classSchema: ClassSchema<T>, databaseSession: DatabaseSession<DatabaseAdapter>, resolver: SQLQueryResolver<T>);
    /**
     * Adds raw SQL to the where clause of the query.
     * If there is a `filter()` set as well, the where is added after the filter using AND.
     *
     * ```
     * database.query(User).where(`id > ${id}`).find();
     * ```
     *
     * Use `${identifier('name')} = ${'Peter'}` for column names that need to be quoted.
     */
    where(sql: SqlQuery): this;
    /**
     * Adds additional selects to the query.
     * Automatically converts the query to a partial (no class instances).
     */
    sqlSelect(sql: SqlQuery): Replace<this, Pick<Resolve<this>, any>>;
}
export declare class SQLDatabaseQueryFactory extends DatabaseAdapterQueryFactory {
    protected connectionPool: SQLConnectionPool;
    protected platform: DefaultPlatform;
    protected databaseSession: DatabaseSession<any>;
    constructor(connectionPool: SQLConnectionPool, platform: DefaultPlatform, databaseSession: DatabaseSession<any>);
    createQuery<T extends Entity>(classType: ClassType<T> | ClassSchema<T>): SQLDatabaseQuery<T>;
}
export declare class SqlMigrationHandler {
    protected database: Database<SQLDatabaseAdapter>;
    protected migrationEntity: ClassSchema;
    constructor(database: Database<SQLDatabaseAdapter>);
    setLatestMigrationVersion(version: number): Promise<void>;
    removeMigrationVersion(version: number): Promise<void>;
    getLatestMigrationVersion(): Promise<number>;
}
export declare class RawQuery {
    protected session: DatabaseSession<SQLDatabaseAdapter>;
    protected connectionPool: SQLConnectionPool;
    protected platform: DefaultPlatform;
    protected sql: SqlQuery;
    constructor(session: DatabaseSession<SQLDatabaseAdapter>, connectionPool: SQLConnectionPool, platform: DefaultPlatform, sql: SqlQuery);
    /**
     * Executes the raw query and returns nothing.
     */
    execute(): Promise<void>;
    /**
     * Returns the raw result of a single row.
     */
    findOne(): Promise<any>;
    /**
     * Returns the full result of a raw query.
     */
    find(): Promise<any[]>;
}
export declare class SqlRawFactory implements RawFactory<[SqlQuery]> {
    protected session: DatabaseSession<SQLDatabaseAdapter>;
    protected connectionPool: SQLConnectionPool;
    protected platform: DefaultPlatform;
    constructor(session: DatabaseSession<SQLDatabaseAdapter>, connectionPool: SQLConnectionPool, platform: DefaultPlatform);
    create(sql: SqlQuery): RawQuery;
}
export declare abstract class SQLDatabaseAdapter extends DatabaseAdapter {
    abstract platform: DefaultPlatform;
    abstract connectionPool: SQLConnectionPool;
    abstract queryFactory(databaseSession: DatabaseSession<this>): SQLDatabaseQueryFactory;
    abstract createPersistence(databaseSession: DatabaseSession<this>): SQLPersistence;
    abstract getSchemaName(): string;
    rawFactory(session: DatabaseSession<this>): SqlRawFactory;
    getInsertBatchSize(schema: ClassSchema): Promise<number>;
    getUpdateBatchSize(schema: ClassSchema): Promise<number>;
    isNativeForeignKeyConstraintSupported(): boolean;
    /**
     * Creates (and re-creates already existing) tables in the database.
     * This is only for testing purposes useful.
     *
     * WARNING: THIS DELETES ALL AFFECTED TABLES AND ITS CONTENT.
     */
    createTables(classSchemas: ClassSchema[]): Promise<void>;
    getMigrations(classSchemas: ClassSchema[]): Promise<{
        [name: string]: {
            sql: string[];
            diff: string;
        };
    }>;
    migrate(classSchemas: ClassSchema[]): Promise<void>;
}
export declare class SQLPersistence extends DatabasePersistence {
    protected platform: DefaultPlatform;
    connectionPool: SQLConnectionPool;
    protected session: DatabaseSession<SQLDatabaseAdapter>;
    protected connection?: SQLConnection;
    constructor(platform: DefaultPlatform, connectionPool: SQLConnectionPool, session: DatabaseSession<SQLDatabaseAdapter>);
    getConnection(): Promise<ReturnType<this['connectionPool']['getConnection']>>;
    release(): void;
    protected prepareAutoIncrement(classSchema: ClassSchema, count: number): void;
    protected populateAutoIncrementFields<T>(classSchema: ClassSchema<T>, items: T[]): void;
    insert<T extends Entity>(classSchema: ClassSchema<T>, items: T[]): Promise<void>;
    update<T extends Entity>(classSchema: ClassSchema<T>, changeSets: DatabasePersistenceChangeSet<T>[]): Promise<void>;
    protected doInsert<T>(classSchema: ClassSchema<T>, items: T[]): Promise<void>;
    batchUpdate<T extends Entity>(classSchema: ClassSchema<T>, changeSets: DatabasePersistenceChangeSet<T>[]): Promise<void>;
    protected batchInsert<T>(classSchema: ClassSchema<T>, items: T[]): Promise<void>;
    protected resetPlaceholderSymbol(): void;
    protected getPlaceholderSymbol(): string;
    protected getInsertSQL(classSchema: ClassSchema, fields: string[], values: string[]): string;
    remove<T extends Entity>(classSchema: ClassSchema<T>, items: T[]): Promise<void>;
}
export {};
