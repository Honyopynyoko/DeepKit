"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SQLPersistence = exports.SQLDatabaseAdapter = exports.SqlRawFactory = exports.RawQuery = exports.SqlMigrationHandler = exports.SQLDatabaseQueryFactory = exports.SQLDatabaseQuery = exports.sql = exports.SqlQuery = exports.identifier = exports.SQLQueryIdentifier = exports.SqlQueryParameter = exports.SQLQueryResolver = exports.SQLConnectionPool = exports.SQLConnection = exports.SQLStatement = exports.SQLQueryModel = void 0;
const orm_1 = require("@deepkit/orm");
const core_1 = require("@deepkit/core");
const type_1 = require("@deepkit/type");
const sql_builder_1 = require("./sql-builder");
const sql_formatter_1 = require("./sql-formatter");
const sql_serializer_1 = require("./serializer/sql-serializer");
const table_1 = require("./schema/table");
class SQLQueryModel extends orm_1.DatabaseQueryModel {
    clone(parentQuery) {
        const m = super.clone(parentQuery);
        m.where = this.where ? this.where.clone() : undefined;
        m.sqlSelect = this.sqlSelect ? this.sqlSelect.clone() : undefined;
        return m;
    }
    isPartial() {
        return super.isPartial() || !!this.sqlSelect;
    }
}
exports.SQLQueryModel = SQLQueryModel;
class SQLStatement {
}
exports.SQLStatement = SQLStatement;
class SQLConnection {
    constructor(connectionPool, logger = new orm_1.DatabaseLogger) {
        this.connectionPool = connectionPool;
        this.logger = logger;
        this.released = false;
    }
    release() {
        this.connectionPool.release(this);
    }
    async execAndReturnSingle(sql, params) {
        const stmt = await this.prepare(sql);
        try {
            return await stmt.get(params);
        }
        finally {
            stmt.release();
        }
    }
    async execAndReturnAll(sql, params) {
        const stmt = await this.prepare(sql);
        try {
            return await stmt.all(params);
        }
        finally {
            stmt.release();
        }
    }
}
exports.SQLConnection = SQLConnection;
class SQLConnectionPool {
    constructor() {
        this.activeConnections = 0;
    }
    getActiveConnections() {
        return this.activeConnections;
    }
    release(connection) {
        this.activeConnections--;
        connection.released = true;
    }
}
exports.SQLConnectionPool = SQLConnectionPool;
function buildSetFromChanges(platform, classSchema, changes) {
    const set = [];
    const scopeSerializer = platform.serializer.for(classSchema);
    if (changes.$set) {
        const value = scopeSerializer.partialSerialize(changes.$set);
        for (const i in value) {
            if (!value.hasOwnProperty(i))
                continue;
            set.push(`${platform.quoteIdentifier(i)} = ${platform.quoteValue(value[i])}`);
        }
    }
    if (changes.$inc) {
        for (const i in changes.$inc) {
            if (!changes.$inc.hasOwnProperty(i))
                continue;
            set.push(`${platform.quoteIdentifier(i)} = ${platform.quoteIdentifier(i)} + ${platform.quoteValue(changes.$inc[i])}`);
        }
    }
    if (changes.$unset) {
        for (const i in changes.$unset) {
            if (!changes.$unset.hasOwnProperty(i))
                continue;
            set.push(`${platform.quoteIdentifier(i)} = NULL`);
        }
    }
    return set;
}
class SQLQueryResolver extends orm_1.GenericQueryResolver {
    constructor(connectionPool, platform, classSchema, session) {
        super(classSchema, session);
        this.connectionPool = connectionPool;
        this.platform = platform;
        this.tableId = this.platform.getTableIdentifier.bind(this.platform);
        this.quoteIdentifier = this.platform.quoteIdentifier.bind(this.platform);
        this.quote = this.platform.quoteValue.bind(this.platform);
    }
    createFormatter(withIdentityMap = false) {
        return new sql_formatter_1.SqlFormatter(this.classSchema, sql_serializer_1.sqlSerializer, this.session.getHydrator(), withIdentityMap ? this.session.identityMap : undefined);
    }
    getTableIdentifier(schema) {
        return this.platform.getTableIdentifier(schema);
    }
    async count(model) {
        const sqlBuilder = new sql_builder_1.SqlBuilder(this.platform);
        const sql = sqlBuilder.build(this.classSchema, model, 'SELECT COUNT(*) as count');
        const connection = await this.connectionPool.getConnection(this.session.logger, this.session.transaction);
        try {
            const row = await connection.execAndReturnSingle(sql.sql, sql.params);
            //postgres has bigint as return type of COUNT, so we need to convert always
            return Number(row.count);
        }
        finally {
            connection.release();
        }
    }
    async delete(model, deleteResult) {
        if (model.hasJoins())
            throw new Error('Delete with joins not supported. Fetch first the ids then delete.');
        const sqlBuilder = new sql_builder_1.SqlBuilder(this.platform);
        const sql = sqlBuilder.build(this.classSchema, model, 'DELETE');
        const connection = await this.connectionPool.getConnection(this.session.logger, this.session.transaction);
        try {
            await connection.run(sql.sql, sql.params);
            deleteResult.modified = await connection.getChanges();
            //todo, implement deleteResult.primaryKeys
        }
        finally {
            connection.release();
        }
    }
    async find(model) {
        const sqlBuilder = new sql_builder_1.SqlBuilder(this.platform);
        const sql = sqlBuilder.select(this.classSchema, model);
        const connection = await this.connectionPool.getConnection(this.session.logger, this.session.transaction);
        try {
            const rows = await connection.execAndReturnAll(sql.sql, sql.params);
            const results = [];
            if (model.isAggregate() || model.sqlSelect) {
                //when aggregate the field types could be completely different, so don't normalize
                for (const row of rows)
                    results.push(row); //mysql returns not a real array, so we have to iterate
                return results;
            }
            const formatter = this.createFormatter(model.withIdentityMap);
            if (model.hasJoins()) {
                const converted = sqlBuilder.convertRows(this.classSchema, model, rows);
                for (const row of converted)
                    results.push(formatter.hydrate(model, row));
            }
            else {
                for (const row of rows)
                    results.push(formatter.hydrate(model, row));
            }
            return results;
        }
        catch (error) {
            throw new orm_1.DatabaseError(`Could not query ${this.classSchema.getClassName()} due to SQL error ${error}.\nSQL: ${sql.sql}\nParams: ${JSON.stringify(sql.params)}`);
        }
        finally {
            connection.release();
        }
    }
    async findOneOrUndefined(model) {
        const sqlBuilder = new sql_builder_1.SqlBuilder(this.platform);
        const sql = sqlBuilder.select(this.classSchema, model);
        const connection = await this.connectionPool.getConnection(this.session.logger, this.session.transaction);
        let row;
        try {
            row = await connection.execAndReturnSingle(sql.sql, sql.params);
            if (!row)
                return;
        }
        catch (error) {
            throw new orm_1.DatabaseError(`Could not query ${this.classSchema.getClassName()} due to SQL error ${error}.\nSQL: ${sql.sql}\nParams: ${JSON.stringify(sql.params)}`);
        }
        finally {
            connection.release();
        }
        if (model.isAggregate() || model.sqlSelect) {
            //when aggregate the field types could be completely different, so don't normalize
            return row;
        }
        const formatter = this.createFormatter(model.withIdentityMap);
        if (model.hasJoins()) {
            const [converted] = sqlBuilder.convertRows(this.classSchema, model, [row]);
            return formatter.hydrate(model, converted);
        }
        else {
            return formatter.hydrate(model, row);
        }
    }
    async has(model) {
        return await this.count(model) > 0;
    }
    async patch(model, changes, patchResult) {
        //this is the default SQL implementation that does not support RETURNING functionality (e.g. returning values from changes.$inc)
        const set = buildSetFromChanges(this.platform, this.classSchema, changes);
        const sqlBuilder = new sql_builder_1.SqlBuilder(this.platform);
        const sql = sqlBuilder.update(this.classSchema, model, set);
        const connection = await this.connectionPool.getConnection(this.session.logger, this.session.transaction);
        try {
            await connection.run(sql.sql, sql.params);
            patchResult.modified = await connection.getChanges();
        }
        finally {
            connection.release();
        }
    }
}
exports.SQLQueryResolver = SQLQueryResolver;
class SqlQueryParameter {
    constructor(value) {
        this.value = value;
    }
}
exports.SqlQueryParameter = SqlQueryParameter;
class SQLQueryIdentifier {
    constructor(id) {
        this.id = id;
    }
}
exports.SQLQueryIdentifier = SQLQueryIdentifier;
function identifier(id) {
    return new SQLQueryIdentifier(id);
}
exports.identifier = identifier;
class SqlQuery {
    constructor(parts) {
        this.parts = parts;
    }
    clone() {
        return new SqlQuery(this.parts.slice());
    }
    convertToSQL(platform, placeholderStrategy, tableName) {
        let sql = '';
        const params = [];
        for (const part of this.parts) {
            if (part instanceof SqlQuery) {
                sql += part.convertToSQL(platform, placeholderStrategy);
            }
            else if (part instanceof SQLQueryIdentifier) {
                const column = platform.quoteIdentifier(part.id);
                if (tableName) {
                    sql += tableName + '.' + column;
                }
                else {
                    sql += column;
                }
            }
            else if (part instanceof SqlQueryParameter) {
                if (part.value instanceof type_1.ClassSchema) {
                    sql += platform.getTableIdentifier(part.value);
                }
                else if (type_1.hasClassSchema(part.value)) {
                    sql += platform.getTableIdentifier(type_1.getClassSchema(part.value));
                }
                else {
                    sql += placeholderStrategy.getPlaceholder();
                    params.push(part.value);
                }
            }
            else {
                sql += part;
            }
        }
        return { sql, params };
    }
}
exports.SqlQuery = SqlQuery;
function sql(strings, ...params) {
    const parts = [strings[0]];
    for (let i = 1; i < strings.length; i++) {
        if (params[i - 1] instanceof SqlQuery
            || params[i - 1] instanceof SqlQueryParameter
            || params[i - 1] instanceof SQLQueryIdentifier) {
            parts.push(params[i - 1]);
        }
        else {
            parts.push(new SqlQueryParameter(params[i - 1]));
        }
        parts.push(strings[i]);
    }
    return new SqlQuery(parts);
}
exports.sql = sql;
class SQLDatabaseQuery extends orm_1.Query {
    constructor(classSchema, databaseSession, resolver) {
        super(classSchema, databaseSession, resolver);
        this.databaseSession = databaseSession;
        this.resolver = resolver;
        this.model = new SQLQueryModel();
        if (!databaseSession.withIdentityMap)
            this.model.withIdentityMap = false;
    }
    /**
     * Adds raw SQL to the where clause of the query.
     * If there is a `filter()` set as well, the where is added after the filter using AND.
     *
     * ```
     * database.query(User).where(`id > ${id}`).find();
     * ```
     *
     * Use `${identifier('name')} = ${'Peter'}` for column names that need to be quoted.
     */
    where(sql) {
        const c = this.clone();
        c.model.where = sql;
        return c;
    }
    /**
     * Adds additional selects to the query.
     * Automatically converts the query to a partial (no class instances).
     */
    sqlSelect(sql) {
        const c = this.clone();
        c.model.sqlSelect = sql;
        return c;
    }
}
exports.SQLDatabaseQuery = SQLDatabaseQuery;
class SQLDatabaseQueryFactory extends orm_1.DatabaseAdapterQueryFactory {
    constructor(connectionPool, platform, databaseSession) {
        super();
        this.connectionPool = connectionPool;
        this.platform = platform;
        this.databaseSession = databaseSession;
    }
    createQuery(classType) {
        return new SQLDatabaseQuery(type_1.getClassSchema(classType), this.databaseSession, new SQLQueryResolver(this.connectionPool, this.platform, type_1.getClassSchema(classType), this.databaseSession));
    }
}
exports.SQLDatabaseQueryFactory = SQLDatabaseQueryFactory;
class SqlMigrationHandler {
    constructor(database) {
        this.database = database;
        this.migrationEntity = type_1.t.schema({
            version: type_1.t.number.primary,
            created: type_1.t.date,
        }, { name: database.adapter.platform.getMigrationTableName() });
    }
    async setLatestMigrationVersion(version) {
        const session = this.database.createSession();
        session.add(type_1.plainToClass(this.migrationEntity, {
            version: version,
            created: new Date,
        }));
        await session.commit();
    }
    async removeMigrationVersion(version) {
        const session = this.database.createSession();
        await session.query(this.migrationEntity).filter({ version }).deleteOne();
    }
    async getLatestMigrationVersion() {
        const session = this.database.createSession();
        try {
            const version = await session.query(this.migrationEntity).sort({ version: 'desc' }).findOneOrUndefined();
            return version ? version.version : 0;
        }
        catch (error) {
            const connection = await this.database.adapter.connectionPool.getConnection();
            try {
                const [table] = this.database.adapter.platform.createTables([this.migrationEntity]);
                const createSql = this.database.adapter.platform.getAddTableDDL(table);
                for (const sql of createSql) {
                    await connection.run(sql);
                }
                return 0;
            }
            finally {
                connection.release();
            }
        }
    }
}
exports.SqlMigrationHandler = SqlMigrationHandler;
class RawQuery {
    constructor(session, connectionPool, platform, sql) {
        this.session = session;
        this.connectionPool = connectionPool;
        this.platform = platform;
        this.sql = sql;
    }
    /**
     * Executes the raw query and returns nothing.
     */
    async execute() {
        const sql = this.sql.convertToSQL(this.platform, new this.platform.placeholderStrategy);
        const connection = await this.connectionPool.getConnection(this.session.logger, this.session.transaction);
        try {
            return await connection.run(sql.sql, sql.params);
        }
        finally {
            connection.release();
        }
    }
    /**
     * Returns the raw result of a single row.
     */
    async findOne() {
        return (await this.find())[0];
    }
    /**
     * Returns the full result of a raw query.
     */
    async find() {
        const sql = this.sql.convertToSQL(this.platform, new this.platform.placeholderStrategy);
        const connection = await this.connectionPool.getConnection(this.session.logger, this.session.transaction);
        try {
            const res = await connection.execAndReturnAll(sql.sql, sql.params);
            return core_1.isArray(res) ? [...res] : [];
        }
        finally {
            connection.release();
        }
    }
}
exports.RawQuery = RawQuery;
class SqlRawFactory {
    constructor(session, connectionPool, platform) {
        this.session = session;
        this.connectionPool = connectionPool;
        this.platform = platform;
    }
    create(sql) {
        return new RawQuery(this.session, this.connectionPool, this.platform, sql);
    }
}
exports.SqlRawFactory = SqlRawFactory;
class SQLDatabaseAdapter extends orm_1.DatabaseAdapter {
    rawFactory(session) {
        return new SqlRawFactory(session, this.connectionPool, this.platform);
    }
    async getInsertBatchSize(schema) {
        return Math.floor(30000 / schema.getProperties().length);
    }
    async getUpdateBatchSize(schema) {
        return Math.floor(30000 / schema.getProperties().length);
    }
    isNativeForeignKeyConstraintSupported() {
        return true;
    }
    /**
     * Creates (and re-creates already existing) tables in the database.
     * This is only for testing purposes useful.
     *
     * WARNING: THIS DELETES ALL AFFECTED TABLES AND ITS CONTENT.
     */
    async createTables(classSchemas) {
        const connection = await this.connectionPool.getConnection();
        try {
            const database = new table_1.DatabaseModel();
            database.schemaName = this.getSchemaName();
            this.platform.createTables(classSchemas, database);
            const DDLs = this.platform.getAddTablesDDL(database);
            for (const sql of DDLs) {
                await connection.run(sql);
            }
        }
        finally {
            connection.release();
        }
    }
    async getMigrations(classSchemas) {
        const migrations = {};
        const connection = await this.connectionPool.getConnection();
        try {
            for (const entity of classSchemas) {
                const databaseModel = new table_1.DatabaseModel();
                databaseModel.schemaName = this.getSchemaName();
                this.platform.createTables(classSchemas, databaseModel);
                const schemaParser = new this.platform.schemaParserType(connection, this.platform);
                const parsedDatabaseModel = new table_1.DatabaseModel();
                parsedDatabaseModel.schemaName = this.getSchemaName();
                await schemaParser.parse(parsedDatabaseModel);
                const databaseDiff = table_1.DatabaseComparator.computeDiff(parsedDatabaseModel, databaseModel);
                if (databaseDiff) {
                    const table = databaseModel.getTableForSchema(entity);
                    databaseDiff.forTable(table);
                    const diff = databaseDiff.getDiff(table);
                    const upSql = this.platform.getModifyDatabaseDDL(databaseDiff);
                    if (upSql.length) {
                        migrations[entity.getName()] = { sql: upSql, diff: diff ? diff.toString() : '' };
                    }
                }
            }
        }
        finally {
            connection.release();
        }
        return migrations;
    }
    async migrate(classSchemas) {
        const connection = await this.connectionPool.getConnection();
        try {
            const databaseModel = new table_1.DatabaseModel();
            databaseModel.schemaName = this.getSchemaName();
            this.platform.createTables(classSchemas, databaseModel);
            const schemaParser = new this.platform.schemaParserType(connection, this.platform);
            const parsedDatabaseModel = new table_1.DatabaseModel();
            parsedDatabaseModel.schemaName = this.getSchemaName();
            await schemaParser.parse(parsedDatabaseModel);
            const databaseDiff = table_1.DatabaseComparator.computeDiff(parsedDatabaseModel, databaseModel);
            if (!databaseDiff) {
                return;
            }
            const upSql = this.platform.getModifyDatabaseDDL(databaseDiff);
            if (!upSql.length)
                return;
            for (const sql of upSql) {
                try {
                    await connection.run(sql);
                }
                catch (error) {
                    console.error('Could not execute migration SQL', sql, error);
                    throw error;
                }
            }
        }
        finally {
            connection.release();
        }
    }
}
exports.SQLDatabaseAdapter = SQLDatabaseAdapter;
class SQLPersistence extends orm_1.DatabasePersistence {
    constructor(platform, connectionPool, session) {
        super();
        this.platform = platform;
        this.connectionPool = connectionPool;
        this.session = session;
    }
    async getConnection() {
        if (!this.connection) {
            this.connection = await this.connectionPool.getConnection(this.session.logger, this.session.transaction);
        }
        return this.connection;
    }
    release() {
        if (this.connection)
            this.connection.release();
    }
    prepareAutoIncrement(classSchema, count) {
    }
    populateAutoIncrementFields(classSchema, items) {
    }
    async insert(classSchema, items) {
        await this.prepareAutoIncrement(classSchema, items.length);
        await this.doInsert(classSchema, items);
        await this.populateAutoIncrementFields(classSchema, items);
    }
    async update(classSchema, changeSets) {
        const batchSize = await this.session.adapter.getUpdateBatchSize(classSchema);
        if (batchSize > changeSets.length) {
            await this.batchUpdate(classSchema, changeSets);
        }
        else {
            for (let i = 0; i < changeSets.length; i += batchSize) {
                await this.batchUpdate(classSchema, changeSets.slice(i, i + batchSize));
            }
        }
    }
    async doInsert(classSchema, items) {
        const batchSize = await this.session.adapter.getInsertBatchSize(classSchema);
        if (batchSize > items.length) {
            await this.batchInsert(classSchema, items);
        }
        else {
            for (let i = 0; i < items.length; i += batchSize) {
                await this.batchInsert(classSchema, items.slice(i, i + batchSize));
            }
        }
    }
    async batchUpdate(classSchema, changeSets) {
        //simple update implementation that is not particular performant nor does it support atomic updates (like $inc)
        const scopeSerializer = this.platform.serializer.for(classSchema);
        const updates = [];
        for (const changeSet of changeSets) {
            const set = [];
            const where = [];
            const pk = scopeSerializer.partialSerialize(changeSet.primaryKey);
            for (const i in pk) {
                if (!pk.hasOwnProperty(i))
                    continue;
                where.push(`${this.platform.quoteIdentifier(i)} = ${this.platform.quoteValue(pk[i])}`);
            }
            const value = scopeSerializer.partialSerialize(changeSet.changes.$set || {});
            for (const i in value) {
                if (!value.hasOwnProperty(i))
                    continue;
                set.push(`${this.platform.quoteIdentifier(i)} = ${this.platform.quoteValue(value[i])}`);
            }
            updates.push(`UPDATE ${this.platform.getTableIdentifier(classSchema)} SET ${set.join(', ')} WHERE ${where.join(' AND ')}`);
        }
        const sql = updates.join(';\n');
        await (await this.getConnection()).run(sql);
    }
    async batchInsert(classSchema, items) {
        const scopeSerializer = this.platform.serializer.for(classSchema);
        const insert = [];
        const params = [];
        this.resetPlaceholderSymbol();
        const names = [];
        for (const property of classSchema.getProperties()) {
            if (property.isParentReference)
                continue;
            if (property.backReference)
                continue;
            if (property.isAutoIncrement)
                continue;
            names.push(this.platform.quoteIdentifier(property.name));
        }
        for (const item of items) {
            const converted = scopeSerializer.serialize(item);
            const row = [];
            for (const property of classSchema.getProperties()) {
                if (property.isParentReference)
                    continue;
                if (property.backReference)
                    continue;
                if (property.isAutoIncrement)
                    continue;
                const v = converted[property.name];
                params.push(v === undefined ? null : v);
                row.push(this.getPlaceholderSymbol());
            }
            insert.push(row.join(', '));
        }
        const sql = this.getInsertSQL(classSchema, names, insert);
        try {
            await (await this.getConnection()).run(sql, params);
        }
        catch (error) {
            console.warn('Insert failed', sql, params.length, params, error);
            throw error;
        }
    }
    resetPlaceholderSymbol() {
    }
    getPlaceholderSymbol() {
        return '?';
    }
    getInsertSQL(classSchema, fields, values) {
        return `INSERT INTO ${this.platform.getTableIdentifier(classSchema)} (${fields.join(', ')}) VALUES (${values.join('), (')})`;
    }
    async remove(classSchema, items) {
        const pks = [];
        const pk = classSchema.getPrimaryField();
        for (const item of items) {
            pks.push(item[pk.name]);
        }
        const inValues = pks.map(v => this.platform.quoteValue(v)).join(', ');
        const sql = `DELETE FROM ${this.platform.getTableIdentifier(classSchema)} WHERE ${this.platform.quoteIdentifier(pk.name)} IN (${inValues})`;
        await (await this.getConnection()).run(sql);
    }
}
exports.SQLPersistence = SQLPersistence;
//# sourceMappingURL=sql-adapter.js.map