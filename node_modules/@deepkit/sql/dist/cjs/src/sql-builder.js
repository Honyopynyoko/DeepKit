"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlBuilder = exports.Sql = void 0;
const type_1 = require("@deepkit/type");
const filter_1 = require("./filter");
class Sql {
    constructor(sql = '', params = []) {
        this.sql = sql;
        this.params = params;
    }
    appendSql(sql) {
        this.sql += ' ' + sql.sql;
        this.params.push(...sql.params);
    }
    append(sql, params) {
        this.sql += ' ' + sql;
        if (params)
            this.params.push(...params);
    }
}
exports.Sql = Sql;
class SqlBuilder {
    constructor(platform, params = []) {
        this.platform = platform;
        this.params = params;
        this.sqlSelect = [];
        this.joins = [];
        this.placeholderStrategy = new platform.placeholderStrategy();
        this.placeholderStrategy.offset = this.params.length;
    }
    appendWhereSQL(sql, schema, model, tableName, prefix = 'WHERE') {
        let whereClause = '';
        let whereParams = [];
        const placeholderStrategy = new this.platform.placeholderStrategy(sql.params.length);
        tableName = tableName || this.platform.getTableIdentifier(schema);
        if (model.filter) {
            const filter = filter_1.getSqlFilter(schema, model.filter, model.parameters, this.platform.serializer);
            const builder = this.platform.createSqlFilterBuilder(schema, tableName);
            builder.placeholderStrategy = placeholderStrategy;
            whereClause = builder.convert(filter);
            whereParams = builder.params;
        }
        if (whereClause || model.where) {
            sql.append(prefix);
            if (whereClause) {
                sql.params.push(...whereParams);
                sql.append(whereClause);
            }
            if (model.where) {
                if (whereClause)
                    sql.append('AND');
                const whereSql = model.where.convertToSQL(this.platform, placeholderStrategy, tableName);
                sql.params.push(...whereSql.params);
                sql.append(whereSql.sql);
            }
        }
    }
    appendHavingSQL(sql, schema, model, tableName) {
        if (!model.having)
            return;
        // tableName = tableName || this.platform.getTableIdentifier(schema);
        const filter = filter_1.getSqlFilter(schema, model.having, model.parameters, this.platform.serializer);
        const builder = this.platform.createSqlFilterBuilder(schema, '');
        builder.placeholderStrategy.offset = sql.params.length;
        const whereClause = builder.convert(filter);
        if (whereClause) {
            sql.append('HAVING');
            sql.params.push(...builder.params);
            sql.append(whereClause);
        }
    }
    selectColumns(schema, model) {
        const tableName = this.platform.getTableIdentifier(schema);
        const properties = model.select.size ? [...model.select.values()].map(name => schema.getProperty(name)) : schema.getProperties();
        if (model.aggregate.size || model.groupBy.size || model.sqlSelect) {
            //we select only whats aggregated
            for (const name of model.groupBy.values()) {
                this.sqlSelect.push(tableName + '.' + this.platform.quoteIdentifier(name));
            }
            for (const [as, a] of model.aggregate.entries()) {
                if (a.property.backReference)
                    continue;
                this.sqlSelect.push(this.platform.getAggregateSelect(tableName, a.property, a.func) + ' AS ' + this.platform.quoteIdentifier(as));
            }
            if (model.sqlSelect) {
                const build = model.sqlSelect?.convertToSQL(this.platform, this.placeholderStrategy, tableName);
                this.params.push(...build.params);
                this.sqlSelect.push(build.sql);
            }
        }
        else {
            for (const property of properties) {
                if (property.backReference)
                    continue;
                this.sqlSelect.push(tableName + '.' + this.platform.quoteIdentifier(property.name));
            }
        }
    }
    selectColumnsWithJoins(schema, model, refName = '') {
        const result = { startIndex: this.sqlSelect.length, fields: [] };
        const properties = model.select.size ? [...model.select.values()].map(name => schema.getProperty(name)) : schema.getProperties();
        const tableName = this.platform.getTableIdentifier(schema);
        for (const property of schema.getPrimaryFields()) {
            if (property.backReference)
                continue;
            result.fields.push(property);
            const as = this.platform.quoteIdentifier(this.sqlSelect.length + '');
            if (refName) {
                this.sqlSelect.push(this.platform.quoteIdentifier(refName) + '.' + this.platform.quoteIdentifier(property.name) + ' AS ' + as);
            }
            else {
                this.sqlSelect.push(tableName + '.' + this.platform.quoteIdentifier(property.name) + ' AS ' + as);
            }
        }
        for (const property of properties) {
            if (property.backReference)
                continue;
            if (property.isId)
                continue;
            result.fields.push(property);
            const as = this.platform.quoteIdentifier(this.sqlSelect.length + '');
            if (refName) {
                this.sqlSelect.push(this.platform.quoteIdentifier(refName) + '.' + this.platform.quoteIdentifier(property.name) + ' AS ' + as);
            }
            else {
                this.sqlSelect.push(tableName + '.' + this.platform.quoteIdentifier(property.name) + ' AS ' + as);
            }
        }
        for (const join of model.joins) {
            if (join.populate) {
                join.as = refName + '__' + join.propertySchema.name;
                const forJoinIndex = this.joins.length - 1;
                const joinMap = {
                    join,
                    forJoinIndex: forJoinIndex,
                    converter: (() => {
                        return {};
                    }),
                    startIndex: 0,
                };
                this.joins.push(joinMap);
                const map = this.selectColumnsWithJoins(join.query.classSchema, join.query.model, refName + '__' + join.propertySchema.name);
                joinMap.converter = this.buildConverter(map.startIndex, map.fields);
                joinMap.startIndex = map.startIndex;
            }
        }
        return result;
    }
    convertRows(schema, model, rows) {
        if (!this.rootConverter)
            throw new Error('No root converter set');
        if (!this.joins.length)
            return rows.map(v => this.rootConverter(v));
        const result = [];
        const itemsStack = [];
        const hashConverter = [];
        itemsStack.push(undefined); //root
        for (const join of this.joins) {
            itemsStack.push(undefined);
            hashConverter.push(type_1.getPrimaryKeyHashGenerator(join.join.query.classSchema, this.platform.serializer));
        }
        const rootPkHasher = type_1.getPrimaryKeyHashGenerator(schema, this.platform.serializer);
        for (const row of rows) {
            const converted = this.rootConverter(row);
            const pkHash = rootPkHasher(converted);
            if (!itemsStack[0] || itemsStack[0].hash !== pkHash) {
                if (itemsStack[0])
                    result.push(itemsStack[0].item);
                itemsStack[0] = { hash: pkHash, item: converted };
            }
            for (let joinId = 0; joinId < this.joins.length; joinId++) {
                const join = this.joins[joinId];
                if (!join.join.as)
                    continue;
                const converted = join.converter(row);
                if (!converted)
                    continue;
                const pkHash = hashConverter[joinId](converted);
                const forItem = itemsStack[join.forJoinIndex + 1].item;
                if (!itemsStack[joinId + 1] || itemsStack[joinId + 1].hash !== pkHash) {
                    itemsStack[joinId + 1] = { hash: pkHash, item: converted };
                }
                if (join.join.propertySchema.isArray) {
                    if (!forItem[join.join.as])
                        forItem[join.join.as] = [];
                    if (converted) {
                        //todo: set lastHash stack, so second level joins work as well
                        // we need to refactor lashHash to a stack first.
                        // const pkHasher = getPrimaryKeyHashGenerator(join.join.query.classSchema, this.platform.serializer);
                        // const pkHash = pkHasher(item);
                        forItem[join.join.as].push(converted);
                    }
                }
                else {
                    forItem[join.join.as] = converted;
                }
            }
        }
        if (itemsStack[0])
            result.push(itemsStack[0].item);
        return result;
    }
    buildConverter(startIndex, fields) {
        const lines = [];
        let primaryKeyIndex = startIndex;
        for (const field of fields) {
            if (field.isId)
                primaryKeyIndex = startIndex;
            lines.push(`'${field.name}': row[${startIndex++}]`);
        }
        const code = `
            return function(row) {
                if (null === row[${primaryKeyIndex}]) return;

                return {
                    ${lines.join(',\n')}
                };
            }
        `;
        return new Function(code)();
    }
    appendJoinSQL(sql, model, parentName, prefix = '') {
        if (!model.joins.length)
            return;
        for (const join of model.joins) {
            const tableName = this.platform.getTableIdentifier(join.query.classSchema);
            const joinName = this.platform.quoteIdentifier(prefix + '__' + join.propertySchema.name);
            const foreignSchema = join.query.classSchema;
            //many-to-many
            if (join.propertySchema.backReference && join.propertySchema.backReference.via) {
                const viaSchema = type_1.getClassSchema(type_1.resolveClassTypeOrForward(join.propertySchema.backReference.via));
                const pivotTableName = this.platform.getTableIdentifier(viaSchema);
                // JOIN pivotTableName as pivot ON (parent.id = pivot.left_foreign_id)
                // JOIN target ON (target.id = pivot.target_foreign_id)
                // viaSchema.name
                const pivotToLeft = viaSchema.findReverseReference(join.classSchema.classType, join.propertySchema);
                const pivotToRight = viaSchema.findReverseReference(join.query.classSchema.classType, join.propertySchema);
                const pivotName = this.platform.quoteIdentifier(prefix + '__p_' + join.propertySchema.name);
                //first pivot table
                sql.append(`${join.type.toUpperCase()} JOIN ${pivotTableName} AS ${pivotName} ON (`);
                sql.append(`${pivotName}.${this.platform.quoteIdentifier(pivotToLeft.name)} = ${parentName}.${this.platform.quoteIdentifier(join.classSchema.getPrimaryField().name)}`);
                sql.append(`)`);
                //then right table
                sql.append(`${join.type.toUpperCase()} JOIN ${tableName} AS ${joinName} ON (`);
                sql.append(`${pivotName}.${this.platform.quoteIdentifier(pivotToRight.name)} = ${joinName}.${this.platform.quoteIdentifier(join.query.classSchema.getPrimaryField().name)}`);
                this.appendWhereSQL(sql, join.query.classSchema, join.query.model, joinName, 'AND');
                sql.append(`)`);
                this.appendJoinSQL(sql, join.query.model, joinName, prefix + '__' + join.propertySchema.name);
                continue;
            }
            sql.append(`${join.type.toUpperCase()} JOIN ${tableName} AS ${joinName} ON (`);
            if (join.propertySchema.backReference && !join.propertySchema.backReference.via) {
                const backReference = foreignSchema.findReverseReference(join.classSchema.classType, join.propertySchema);
                sql.append(`${parentName}.${this.platform.quoteIdentifier(join.classSchema.getPrimaryField().name)} = ${joinName}.${this.platform.quoteIdentifier(backReference.name)}`);
            }
            else {
                sql.append(`${parentName}.${this.platform.quoteIdentifier(join.propertySchema.name)} = ${joinName}.${this.platform.quoteIdentifier(join.foreignPrimaryKey.name)}`);
            }
            this.appendWhereSQL(sql, join.query.classSchema, join.query.model, joinName, 'AND');
            sql.append(`)`);
            this.appendJoinSQL(sql, join.query.model, joinName, prefix + '__' + join.propertySchema.name);
        }
    }
    build(schema, model, head, withRange = true) {
        const tableName = this.platform.getTableIdentifier(schema);
        const sql = new Sql(`${head} FROM ${tableName}`, this.params);
        this.appendJoinSQL(sql, model, tableName);
        this.appendWhereSQL(sql, schema, model);
        if (withRange) {
            if (model.limit !== undefined)
                sql.append('LIMIT ' + this.platform.quoteValue(model.limit));
            if (model.skip !== undefined)
                sql.append('OFFSET ' + this.platform.quoteValue(model.skip));
        }
        return sql;
    }
    update(schema, model, set) {
        const tableName = this.platform.getTableIdentifier(schema);
        const primaryKey = schema.getPrimaryField();
        const select = this.select(schema, model, { select: [primaryKey.name] });
        return new Sql(`UPDATE ${tableName} SET ${set.join(', ')} WHERE ${this.platform.quoteIdentifier(primaryKey.name)} IN (SELECT * FROM (${select.sql}) as __)`, select.params);
    }
    select(schema, model, options = {}) {
        const manualSelect = options.select && options.select.length ? options.select : undefined;
        if (!manualSelect) {
            if (model.hasJoins()) {
                const map = this.selectColumnsWithJoins(schema, model, '');
                this.rootConverter = this.buildConverter(map.startIndex, map.fields);
            }
            else {
                this.selectColumns(schema, model);
            }
        }
        const order = [];
        if (model.sort) {
            for (const [name, sort] of Object.entries(model.sort)) {
                order.push(`${this.platform.quoteIdentifier(name)} ${sort}`);
            }
        }
        const sql = this.build(schema, model, 'SELECT ' + (manualSelect || this.sqlSelect).join(', '), false);
        if (model.groupBy.size) {
            const groupBy = [];
            for (const g of model.groupBy.values()) {
                groupBy.push(this.platform.quoteIdentifier(g));
            }
            sql.append('GROUP BY ' + groupBy.join(', '));
        }
        this.appendHavingSQL(sql, schema, model);
        if (order.length) {
            sql.append(' ORDER BY ' + (order.join(', ')));
        }
        if (model.limit !== undefined)
            sql.append('LIMIT ' + this.platform.quoteValue(model.limit));
        if (model.skip !== undefined)
            sql.append('OFFSET ' + this.platform.quoteValue(model.skip));
        return sql;
    }
}
exports.SqlBuilder = SqlBuilder;
//# sourceMappingURL=sql-builder.js.map