"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SQLFilterBuilder = void 0;
const core_1 = require("@deepkit/core");
const type_1 = require("@deepkit/type");
class SQLFilterBuilder {
    constructor(schema, tableName, serializer, placeholderStrategy, quoteValue, quoteId) {
        this.schema = schema;
        this.tableName = tableName;
        this.serializer = serializer;
        this.placeholderStrategy = placeholderStrategy;
        this.quoteValue = quoteValue;
        this.quoteId = quoteId;
        this.params = [];
    }
    isNull() {
        return 'IS NULL';
    }
    regexpComparator() {
        return 'REGEXP';
    }
    convert(filter) {
        return this.conditions(filter, 'AND').trim();
    }
    /**
     * Normalizes values necessary for the conection driver to bind parameters for prepared statements.
     * E.g. SQLite does not support boolean, so we convert boolean to number.
     */
    bindValue(value) {
        if (value === undefined)
            return null; //no SQL driver supports undefined
        if (value instanceof RegExp)
            return value.source;
        return value;
    }
    conditionsArray(filters, join) {
        const sql = [];
        for (const filter of filters) {
            sql.push(this.conditions(filter, 'AND'));
        }
        if (sql.length > 1)
            return '(' + sql.join(` ${join} `) + ')';
        return sql.join(` ${join} `);
    }
    quoteIdWithTable(id) {
        if (this.tableName)
            return `${this.tableName}.${this.quoteId(id)}`;
        return `${this.quoteId(id)}`;
    }
    condition(fieldName, value, comparison) {
        if (fieldName === undefined) {
            throw new Error('No comparison operators at root level allowed');
        }
        if (core_1.isPlainObject(value)) {
            return this.conditions(value, fieldName);
        }
        let cmpSign;
        if (comparison === 'eq')
            cmpSign = '=';
        else if (comparison === 'neq')
            cmpSign = '!=';
        else if (comparison === 'gt')
            cmpSign = '>';
        else if (comparison === 'gte')
            cmpSign = '>=';
        else if (comparison === 'lt')
            cmpSign = '<';
        else if (comparison === 'lte')
            cmpSign = '<=';
        else if (comparison === 'ne')
            cmpSign = '!=';
        else if (comparison === 'in')
            cmpSign = 'IN';
        else if (comparison === 'nin')
            cmpSign = 'NOT IN';
        else if (comparison === 'regex')
            cmpSign = this.regexpComparator();
        else
            throw new Error(`Comparator ${comparison} not supported.`);
        const isReference = 'string' === typeof value && value[0] === '$';
        let rvalue = '';
        if (isReference) {
            rvalue = `${this.quoteIdWithTable(value.substr(1))}`;
        }
        else {
            if (value === undefined || value === null) {
                cmpSign = this.isNull();
                rvalue = '';
            }
            else {
                const property = type_1.resolvePropertySchema(this.schema, fieldName);
                if (comparison === 'in' || comparison === 'nin') {
                    if (core_1.isArray(value)) {
                        const params = [];
                        for (let item of value) {
                            params.push(this.placeholderStrategy.getPlaceholder());
                            if (!property.isReference && !property.backReference && (property.type === 'class' || property.type === 'map' || property.type === 'array')) {
                                item = JSON.stringify(item);
                            }
                            this.params.push(this.bindValue(item));
                        }
                        rvalue = params.length ? `(${params.join(', ')})` : '(null)';
                    }
                }
                else {
                    rvalue = this.placeholderStrategy.getPlaceholder();
                    if (!property.isReference && !property.backReference && (property.type === 'class' || property.type === 'map' || property.type === 'array')) {
                        value = JSON.stringify(value);
                    }
                    this.params.push(this.bindValue(value));
                }
            }
        }
        // if (comparison === 'in' || comparison === 'nin') rvalue = '(' + rvalue + ')';
        if (fieldName.includes('.')) {
            const [column, path] = this.splitDeepFieldPath(fieldName);
            return `${this.getDeepColumnAccessor(this.tableName, column, path)} ${cmpSign} ${rvalue}`;
        }
        return `${this.quoteIdWithTable(fieldName)} ${cmpSign} ${rvalue}`;
    }
    getDeepColumnAccessor(table, column, path) {
        return `${table}.${this.quoteId(column)}->${this.quoteValue('$.' + path)}`;
    }
    splitDeepFieldPath(path) {
        const pos = path.indexOf('.');
        if (pos === -1)
            return [path, ''];
        return [path.substr(0, pos), path.substr(pos + 1)];
    }
    conditions(filter, fieldName) {
        const sql = [];
        for (const i in filter) {
            if (!filter.hasOwnProperty(i))
                continue;
            if (i === '$or')
                return this.conditionsArray(filter[i], 'OR');
            if (i === '$and')
                return this.conditionsArray(filter[i], 'AND');
            if (i === '$not')
                return `NOT ` + this.conditionsArray(filter[i], 'AND');
            if (i === '$exists')
                sql.push(this.quoteValue(this.schema.hasProperty(i)));
            else if (i[0] === '$')
                sql.push(this.condition(fieldName, filter[i], i.substr(1)));
            else
                sql.push(this.condition(i, filter[i], 'eq'));
        }
        if (sql.length > 1)
            return '(' + sql.join(` AND `) + ')';
        return sql.join(` AND `);
    }
}
exports.SQLFilterBuilder = SQLFilterBuilder;
//# sourceMappingURL=sql-filter-builder.js.map