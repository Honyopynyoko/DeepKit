"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schemaMigrationRoundTrip = exports.createSetup = void 0;
const orm_1 = require("@deepkit/orm");
const type_1 = require("@deepkit/type");
const table_1 = require("../src/schema/table");
const globals_1 = require("@jest/globals");
async function createSetup(adapter, schemas) {
    const database = new orm_1.Database(adapter);
    database.registerEntity(...schemas);
    await adapter.createTables([...database.entities]);
    return database;
}
exports.createSetup = createSetup;
async function schemaMigrationRoundTrip(types, adapter) {
    const originDatabaseModel = new table_1.DatabaseModel;
    adapter.platform.createTables(types, originDatabaseModel);
    const db = new orm_1.Database(adapter, types);
    const connection = await adapter.connectionPool.getConnection();
    try {
        await adapter.createTables([...db.entities]);
        const schemaParser = new adapter.platform.schemaParserType(connection, adapter.platform);
        // console.log(adapter.platform.getAddTablesDDL(originDatabaseModel));
        const readDatabaseModel = new table_1.DatabaseModel();
        await schemaParser.parse(readDatabaseModel, originDatabaseModel.getTableNames());
        globals_1.expect(readDatabaseModel.tables.length).toBe(types.length);
        for (const type of types) {
            const s = type_1.getClassSchema(type);
            const diff = table_1.TableComparator.computeDiff(originDatabaseModel.getTable(s.name), readDatabaseModel.getTable(s.name));
            if (diff)
                console.log('diff', s.getClassName(), diff);
            globals_1.expect(diff).toBe(undefined);
        }
    }
    finally {
        connection.release();
        globals_1.expect(adapter.connectionPool.getActiveConnections()).toBe(0);
        db.disconnect();
    }
}
exports.schemaMigrationRoundTrip = schemaMigrationRoundTrip;
//# sourceMappingURL=setup.js.map