"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const type_1 = require("@deepkit/type");
const sql_filter_builder_1 = require("../src/sql-filter-builder");
const sqlstring_1 = require("sqlstring");
const sql_adapter_1 = require("../src/sql-adapter");
const default_platform_1 = require("../src/platform/default-platform");
const schema_parser_1 = require("../src/reverse/schema-parser");
const sql_builder_1 = require("../src/sql-builder");
function quoteId(value) {
    return value;
}
class MySchemaParser extends schema_parser_1.SchemaParser {
    parse(database, limitTableNames) {
    }
}
class MyPlatform extends default_platform_1.DefaultPlatform {
    constructor() {
        super();
        this.schemaParserType = MySchemaParser;
        this.addType('number', 'integer');
    }
}
globals_1.test('sql query', () => {
    let User = class User {
    };
    User = __decorate([
        type_1.entity.name('user')
    ], User);
    const id = 0;
    const query = sql_adapter_1.sql `SELECT * FROM ${User} WHERE id > ${id}`;
    const generated = query.convertToSQL(new MyPlatform(), new default_platform_1.SqlPlaceholderStrategy());
    globals_1.expect(generated.sql).toBe('SELECT * FROM "user" WHERE id > ?');
    globals_1.expect(generated.params).toEqual([0]);
});
globals_1.test('select', () => {
    let User = class User {
        constructor() {
            this.id = 0;
        }
    };
    __decorate([
        type_1.t.required,
        __metadata("design:type", Number)
    ], User.prototype, "id", void 0);
    __decorate([
        type_1.t.required,
        __metadata("design:type", String)
    ], User.prototype, "username", void 0);
    User = __decorate([
        type_1.entity.name('user-select')
    ], User);
    {
        const builder = new sql_builder_1.SqlBuilder(new MyPlatform());
        const model = new sql_adapter_1.SQLQueryModel();
        const builtSQL = builder.select(type_1.getClassSchema(User), model);
        globals_1.expect(builtSQL.sql).toBe(`SELECT "user-select"."id", "user-select"."username" FROM "user-select"`);
    }
    {
        const builder = new sql_builder_1.SqlBuilder(new MyPlatform());
        const model = new sql_adapter_1.SQLQueryModel();
        model.sqlSelect = sql_adapter_1.sql `count(*) as count`;
        const builtSQL = builder.select(type_1.getClassSchema(User), model);
        globals_1.expect(builtSQL.sql).toBe(`SELECT count(*) as count FROM "user-select"`);
        globals_1.expect(model.isPartial()).toBe(true);
    }
});
globals_1.test('QueryToSql', () => {
    const User = type_1.t.class({
        id: type_1.t.number,
        username: type_1.t.string,
        password: type_1.t.string,
        disabled: type_1.t.boolean,
        created: type_1.t.date,
    });
    const queryToSql = new sql_filter_builder_1.SQLFilterBuilder(type_1.getClassSchema(User), quoteId('user'), type_1.jsonSerializer, new default_platform_1.SqlPlaceholderStrategy(), sqlstring_1.escape, quoteId);
    globals_1.expect(queryToSql.convert({ id: 123 })).toBe(`user.id = ?`);
    globals_1.expect(queryToSql.convert({ id: '$id' })).toBe(`user.id = user.id`);
    globals_1.expect(queryToSql.convert({ username: 'Peter' })).toBe(`user.username = ?`);
    globals_1.expect(queryToSql.convert({ id: 44, username: 'Peter' })).toBe(`(user.id = ? AND user.username = ?)`);
    globals_1.expect(queryToSql.convert({ $or: [{ id: 44 }, { username: 'Peter' }] })).toBe(`(user.id = ? OR user.username = ?)`);
    globals_1.expect(queryToSql.convert({ $and: [{ id: 44 }, { username: 'Peter' }] })).toBe(`(user.id = ? AND user.username = ?)`);
    globals_1.expect(queryToSql.convert({ id: { $ne: 44 } })).toBe(`user.id != ?`);
    globals_1.expect(queryToSql.convert({ id: { $eq: 44 } })).toBe(`user.id = ?`);
    globals_1.expect(queryToSql.convert({ id: { $gt: 44 } })).toBe(`user.id > ?`);
    globals_1.expect(queryToSql.convert({ id: { $gte: 44 } })).toBe(`user.id >= ?`);
    globals_1.expect(queryToSql.convert({ id: { $lt: 44 } })).toBe(`user.id < ?`);
    globals_1.expect(queryToSql.convert({ id: { $lte: 44 } })).toBe(`user.id <= ?`);
    globals_1.expect(queryToSql.convert({ id: { $in: [44, 55] } })).toBe(`user.id IN (?, ?)`);
    globals_1.expect(() => queryToSql.convert({ invalidField: { $nin: [44, 55] } })).toThrowError('invalidField not found');
    globals_1.expect(queryToSql.convert({ id: { $nin: [44, 55] } })).toBe(`user.id NOT IN (?, ?)`);
    globals_1.expect(() => queryToSql.convert({ id: { $oasdads: 123 } })).toThrow('not supported');
});
//# sourceMappingURL=sql-query.spec.js.map