/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { DatabaseModel, Table } from '../schema/table';
import { binaryTypes, getClassSchema, isArray } from '@deepkit/type';
import sqlstring from 'sqlstring';
import { isObject } from '@deepkit/core';
import { sqlSerializer } from '../serializer/sql-serializer';
import { SQLFilterBuilder } from '../sql-filter-builder';
export function isSet(v) {
    return v !== '' && v !== undefined && v !== null;
}
export class DefaultNamingStrategy {
    getColumnName(property) {
        return property.name;
    }
    getTableName(classSchema) {
        return classSchema.getCollectionName();
    }
}
export class SqlPlaceholderStrategy {
    constructor(offset = 0) {
        this.offset = offset;
    }
    getPlaceholder() {
        return '?';
    }
}
export class DefaultPlatform {
    constructor() {
        this.defaultSqlType = 'text';
        this.typeMapping = new Map();
        this.nativeTypeInformation = new Map();
        this.serializer = sqlSerializer;
        this.namingStrategy = new DefaultNamingStrategy();
        this.placeholderStrategy = SqlPlaceholderStrategy;
    }
    typeCast(schema, name) {
        let property = schema.getProperty(name);
        if (property.type === 'string')
            return '';
        if (property.isReference)
            property = property.getResolvedClassSchema().getPrimaryField();
        const type = this.typeMapping.get(property.type);
        if (!type)
            return '';
        return '::' + type.sqlType;
    }
    createSqlFilterBuilder(schema, tableName) {
        return new SQLFilterBuilder(schema, tableName, this.serializer, new this.placeholderStrategy, this.quoteValue.bind(this), this.quoteIdentifier.bind(this));
    }
    getMigrationTableName() {
        return `deepkit_orm_migration`;
    }
    quoteValue(value) {
        if (!(value instanceof Date) && (isObject(value) || isArray(value)))
            return sqlstring.escape(JSON.stringify(value));
        return sqlstring.escape(value);
    }
    getAggregateSelect(tableName, property, func) {
        return `${func}(${tableName}.${this.quoteIdentifier(property.name)})`;
    }
    addBinaryType(sqlType, size, scale) {
        for (const type of binaryTypes) {
            this.addType(type, sqlType, size, scale);
        }
    }
    addType(marshalType, sqlType, size, scale) {
        this.typeMapping.set(marshalType, { sqlType, size, scale });
    }
    getColumnListDDL(columns) {
        return columns.map(v => this.getIdentifier(v)).join(', ');
    }
    getSchemaDelimiter() {
        return '.';
    }
    /**
     * If the platform supports the `PRIMARY KEY` section in `CREATE TABLE(column, column, PRIMARY KEY())`;
     */
    supportsInlinePrimaryKey() {
        return true;
    }
    /**
     * If the platform supports the `CONSTRAINT %s FOREIGN KEY` section in `CREATE TABLE(column, column, CONSTRAINT %s FOREIGN KEY)`;
     */
    supportsInlineForeignKey() {
        return true;
    }
    getPrimaryKeyDDL(table) {
        if (!table.hasPrimaryKey())
            return '';
        return `PRIMARY KEY (${this.getColumnListDDL(table.getPrimaryKeys())})`;
    }
    normalizeTables(tables) {
    }
    getEntityFields(schema) {
        const fields = [];
        for (const property of schema.getProperties()) {
            if (property.isParentReference)
                continue;
            if (property.backReference)
                continue;
            fields.push(property);
        }
        return fields;
    }
    setColumnType(column, typeProperty) {
        column.type = this.defaultSqlType;
        const map = this.typeMapping.get(typeProperty.type);
        if (map) {
            column.type = map.sqlType;
            column.size = map.size;
            column.scale = map.scale;
        }
    }
    getModifyDatabaseDDL(databaseDiff) {
        const lines = [];
        for (const table of databaseDiff.removedTables)
            lines.push(this.getDropTableDDL(table));
        for (const [from, to] of databaseDiff.renamedTables)
            lines.push(this.getRenameTableDDL(from, to));
        for (const table of databaseDiff.addedTables) {
            lines.push(...this.getAddTableDDL(table));
            lines.push(...this.getAddIndicesDDL(table));
        }
        for (const tableDiff of databaseDiff.modifiedTables)
            lines.push(...this.getModifyTableDDL(tableDiff));
        if (!this.supportsInlineForeignKey()) {
            for (const table of databaseDiff.addedTables)
                lines.push(...this.getAddForeignKeysDDL(table));
        }
        if (lines.length) {
            lines.unshift(this.getBeginDDL());
            lines.push(this.getEndDDL());
        }
        return lines.filter(isSet);
    }
    createTables(schemas, database = new DatabaseModel()) {
        const mergedToSingleTable = new Set();
        const refs = new Map();
        for (let schema of schemas) {
            schema = getClassSchema(schema);
            if (schema.singleTableInheritance) {
                if (!schema.superClass)
                    throw new Error(`Class ${schema.getClassName()} has singleTableInheritance enabled but no super class.`);
                if (mergedToSingleTable.has(schema.superClass))
                    continue;
                mergedToSingleTable.add(schema.superClass);
                const discriminant = schema.superClass.getSingleTableInheritanceDiscriminant();
                const old = schema;
                schema = schema.superClass.clone();
                refs.set(old.superClass, schema);
                //add all properties from all sub classes.
                for (const subSchema of schema.subClasses) {
                    for (let property of subSchema.getProperties()) {
                        if (schema.hasProperty(property.name))
                            continue;
                        property = property.clone();
                        property.isOptional = true;
                        schema.registerProperty(property);
                    }
                }
                schema.getProperty(discriminant.name).isOptional = false;
            }
            const table = new Table(this.namingStrategy.getTableName(schema));
            database.schemaMap.set(schema, table);
            table.schemaName = schema.databaseSchemaName || database.schemaName;
            for (const property of this.getEntityFields(schema)) {
                if (property.backReference)
                    continue;
                const column = table.addColumn(this.namingStrategy.getColumnName(property), property);
                if (!property.isAutoIncrement) {
                    column.defaultValue = property.getDefaultValue();
                }
                const isNullable = property.isNullable || property.isOptional;
                column.isNotNull = !isNullable;
                column.isPrimaryKey = property.isId;
                if (property.isAutoIncrement) {
                    column.isAutoIncrement = true;
                    column.isNotNull = true;
                }
                const typeProperty = property.isReference ? property.getResolvedClassSchema().getPrimaryField() : property;
                this.setColumnType(column, typeProperty);
            }
        }
        //set foreign keys
        for (let [schema, table] of database.schemaMap.entries()) {
            for (const property of schema.getProperties()) {
                if (!property.isReference)
                    continue;
                const foreignSchema = property.getResolvedClassSchema();
                const foreignTable = database.schemaMap.get(refs.get(foreignSchema) || foreignSchema);
                if (!foreignTable) {
                    throw new Error(`Referenced entity ${foreignSchema.getClassName()} from ${schema.getClassName()}.${property.name} is not available`);
                }
                const foreignKey = table.addForeignKey('', foreignTable);
                foreignKey.localColumns = [table.getColumn(property.name)];
                foreignKey.foreignColumns = foreignTable.getPrimaryKeys();
                foreignKey.onDelete = property.referenceOptions.onDelete;
                foreignKey.onUpdate = property.referenceOptions.onUpdate;
            }
        }
        //create index
        for (let [schema, table] of database.schemaMap.entries()) {
            for (const [name, index] of schema.indices.entries()) {
                if (table.hasIndexByName(name))
                    continue;
                const columns = index.fields.map(v => table.getColumn(v));
                if (table.hasIndex(columns, index.options.unique))
                    continue;
                const addedIndex = table.addIndex(name, index.options.unique);
                addedIndex.columns = columns;
                addedIndex.spatial = index.options.spatial || false;
            }
            //sqlite and postgres do not create a index for foreign keys. But this
            //is rather important for back referencing joins.
            for (const foreignKeys of table.foreignKeys) {
                if (table.hasIndex(foreignKeys.localColumns))
                    continue;
                //there's no need to add an index to a foreign key that is a primary key
                const allPrimaryKey = foreignKeys.localColumns.every(v => v.isPrimaryKey);
                if (allPrimaryKey)
                    continue;
                const index = table.addIndex(foreignKeys.getName(), false);
                index.columns = foreignKeys.localColumns;
            }
            //manual composite indices
            for (const property of schema.getProperties()) {
                if (!property.index)
                    continue;
                const column = table.getColumnForProperty(property);
                if (table.hasIndex([column], property.index.unique))
                    continue;
                const index = table.addIndex('', property.index.unique);
                index.columns = [column];
            }
        }
        const tables = [...database.schemaMap.values()];
        this.normalizeTables(tables);
        database.tables = tables;
        return tables;
    }
    quoteIdentifier(id) {
        return `"${id.replace('.', '"."')}"`;
    }
    getTableIdentifier(schema) {
        const collectionName = this.namingStrategy.getTableName(schema);
        if (schema.databaseSchemaName)
            return this.quoteIdentifier(schema.databaseSchemaName + this.getSchemaDelimiter() + collectionName);
        return this.quoteIdentifier(collectionName);
    }
    getIdentifier(object, append = '') {
        if (object instanceof Table)
            return this.getFullIdentifier(object, append);
        return this.quoteIdentifier(object.getName() + append);
    }
    getFullIdentifier(object, append = '') {
        return this.quoteIdentifier(object.getFullName(this.getSchemaDelimiter()) + append);
    }
    getPrimaryKeyName(table) {
        return this.getFullIdentifier(table, '_pk');
    }
    getDropPrimaryKeyDDL(table) {
        if (!table.hasPrimaryKey())
            return '';
        return `ALTER TABLE ${this.getIdentifier(table)} DROP CONSTRAINT ${this.getPrimaryKeyName(table)}`;
    }
    getAddPrimaryKeyDDL(table) {
        return `ALTER TABLE ${this.getIdentifier(table)} ADD ${this.getPrimaryKeyDDL(table)}`;
    }
    getBeginDDL() {
        return '';
    }
    getEndDDL() {
        return '';
    }
    getAddTablesDDL(database) {
        const ddl = [];
        ddl.push(this.getBeginDDL());
        for (const table of database.tables) {
            ddl.push(this.getDropTableDDL(table));
            ddl.push(...this.getAddTableDDL(table));
            ddl.push(...this.getAddIndicesDDL(table));
        }
        for (const table of database.tables) {
            if (!this.supportsInlineForeignKey())
                ddl.push(...this.getAddForeignKeysDDL(table));
        }
        ddl.push(this.getEndDDL());
        return ddl.filter(isSet);
    }
    getAddSchemasDDL(database) {
        const schemaNames = new Set();
        if (database.schemaName)
            schemaNames.add(database.schemaName);
        for (const table of database.tables) {
            if (table.schemaName)
                schemaNames.add(table.schemaName);
        }
        return [...schemaNames.values()].map(v => this.getAddSchemaDDL(v)).join(';\n');
    }
    getAddSchemaDDL(schemaName) {
        if (!schemaName)
            return '';
        return `CREATE SCHEMA ${this.quoteIdentifier(schemaName)}`;
    }
    getUseSchemaDDL(table) {
        return ``;
    }
    getResetSchemaDDL(table) {
        return ``;
    }
    getRenameTableDDL(from, to) {
        return `ALTER TABLE ${this.getIdentifier(from)} RENAME TO ${this.getIdentifier(to)}`;
    }
    getModifyTableDDL(diff) {
        const ddl = [];
        // drop indices, foreign keys
        for (const foreignKey of diff.removedFKs.values())
            ddl.push(this.getDropForeignKeyDDL(foreignKey));
        for (const [from] of diff.modifiedFKs.values())
            ddl.push(this.getDropForeignKeyDDL(from));
        for (const index of diff.removedIndices.values())
            ddl.push(this.getDropIndexDDL(index));
        for (const [from] of diff.modifiedIndices.values())
            ddl.push(this.getDropIndexDDL(from));
        //merge field changes into one command. This is more compatible especially with PK constraints.
        const alterTableLines = [];
        function add(value) {
            if (value.trim().startsWith('ALTER TABLE')) {
                alterTableLines.push(value.trim().substr('ALTER TABLE '.length));
            }
            else {
                ddl.push(value);
            }
        }
        // alter entity structure
        if (diff.hasModifiedPk())
            add(this.getDropPrimaryKeyDDL(diff.from));
        for (const [from, to] of diff.renamedColumns.values())
            add(this.getRenameColumnDDL(from, to));
        if (diff.modifiedColumns.length)
            for (const columnDiff of diff.modifiedColumns)
                add(this.getModifyColumnDDL(columnDiff));
        if (diff.addedColumns.length)
            for (const column of diff.addedColumns)
                add(this.getAddColumnDDL(column));
        for (const column of diff.removedColumns.values())
            add(this.getRemoveColumnDDL(column));
        if (diff.hasModifiedPk())
            add(this.getAddPrimaryKeyDDL(diff.to));
        if (alterTableLines.length) {
            ddl.push(`ALTER TABLE ${alterTableLines.join(', ')}`);
        }
        // create indices, foreign keys
        for (const [, to] of diff.modifiedIndices.values())
            ddl.push(this.getAddIndexDDL(to));
        for (const index of diff.addedIndices.values())
            ddl.push(this.getAddIndexDDL(index));
        for (const [, to] of diff.modifiedFKs.values())
            ddl.push(this.getAddForeignKeyDDL(to));
        for (const foreignKey of diff.addedFKs.values())
            ddl.push(this.getAddForeignKeyDDL(foreignKey));
        return ddl.filter(isSet);
    }
    getAddTableDDL(table) {
        const lines = [];
        lines.push(this.getUseSchemaDDL(table));
        lines.push(this.getCreateTableDDL(table));
        lines.push(this.getResetSchemaDDL(table));
        return lines.filter(isSet);
    }
    getCreateTableDDL(table) {
        const lines = [];
        for (const column of table.columns)
            lines.push(this.getColumnDDL(column));
        if (this.supportsInlinePrimaryKey() && table.hasPrimaryKey())
            lines.push(this.getPrimaryKeyDDL(table));
        if (this.supportsInlineForeignKey())
            for (const foreignKey of table.foreignKeys)
                lines.push(this.getForeignKeyDDL(foreignKey));
        return `CREATE TABLE ${this.getIdentifier(table)} (\n    ${lines.join(',\n    ')}\n)`;
    }
    getAddForeignKeysDDL(table) {
        return table.foreignKeys.map(v => this.getAddForeignKeyDDL(v)).filter(isSet);
    }
    getAddIndicesDDL(table) {
        return table.indices.map(v => this.getAddIndexDDL(v));
    }
    getAddForeignKeyDDL(foreignKey) {
        return `ALTER TABLE ${this.getIdentifier(foreignKey.table)} ADD ${this.getForeignKeyDDL(foreignKey)}`;
    }
    getForeignKeyDDL(foreignKey) {
        const ddl = [];
        ddl.push(`
        CONSTRAINT ${this.getIdentifier(foreignKey)}
        FOREIGN KEY (${this.getColumnListDDL(foreignKey.localColumns)})
        REFERENCES ${this.getIdentifier(foreignKey.foreign)} (${this.getColumnListDDL(foreignKey.foreignColumns)})
        `.trim());
        if (foreignKey.onUpdate)
            ddl.push(`ON UPDATE ${foreignKey.onUpdate}`);
        if (foreignKey.onDelete)
            ddl.push(`ON DELETE ${foreignKey.onDelete}`);
        return ddl.join(' ');
    }
    getAddIndexDDL(index) {
        const u = index.isUnique ? 'UNIQUE' : '';
        const columns = [];
        for (const column of index.columns) {
            if (index.size) {
                columns.push(`${this.getIdentifier(column)}(${index.size})`);
                continue;
            }
            const typeInfo = this.nativeTypeInformation.get(column.type || '');
            if (typeInfo && typeInfo.needsIndexPrefix) {
                columns.push(`${this.getIdentifier(column)}(${typeInfo.defaultIndexSize || 100})`);
                continue;
            }
            columns.push(`${this.getIdentifier(column)}`);
        }
        return `CREATE ${u} INDEX ${this.getIdentifier(index)} ON ${this.getIdentifier(index.table)} (${columns.join(', ')})`;
    }
    getDropTableDDL(table) {
        return `DROP TABLE IF EXISTS ${this.getIdentifier(table)}`;
    }
    // getAddColumnDDL(column: Column): string {
    //     return `ALTER TABLE ${this.getIdentifier(column.table)} ADD ${this.getColumnDDL(column)}`;
    // }
    getRemoveColumnDDL(column) {
        return `ALTER TABLE ${this.getIdentifier(column.table)} DROP COLUMN ${this.getIdentifier(column)}`;
    }
    getRenameColumnDDL(from, to) {
        return `ALTER TABLE ${this.getIdentifier(from.table)} RENAME COLUMN ${this.getIdentifier(from)} TO ${this.getIdentifier(to)}`;
    }
    // getModifyColumnDDL(column: Column): string {
    //     return `ALTER TABLE ${this.getIdentifier(column.table)} MODIFY ${this.getColumnDDL(column)}`;
    // }
    getModifyColumnDDL(diff) {
        return `ALTER TABLE ${this.getIdentifier(diff.to.table)} MODIFY ${this.getColumnDDL(diff.to)}`;
    }
    getAddColumnDDL(column) {
        return `ALTER TABLE ${this.getIdentifier(column.table)} ADD ${this.getColumnDDL(column)}`;
    }
    getDropForeignKeyDDL(foreignKey) {
        return `ALTER TABLE ${this.getIdentifier(foreignKey.table)} DROP CONSTRAINT ${this.getIdentifier(foreignKey)}`;
    }
    getDropIndexDDL(index) {
        return `DROP INDEX ${this.getIdentifier(index)}`;
    }
    getUniqueDDL(unique) {
        return `UNIQUE INDEX ${this.getIdentifier(unique)} (${this.getColumnListDDL(unique.columns)})`;
    }
    getColumnDDL(column) {
        const ddl = [];
        ddl.push(this.getIdentifier(column));
        ddl.push((column.type || 'INTEGER') + column.getSizeDefinition());
        ddl.push(this.getColumnDefaultValueDDL(column));
        ddl.push(column.isNotNull ? this.getNotNullString() : this.getNullString());
        if (column.isAutoIncrement)
            ddl.push(this.getAutoIncrement());
        return ddl.filter(isSet).join(' ');
    }
    getColumnDefaultValueDDL(column) {
        if (undefined === column.defaultValue)
            return '';
        //todo: allow to add expressions, like CURRENT_TIMESTAMP
        return 'DEFAULT ' + this.quoteValue(isObject(column.defaultValue) ? JSON.stringify(column.defaultValue) : column.defaultValue);
    }
    getAutoIncrement() {
        return 'IDENTITY';
    }
    getNotNullString() {
        return 'NOT NULL';
    }
    getNullString() {
        return 'NULL';
    }
}
//# sourceMappingURL=default-platform.js.map