import { ClassType, Mutex } from '@deepkit/core';
import { DatabaseAdapter, DatabaseLogger, DatabasePersistenceChangeSet, DatabaseSession, DatabaseTransaction, DeleteResult, Entity, PatchResult } from '@deepkit/orm';
import { DefaultPlatform, SQLConnection, SQLConnectionPool, SQLDatabaseAdapter, SQLDatabaseQuery, SQLDatabaseQueryFactory, SQLPersistence, SQLQueryModel, SQLQueryResolver, SQLStatement } from '@deepkit/sql';
import { Changes, ClassSchema } from '@deepkit/type';
import sqlite3 from 'better-sqlite3';
import { SQLitePlatform } from './sqlite-platform';
export declare class SQLiteStatement extends SQLStatement {
    protected logger: DatabaseLogger;
    protected sql: string;
    protected stmt: sqlite3.Statement;
    constructor(logger: DatabaseLogger, sql: string, stmt: sqlite3.Statement);
    get(params?: any[]): Promise<any>;
    all(params?: any[]): Promise<any[]>;
    release(): void;
}
export declare class SQLiteConnection extends SQLConnection {
    protected db: sqlite3.Database;
    platform: SQLitePlatform;
    protected changes: number;
    constructor(connectionPool: SQLConnectionPool, db: sqlite3.Database, logger?: DatabaseLogger);
    prepare(sql: string): Promise<SQLiteStatement>;
    run(sql: string, params?: any[]): Promise<void>;
    exec(sql: string): Promise<void>;
    getChanges(): Promise<number>;
}
export declare class SQLiteConnectionPool extends SQLConnectionPool {
    protected db: sqlite3.Database;
    protected connectionMutex: Mutex;
    constructor(db: sqlite3.Database);
    getConnection(logger?: DatabaseLogger, transaction?: DatabaseTransaction): Promise<SQLiteConnection>;
    release(connection: SQLConnection): void;
}
export declare class SQLitePersistence extends SQLPersistence {
    protected platform: DefaultPlatform;
    connectionPool: SQLiteConnectionPool;
    constructor(platform: DefaultPlatform, connectionPool: SQLiteConnectionPool, database: DatabaseSession<any>);
    batchUpdate<T extends Entity>(classSchema: ClassSchema<T>, changeSets: DatabasePersistenceChangeSet<T>[]): Promise<void>;
    protected populateAutoIncrementFields<T>(classSchema: ClassSchema<T>, items: T[]): Promise<void>;
}
export declare class SQLiteQueryResolver<T extends Entity> extends SQLQueryResolver<T> {
    protected connectionPool: SQLiteConnectionPool;
    protected platform: DefaultPlatform;
    constructor(connectionPool: SQLiteConnectionPool, platform: DefaultPlatform, classSchema: ClassSchema<T>, databaseSession: DatabaseSession<DatabaseAdapter>);
    delete(model: SQLQueryModel<T>, deleteResult: DeleteResult<T>): Promise<void>;
    patch(model: SQLQueryModel<T>, changes: Changes<T>, patchResult: PatchResult<T>): Promise<void>;
}
export declare class SQLiteDatabaseQuery<T> extends SQLDatabaseQuery<T> {
}
export declare class SQLiteDatabaseQueryFactory extends SQLDatabaseQueryFactory {
    protected connectionPool: SQLiteConnectionPool;
    constructor(connectionPool: SQLiteConnectionPool, platform: DefaultPlatform, databaseSession: DatabaseSession<any>);
    createQuery<T extends Entity>(classType: ClassType<T> | ClassSchema<T>): SQLiteDatabaseQuery<T>;
}
export declare class SQLiteDatabaseAdapter extends SQLDatabaseAdapter {
    protected sqlitePath: string;
    readonly db: sqlite3.Database;
    readonly connectionPool: SQLiteConnectionPool;
    readonly platform: SQLitePlatform;
    constructor(sqlitePath?: string);
    getInsertBatchSize(schema: ClassSchema): Promise<number>;
    getName(): string;
    getSchemaName(): string;
    createPersistence(session: DatabaseSession<any>): SQLPersistence;
    queryFactory(databaseSession: DatabaseSession<any>): SQLDatabaseQueryFactory;
    disconnect(force?: boolean): void;
}
