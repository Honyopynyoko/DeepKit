"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SQLiteDatabaseAdapter = exports.SQLiteDatabaseQueryFactory = exports.SQLiteDatabaseQuery = exports.SQLiteQueryResolver = exports.SQLitePersistence = exports.SQLiteConnectionPool = exports.SQLiteConnection = exports.SQLiteStatement = void 0;
const core_1 = require("@deepkit/core");
const sql_1 = require("@deepkit/sql");
const type_1 = require("@deepkit/type");
const better_sqlite3_1 = __importDefault(require("better-sqlite3"));
const sqlite_platform_1 = require("./sqlite-platform");
class SQLiteStatement extends sql_1.SQLStatement {
    constructor(logger, sql, stmt) {
        super();
        this.logger = logger;
        this.sql = sql;
        this.stmt = stmt;
    }
    async get(params = []) {
        try {
            const res = this.stmt.get(...params);
            this.logger.logQuery(this.sql, params);
            return res;
        }
        catch (error) {
            this.logger.failedQuery(error, this.sql, params);
            throw error;
        }
    }
    async all(params = []) {
        try {
            const res = this.stmt.all(...params);
            this.logger.logQuery(this.sql, params);
            return res;
        }
        catch (error) {
            this.logger.failedQuery(error, this.sql, params);
            throw error;
        }
    }
    release() {
    }
}
exports.SQLiteStatement = SQLiteStatement;
class SQLiteConnection extends sql_1.SQLConnection {
    constructor(connectionPool, db, logger) {
        super(connectionPool, logger);
        this.db = db;
        this.platform = new sqlite_platform_1.SQLitePlatform();
        this.changes = 0;
    }
    async prepare(sql) {
        return new SQLiteStatement(this.logger, sql, this.db.prepare(sql));
    }
    async run(sql, params = []) {
        try {
            const stmt = this.db.prepare(sql);
            this.logger.logQuery(sql, params);
            const result = stmt.run(...params);
            this.changes = result.changes;
        }
        catch (error) {
            this.logger.failedQuery(error, sql, params);
            throw error;
        }
    }
    async exec(sql) {
        try {
            this.db.exec(sql);
            this.logger.logQuery(sql, []);
        }
        catch (error) {
            this.logger.failedQuery(error, sql, []);
            throw error;
        }
    }
    async getChanges() {
        return this.changes;
    }
}
exports.SQLiteConnection = SQLiteConnection;
class SQLiteConnectionPool extends sql_1.SQLConnectionPool {
    constructor(db) {
        super();
        this.db = db;
        this.connectionMutex = new core_1.Mutex();
    }
    async getConnection(logger, transaction) {
        //todo: handle transaction, when given we make sure we return a sticky connection to the transaction
        // and release the stickiness when transaction finished.
        await this.connectionMutex.lock();
        this.activeConnections++;
        return new SQLiteConnection(this, this.db, logger);
    }
    release(connection) {
        super.release(connection);
        this.connectionMutex.unlock();
    }
}
exports.SQLiteConnectionPool = SQLiteConnectionPool;
class SQLitePersistence extends sql_1.SQLPersistence {
    constructor(platform, connectionPool, database) {
        super(platform, connectionPool, database);
        this.platform = platform;
        this.connectionPool = connectionPool;
    }
    async batchUpdate(classSchema, changeSets) {
        const scopeSerializer = this.platform.serializer.for(classSchema);
        const tableName = this.platform.getTableIdentifier(classSchema);
        const pkName = classSchema.getPrimaryField().name;
        const pkField = this.platform.quoteIdentifier(pkName);
        const values = {};
        const setNames = [];
        const aggregateSelects = {};
        const requiredFields = {};
        const assignReturning = {};
        const setReturning = {};
        for (const changeSet of changeSets) {
            const where = [];
            const pk = scopeSerializer.partialSerialize(changeSet.primaryKey);
            for (const i in pk) {
                if (!pk.hasOwnProperty(i))
                    continue;
                where.push(`${this.platform.quoteIdentifier(i)} = ${this.platform.quoteValue(pk[i])}`);
                requiredFields[i] = 1;
            }
            if (!values[pkName])
                values[pkName] = [];
            values[pkName].push(this.platform.quoteValue(changeSet.primaryKey[pkName]));
            const fieldAddedToValues = {};
            const id = changeSet.primaryKey[pkName];
            //todo: handle changes.$unset
            if (changeSet.changes.$set) {
                const value = scopeSerializer.partialSerialize(changeSet.changes.$set);
                for (const i in value) {
                    if (!value.hasOwnProperty(i))
                        continue;
                    if (!values[i]) {
                        values[i] = [];
                        setNames.push(`${this.platform.quoteIdentifier(i)} = _b.${this.platform.quoteIdentifier(i)}`);
                    }
                    requiredFields[i] = 1;
                    fieldAddedToValues[i] = 1;
                    values[i].push(this.platform.quoteValue(value[i]));
                }
            }
            if (changeSet.changes.$inc) {
                for (const i in changeSet.changes.$inc) {
                    if (!changeSet.changes.$inc.hasOwnProperty(i))
                        continue;
                    const value = changeSet.changes.$inc[i];
                    if (!aggregateSelects[i])
                        aggregateSelects[i] = [];
                    if (!values[i]) {
                        values[i] = [];
                        setNames.push(`${this.platform.quoteIdentifier(i)} = _b.${this.platform.quoteIdentifier(i)}`);
                    }
                    if (!assignReturning[id]) {
                        assignReturning[id] = { item: changeSet.item, names: [] };
                    }
                    assignReturning[id].names.push(i);
                    setReturning[i] = 1;
                    aggregateSelects[i].push({
                        id: changeSet.primaryKey[pkName],
                        sql: `_origin.${this.platform.quoteIdentifier(i)} + ${this.platform.quoteValue(value)}`
                    });
                    requiredFields[i] = 1;
                    if (!fieldAddedToValues[i]) {
                        fieldAddedToValues[i] = 1;
                        values[i].push(this.platform.quoteValue(null));
                    }
                }
            }
        }
        const selects = [];
        const valuesValues = [];
        const valuesNames = [];
        const _rename = [];
        let j = 1;
        for (const i in values) {
            valuesNames.push(i);
            _rename.push(`column${j++} as ${i}`);
        }
        for (let i = 0; i < values[pkName].length; i++) {
            valuesValues.push('(' + valuesNames.map(name => values[name][i]).join(',') + ')');
        }
        for (const i in requiredFields) {
            if (aggregateSelects[i]) {
                const select = [];
                select.push('CASE');
                for (const item of aggregateSelects[i]) {
                    select.push(`WHEN _.${pkField} = ${item.id} THEN ${item.sql}`);
                }
                select.push(`ELSE _.${this.platform.quoteIdentifier(i)} END as ${this.platform.quoteIdentifier(i)}`);
                selects.push(select.join(' '));
            }
            else {
                selects.push('_.' + i);
            }
        }
        const sql = `
              DROP TABLE IF EXISTS _b;
              CREATE TEMPORARY TABLE _b AS
                SELECT ${selects.join(', ')}
                FROM (SELECT ${_rename.join(', ')} FROM (VALUES ${valuesValues.join(', ')})) as _
                INNER JOIN ${tableName} as _origin ON (_origin.${pkField} = _.${pkField});
              UPDATE
                ${tableName}
                SET ${setNames.join(', ')}
              FROM
                _b
              WHERE ${tableName}.${pkField} = _b.${pkField};
        `;
        const connection = await this.getConnection(); //will automatically be released in SQLPersistence
        await connection.exec(sql);
        if (!core_1.empty(setReturning)) {
            const returnings = await connection.execAndReturnAll('SELECT * FROM _b');
            for (const returning of returnings) {
                const r = assignReturning[returning[pkName]];
                for (const name of r.names) {
                    r.item[name] = returning[name];
                }
            }
        }
    }
    async populateAutoIncrementFields(classSchema, items) {
        const autoIncrement = classSchema.getAutoIncrementField();
        if (!autoIncrement)
            return;
        //SQLite returns the _last_ auto-incremented value for a batch insert as last_insert_rowid().
        //Since we know how many items were inserted, we can simply calculate for each item the auto-incremented value.
        const connection = await this.getConnection(); //will automatically be released in SQLPersistence
        const row = await connection.execAndReturnSingle(`SELECT last_insert_rowid() as rowid`);
        const lastInserted = row.rowid;
        let start = lastInserted - items.length + 1;
        for (const item of items) {
            item[autoIncrement.name] = start++;
        }
    }
}
exports.SQLitePersistence = SQLitePersistence;
class SQLiteQueryResolver extends sql_1.SQLQueryResolver {
    constructor(connectionPool, platform, classSchema, databaseSession) {
        super(connectionPool, platform, classSchema, databaseSession);
        this.connectionPool = connectionPool;
        this.platform = platform;
    }
    async delete(model, deleteResult) {
        // if (model.hasJoins()) throw new Error('Delete with joins not supported. Fetch first the ids then delete.');
        const pkName = this.classSchema.getPrimaryField().name;
        const primaryKey = this.classSchema.getPrimaryField();
        const pkField = this.platform.quoteIdentifier(primaryKey.name);
        const sqlBuilder = new sql_1.SqlBuilder(this.platform);
        const select = sqlBuilder.select(this.classSchema, model, { select: [pkField] });
        const primaryKeyConverted = type_1.getPropertyXtoClassFunction(primaryKey, this.platform.serializer);
        const connection = await this.connectionPool.getConnection(this.session.logger, this.session.transaction);
        try {
            await connection.exec(`DROP TABLE IF EXISTS _tmp_d`);
            await connection.run(`CREATE TEMPORARY TABLE _tmp_d as ${select.sql};`, select.params);
            const sql = `DELETE FROM ${this.platform.getTableIdentifier(this.classSchema)} WHERE ${pkField} IN (SELECT * FROM _tmp_d)`;
            await connection.run(sql);
            const rows = await connection.execAndReturnAll('SELECT * FROM _tmp_d');
            deleteResult.modified = await connection.getChanges();
            for (const row of rows) {
                deleteResult.primaryKeys.push(primaryKeyConverted(row[pkName]));
            }
        }
        finally {
            connection.release();
        }
    }
    async patch(model, changes, patchResult) {
        const select = [];
        const selectParams = [];
        const tableName = this.platform.getTableIdentifier(this.classSchema);
        const primaryKey = this.classSchema.getPrimaryField();
        const primaryKeyConverted = type_1.getPropertyXtoClassFunction(primaryKey, this.platform.serializer);
        const fieldsSet = {};
        const aggregateFields = {};
        const scopeSerializer = this.platform.serializer.for(this.classSchema);
        const $set = changes.$set ? scopeSerializer.partialSerialize(changes.$set) : undefined;
        if ($set)
            for (const i in $set) {
                if (!$set.hasOwnProperty(i))
                    continue;
                fieldsSet[i] = 1;
                select.push(`? as ${this.platform.quoteIdentifier(i)}`);
                selectParams.push($set[i]);
            }
        if (changes.$unset)
            for (const i in changes.$unset) {
                if (!changes.$unset.hasOwnProperty(i))
                    continue;
                fieldsSet[i] = 1;
                select.push(`NULL as ${this.platform.quoteIdentifier(i)}`);
            }
        for (const i of model.returning) {
            aggregateFields[i] = { converted: type_1.getPropertyXtoClassFunction(type_1.resolvePropertySchema(this.classSchema, i), this.platform.serializer) };
            select.push(`(${this.platform.quoteIdentifier(i)} ) as ${this.platform.quoteIdentifier(i)}`);
        }
        if (changes.$inc)
            for (const i in changes.$inc) {
                if (!changes.$inc.hasOwnProperty(i))
                    continue;
                fieldsSet[i] = 1;
                aggregateFields[i] = { converted: type_1.getPropertyXtoClassFunction(type_1.resolvePropertySchema(this.classSchema, i), this.platform.serializer) };
                select.push(`(${this.platform.quoteIdentifier(i)} + ${this.platform.quoteValue(changes.$inc[i])}) as ${this.platform.quoteIdentifier(i)}`);
            }
        const set = [];
        for (const i in fieldsSet) {
            set.push(`${this.platform.quoteIdentifier(i)} = _b.${this.platform.quoteIdentifier(i)}`);
        }
        let bPrimaryKey = primaryKey.name;
        //we need a different name because primaryKeys could be updated as well
        if (fieldsSet[primaryKey.name]) {
            select.unshift(this.platform.quoteIdentifier(primaryKey.name) + ' as __' + primaryKey.name);
            bPrimaryKey = '__' + primaryKey.name;
        }
        else {
            select.unshift(this.platform.quoteIdentifier(primaryKey.name));
        }
        const sqlBuilder = new sql_1.SqlBuilder(this.platform, selectParams);
        const selectSQL = sqlBuilder.select(this.classSchema, model, { select });
        const sql = `
              UPDATE
                ${tableName}
              SET
                ${set.join(', ')}
              FROM
                _b
              WHERE ${tableName}.${this.platform.quoteIdentifier(primaryKey.name)} = _b.${this.platform.quoteIdentifier(bPrimaryKey)};
        `;
        const connection = await this.connectionPool.getConnection(this.session.logger, this.session.transaction);
        try {
            await connection.exec(`DROP TABLE IF EXISTS _b;`);
            const createBSQL = `CREATE TEMPORARY TABLE _b AS ${selectSQL.sql};`;
            await connection.run(createBSQL, selectSQL.params);
            await connection.run(sql);
            patchResult.modified = await connection.getChanges();
            const returnings = await connection.execAndReturnAll('SELECT * FROM _b');
            for (const i in aggregateFields) {
                patchResult.returning[i] = [];
            }
            for (const returning of returnings) {
                patchResult.primaryKeys.push(primaryKeyConverted(returning[primaryKey.name]));
                for (const i in aggregateFields) {
                    patchResult.returning[i].push(aggregateFields[i].converted(returning[i]));
                }
            }
        }
        finally {
            connection.release();
        }
    }
}
exports.SQLiteQueryResolver = SQLiteQueryResolver;
class SQLiteDatabaseQuery extends sql_1.SQLDatabaseQuery {
}
exports.SQLiteDatabaseQuery = SQLiteDatabaseQuery;
class SQLiteDatabaseQueryFactory extends sql_1.SQLDatabaseQueryFactory {
    constructor(connectionPool, platform, databaseSession) {
        super(connectionPool, platform, databaseSession);
        this.connectionPool = connectionPool;
    }
    createQuery(classType) {
        return new SQLiteDatabaseQuery(type_1.getClassSchema(classType), this.databaseSession, new SQLiteQueryResolver(this.connectionPool, this.platform, type_1.getClassSchema(classType), this.databaseSession));
    }
}
exports.SQLiteDatabaseQueryFactory = SQLiteDatabaseQueryFactory;
class SQLiteDatabaseAdapter extends sql_1.SQLDatabaseAdapter {
    constructor(sqlitePath = ':memory:') {
        super();
        this.sqlitePath = sqlitePath;
        this.platform = new sqlite_platform_1.SQLitePlatform();
        this.db = new better_sqlite3_1.default(sqlitePath);
        this.db.exec('PRAGMA foreign_keys=ON');
        this.connectionPool = new SQLiteConnectionPool(this.db);
    }
    async getInsertBatchSize(schema) {
        return Math.floor(32000 / schema.getProperties().length);
    }
    getName() {
        return 'sqlite';
    }
    getSchemaName() {
        return '';
    }
    createPersistence(session) {
        return new SQLitePersistence(this.platform, this.connectionPool, session);
    }
    queryFactory(databaseSession) {
        return new SQLiteDatabaseQueryFactory(this.connectionPool, this.platform, databaseSession);
    }
    disconnect(force) {
        if (this.connectionPool.getActiveConnections() > 0) {
            throw new Error(`There are still active connections. Please release() any fetched connection first.`);
        }
        this.db.close();
    }
}
exports.SQLiteDatabaseAdapter = SQLiteDatabaseAdapter;
//# sourceMappingURL=sqlite-adapter.js.map