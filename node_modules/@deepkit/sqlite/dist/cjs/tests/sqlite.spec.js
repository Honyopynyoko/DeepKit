"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
require("reflect-metadata");
const sqlite_platform_1 = require("../src/sqlite-platform");
const type_1 = require("@deepkit/type");
const factory_1 = require("./factory");
const orm_integration_1 = require("@deepkit/orm-integration");
globals_1.test('tables', () => {
    const [user] = new sqlite_platform_1.SQLitePlatform().createTables([orm_integration_1.User]);
    globals_1.expect(user.getColumn('birthdate').isNotNull).toBe(false);
    const [userCredentials] = new sqlite_platform_1.SQLitePlatform().createTables([orm_integration_1.UserCredentials, orm_integration_1.User]);
    globals_1.expect(userCredentials.getColumn('user').isPrimaryKey).toBe(true);
    globals_1.expect(userCredentials.getColumn('user').type).toBe('integer');
});
globals_1.test('sqlite basic', async () => {
    const User = type_1.t.schema({
        id: type_1.t.number.primary,
        name: type_1.t.string,
        created: type_1.t.date,
    }, { name: 'user' });
    const database = await factory_1.databaseFactory([User]);
    const user1 = type_1.plainToClass(User, { id: 1, name: 'Yes', created: new Date() });
    const user2 = type_1.plainToClass(User, { id: 2, name: 'Wow', created: new Date() });
    const user3 = type_1.plainToClass(User, { id: 3, name: 'asdadasd', created: new Date() });
    {
        const session = database.createSession();
        globals_1.expect(await session.query(User).count()).toBe(0);
        session.add(user1, user2, user3);
        await session.commit();
        globals_1.expect(await session.query(User).count()).toBe(3);
        user1.name = 'Changed';
        await session.commit();
        globals_1.expect(await session.query(User).count()).toBe(3);
        globals_1.expect((await session.query(User).disableIdentityMap().filter(user1).findOne()).name).toBe('Changed');
    }
    {
        const session = database.createSession();
        const user1db = await session.query(User).filter({ id: user1.id }).findOne();
        globals_1.expect(user1db.name).toBe('Changed');
    }
    {
        const session = database.createSession();
        globals_1.expect((await session.query(User).deleteMany()).modified).toBe(3);
        globals_1.expect((await session.query(User).deleteMany()).modified).toBe(0);
    }
});
globals_1.test('sqlite autoincrement', async () => {
    let User = class User {
        constructor(name) {
            this.name = name;
            this.created = new Date;
        }
    };
    __decorate([
        type_1.t.primary.autoIncrement,
        __metadata("design:type", Number)
    ], User.prototype, "id", void 0);
    __decorate([
        type_1.t,
        __metadata("design:type", Date)
    ], User.prototype, "created", void 0);
    User = __decorate([
        type_1.Entity('sqlite-user'),
        __param(0, type_1.t),
        __metadata("design:paramtypes", [String])
    ], User);
    const database = await factory_1.databaseFactory([User]);
    const session = database.createSession();
    globals_1.expect(await session.query(User).count()).toBe(0);
    const peter = new User('Peter');
    const herbert = new User('Herbert');
    session.add(peter);
    session.add(herbert);
    await session.commit();
    globals_1.expect(await session.query(User).count()).toBe(2);
    globals_1.expect(peter.id).toBe(1);
    globals_1.expect(herbert.id).toBe(2);
    globals_1.expect(await session.query(User).count()).toBe(2);
});
globals_1.test('sqlite relation', async () => {
    let Author = class Author {
        constructor(id, name) {
            this.id = id;
            this.name = name;
            this.created = new Date;
        }
    };
    __decorate([
        type_1.t,
        __metadata("design:type", Date)
    ], Author.prototype, "created", void 0);
    Author = __decorate([
        type_1.Entity('sqlite-author'),
        __param(0, type_1.t.primary),
        __param(1, type_1.t),
        __metadata("design:paramtypes", [Number, String])
    ], Author);
    let Book = class Book {
        constructor(id, author, name) {
            this.id = id;
            this.author = author;
            this.name = name;
        }
    };
    Book = __decorate([
        type_1.Entity('sqlite-book'),
        __param(0, type_1.t.primary),
        __param(1, type_1.t.reference()),
        __param(2, type_1.t),
        __metadata("design:paramtypes", [Number, Author, String])
    ], Book);
    const database = await factory_1.databaseFactory([Author, Book]);
    const session = database.createSession();
    globals_1.expect(await session.query(Author).count()).toBe(0);
    const peter = new Author(1, 'Peter');
    const herbert = new Author(2, 'Herbert');
    session.add(peter);
    session.add(herbert);
    const book1 = new Book(1, peter, 'Peters book');
    session.add(book1);
    await session.commit();
    globals_1.expect(await session.query(Author).count()).toBe(2);
    globals_1.expect(await session.query(Book).count()).toBe(1);
});
//# sourceMappingURL=sqlite.spec.js.map