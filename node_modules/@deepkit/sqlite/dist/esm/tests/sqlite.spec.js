var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { expect, test } from '@jest/globals';
import 'reflect-metadata';
import { SQLitePlatform } from '../src/sqlite-platform';
import { Entity, plainToClass, t } from '@deepkit/type';
import { databaseFactory } from './factory';
import { User, UserCredentials } from '@deepkit/orm-integration';
test('tables', () => {
    const [user] = new SQLitePlatform().createTables([User]);
    expect(user.getColumn('birthdate').isNotNull).toBe(false);
    const [userCredentials] = new SQLitePlatform().createTables([UserCredentials, User]);
    expect(userCredentials.getColumn('user').isPrimaryKey).toBe(true);
    expect(userCredentials.getColumn('user').type).toBe('integer');
});
test('sqlite basic', async () => {
    const User = t.schema({
        id: t.number.primary,
        name: t.string,
        created: t.date,
    }, { name: 'user' });
    const database = await databaseFactory([User]);
    const user1 = plainToClass(User, { id: 1, name: 'Yes', created: new Date() });
    const user2 = plainToClass(User, { id: 2, name: 'Wow', created: new Date() });
    const user3 = plainToClass(User, { id: 3, name: 'asdadasd', created: new Date() });
    {
        const session = database.createSession();
        expect(await session.query(User).count()).toBe(0);
        session.add(user1, user2, user3);
        await session.commit();
        expect(await session.query(User).count()).toBe(3);
        user1.name = 'Changed';
        await session.commit();
        expect(await session.query(User).count()).toBe(3);
        expect((await session.query(User).disableIdentityMap().filter(user1).findOne()).name).toBe('Changed');
    }
    {
        const session = database.createSession();
        const user1db = await session.query(User).filter({ id: user1.id }).findOne();
        expect(user1db.name).toBe('Changed');
    }
    {
        const session = database.createSession();
        expect((await session.query(User).deleteMany()).modified).toBe(3);
        expect((await session.query(User).deleteMany()).modified).toBe(0);
    }
});
test('sqlite autoincrement', async () => {
    let User = class User {
        constructor(name) {
            this.name = name;
            this.created = new Date;
        }
    };
    __decorate([
        t.primary.autoIncrement,
        __metadata("design:type", Number)
    ], User.prototype, "id", void 0);
    __decorate([
        t,
        __metadata("design:type", Date)
    ], User.prototype, "created", void 0);
    User = __decorate([
        Entity('sqlite-user'),
        __param(0, t),
        __metadata("design:paramtypes", [String])
    ], User);
    const database = await databaseFactory([User]);
    const session = database.createSession();
    expect(await session.query(User).count()).toBe(0);
    const peter = new User('Peter');
    const herbert = new User('Herbert');
    session.add(peter);
    session.add(herbert);
    await session.commit();
    expect(await session.query(User).count()).toBe(2);
    expect(peter.id).toBe(1);
    expect(herbert.id).toBe(2);
    expect(await session.query(User).count()).toBe(2);
});
test('sqlite relation', async () => {
    let Author = class Author {
        constructor(id, name) {
            this.id = id;
            this.name = name;
            this.created = new Date;
        }
    };
    __decorate([
        t,
        __metadata("design:type", Date)
    ], Author.prototype, "created", void 0);
    Author = __decorate([
        Entity('sqlite-author'),
        __param(0, t.primary),
        __param(1, t),
        __metadata("design:paramtypes", [Number, String])
    ], Author);
    let Book = class Book {
        constructor(id, author, name) {
            this.id = id;
            this.author = author;
            this.name = name;
        }
    };
    Book = __decorate([
        Entity('sqlite-book'),
        __param(0, t.primary),
        __param(1, t.reference()),
        __param(2, t),
        __metadata("design:paramtypes", [Number, Author, String])
    ], Book);
    const database = await databaseFactory([Author, Book]);
    const session = database.createSession();
    expect(await session.query(Author).count()).toBe(0);
    const peter = new Author(1, 'Peter');
    const herbert = new Author(2, 'Herbert');
    session.add(peter);
    session.add(herbert);
    const book1 = new Book(1, peter, 'Peters book');
    session.add(book1);
    await session.commit();
    expect(await session.query(Author).count()).toBe(2);
    expect(await session.query(Book).count()).toBe(1);
});
//# sourceMappingURL=sqlite.spec.js.map