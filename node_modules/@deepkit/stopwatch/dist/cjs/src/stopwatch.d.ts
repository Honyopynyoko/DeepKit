import { FrameCategory, FrameCategoryModel, FrameData, FrameEnd, FrameStart } from './types';
export declare abstract class StopwatchStore {
    frameQueue: (FrameStart | FrameEnd)[];
    dataQueue: FrameData[];
    protected sync(): void;
    abstract run<T>(data: {
        [name: string]: any;
    }, cb: () => Promise<T>): Promise<T>;
    abstract getZone(): {
        [name: string]: any;
    } | undefined;
    data(data: FrameData): void;
    add(frame: FrameStart | FrameEnd): number;
}
export declare class StopwatchFrame<C extends FrameCategory & keyof FrameCategoryModel> {
    protected store: StopwatchStore;
    context: number;
    category: number;
    id: number;
    worker: number;
    constructor(store: StopwatchStore, context: number, category: number, id: number, worker: number);
    data(data: Partial<FrameCategoryModel[C]>): void;
    end(): void;
    run<T>(data: {
        [name: string]: any;
    }, cb: () => Promise<T>): Promise<T>;
}
export declare class Stopwatch {
    protected store?: StopwatchStore | undefined;
    times: {
        [name: string]: {
            stack: number[];
            time: number;
        };
    };
    /**
     * It's active when there is a StopwatchStore attached.
     * Per default its inactive.
     */
    active: boolean;
    constructor(store?: StopwatchStore | undefined);
    /**
     * Please check Stopwatch.active before using this method.
     *
     * When a new context is created, it's important to use StopwatchFrame.run() so that all
     * sub frames are correctly assigned to the new context.
     */
    start<C extends FrameCategory & keyof FrameCategoryModel>(label: string, category?: C, newContext?: boolean): StopwatchFrame<C>;
}
