"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArraySort = void 0;
const base_1 = require("./base");
/**
 * A topological sort implementation based on  arrays.
 *
 * @author Marc J. Schmidt <marc@marcjschmidt.de>
 */
class ArraySort extends base_1.BaseImplementation {
    constructor() {
        super(...arguments);
        this.elements = new Map();
        this.sorted = [];
    }
    set(elements) {
        for (const [key, value] of elements.entries()) {
            this.add(key, value);
        }
    }
    add(element, dependencies = []) {
        this.elements.set(element, {
            item: element,
            dependencies: dependencies,
            visited: false,
        });
    }
    reset() {
        for (const element of this.elements.values()) {
            element.visited = false;
        }
    }
    /**
     * Visits element and handles it dependencies, queues to internal sorted list in the right order.
     *
     * @throws CircularDependencyException if a circular dependency has been found
     * @throws ElementNotFoundException if a dependency can not be found
     */
    visit(element, parents) {
        if (parents)
            this.throwCircularExceptionIfNeeded(element.item, parents);
        if (!element.visited) {
            element.visited = true;
            if (element.dependencies.length) {
                parents = parents || new Set();
                parents.add(element.item);
                for (const dependency of element.dependencies) {
                    let item = this.elements.get(dependency);
                    if (!item)
                        throw new base_1.ElementNotFoundException(element.item, dependency);
                    this.visit(item, parents);
                }
            }
            this.addToList(element);
        }
    }
    addToList(element) {
        this.sorted.push(element.item);
    }
    /**
     * Sorts dependencies and returns internal used data structure.
     *
     * @throws CircularDependencyException if a circular dependency has been found
     * @throws ElementNotFoundException if a dependency can not be found
     */
    sort() {
        return this.doSort();
    }
    doSort() {
        this.sorted = [];
        for (const element of this.elements.values()) {
            this.visit(element);
        }
        return this.sorted;
    }
}
exports.ArraySort = ArraySort;
//# sourceMappingURL=array-sort.js.map