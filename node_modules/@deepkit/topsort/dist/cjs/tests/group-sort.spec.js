"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const group_array_sort_1 = require("../src/group-array-sort");
const base_1 = require("../src/base");
const utils_1 = require("./utils");
const assert_1 = require("assert");
function getElementsGroup(count) {
    const elements = new Map();
    for (let i = 0; i < count / 3; i++) {
        elements.set({ item: 'car' + i, type: 'car' }, ['brand' + i]);
        elements.set({ item: 'owner' + i, type: 'owner' }, ['brand' + i, 'car' + i]);
        elements.set({ item: 'brand' + i, type: 'brand' }, []);
    }
    return elements;
}
globals_1.test('bench', () => {
    const count = 10000;
    const items = getElementsGroup(count);
    utils_1.bench(10, `ArraySort Warmup ${count}`, () => {
        const sorter = new group_array_sort_1.GroupArraySort();
        sorter.set(items);
        sorter.sort();
    });
    const sorter = new group_array_sort_1.GroupArraySort();
    sorter.set(items);
    utils_1.bench(1, `GroupArraySort ${count}`, () => {
        sorter.sort();
    });
});
globals_1.test('circular disabled', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    sorter.add('car1', 'car', ['owner1']);
    sorter.add('owner1', 'owner', ['car1']);
    sorter.throwCircularDependency = false;
    sorter.sort();
});
globals_1.test('circular exception', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    sorter.add('car1', 'car', ['owner1']);
    sorter.add('owner1', 'owner', ['brand1']);
    sorter.add('brand1', 'brand', ['car1']);
    try {
        sorter.sort();
        assert_1.fail('this must fail');
    }
    catch (error) {
        globals_1.expect(error).toBeInstanceOf(base_1.CircularDependencyException);
        if (error instanceof base_1.CircularDependencyException) {
            globals_1.expect(error.nodes).toEqual(['car1', 'owner1', 'brand1']);
            globals_1.expect(error.getStart()).toBe('car1');
            globals_1.expect(error.getEnd()).toBe('brand1');
        }
    }
});
globals_1.test('dependency in same', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    sorter.add('car1', 'car', ['brand1']);
    sorter.add('car2', 'car', ['car3']);
    sorter.add('car3', 'car', ['brand2']);
    sorter.add('brand1', 'brand');
    sorter.add('brand2', 'brand');
    sorter.sort();
    globals_1.expect(sorter.getGroups()).toEqual([
        { type: 'brand', items: ['brand1', 'brand2'] },
        { type: 'car', items: ['car1', 'car3', 'car2'] },
    ]);
});
globals_1.test('dependency in same with activated sameTypeGrouping', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    sorter.add('car1', 'car', ['brand1']);
    sorter.add('car2', 'car', ['car3']);
    sorter.add('car3', 'car', ['brand2']);
    sorter.add('brand1', 'brand');
    sorter.add('brand2', 'brand');
    sorter.sameTypeExtraGrouping = true;
    sorter.sort();
    globals_1.expect(sorter.getGroups()).toEqual([
        { type: 'brand', items: ['brand1', 'brand2'] },
        { type: 'car', items: ['car1', 'car3'] },
        { type: 'car', items: ['car2'] },
    ]);
});
globals_1.test('dependency in same with activated sameTypeGrouping more complex', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    sorter.add('car6', 'car');
    sorter.add('car1', 'car', ['brand1']);
    sorter.add('car2', 'car', ['car3']);
    sorter.add('car3', 'car', ['brand2']);
    sorter.add('car4', 'car', ['car2']);
    sorter.add('car5', 'car', ['brand2']);
    sorter.add('brand1', 'brand');
    sorter.add('brand2', 'brand');
    sorter.sameTypeExtraGrouping = true;
    sorter.sort();
    globals_1.expect(sorter.getGroups()).toEqual([
        { type: 'car', items: ['car6'] },
        { type: 'brand', items: ['brand1', 'brand2'] },
        { type: 'car', items: ['car1', 'car3'] },
        { type: 'car', items: ['car2'] },
        { type: 'car', items: ['car4', 'car5'] },
    ]);
});
globals_1.test('not found', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    sorter.add('car1', 'car', ['owner1']);
    sorter.add('owner1', 'owner', ['car2']);
    try {
        sorter.sort();
        assert_1.fail('this must fail');
    }
    catch (error) {
        globals_1.expect(error).toBeInstanceOf(base_1.ElementNotFoundException);
        if (error instanceof base_1.ElementNotFoundException) {
            globals_1.expect(error.element).toBe('owner1');
            globals_1.expect(error.dependency).toBe('car2');
        }
    }
});
globals_1.test('simple2', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    sorter.add('car1', 'car', ['brand1']);
    sorter.add('brand1', 'brand');
    sorter.add('car2', 'car');
    sorter.add('brand2', 'brand', ['car2']);
    globals_1.expect(sorter.sort()).toEqual('brand1, car1, car2, brand2'.split(', '));
    globals_1.expect(sorter.getGroups()).toEqual([
        { type: 'brand', items: ['brand1'] },
        { type: 'car', items: ['car1', 'car2'] },
        { type: 'brand', items: ['brand2'] },
    ]);
});
globals_1.test('GetGroups', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    sorter.add('car1', 'car', ['owner1', 'brand1']);
    sorter.add('brand1', 'brand');
    sorter.add('brand2', 'brand');
    sorter.add('owner1', 'user', ['brand1']);
    sorter.add('owner2', 'user', ['brand2']);
    const result = sorter.sort();
    globals_1.expect(result).toEqual('brand1, brand2, owner1, owner2, car1'.split(', '));
    globals_1.expect(sorter.groups[0]).toEqual({ type: 'brand', level: 0, position: 0, length: 2 });
    globals_1.expect(sorter.groups[1]).toEqual({ type: 'user', level: 1, position: 2, length: 2 });
    globals_1.expect(sorter.groups[2]).toEqual({ type: 'car', level: 2, position: 4, length: 1 });
    globals_1.expect(sorter.getGroups()).toEqual([
        { type: 'brand', items: ['brand1', 'brand2'] },
        { type: 'user', items: ['owner1', 'owner2'] },
        { type: 'car', items: ['car1'] },
    ]);
    globals_1.expect(result[sorter.groups[0].position]).toBe('brand1');
    globals_1.expect(result[sorter.groups[0].position + 1]).toBe('brand2');
    globals_1.expect(result[sorter.groups[1].position]).toBe('owner1');
    globals_1.expect(result[sorter.groups[1].position + 1]).toBe('owner2');
    globals_1.expect(result[sorter.groups[2].position]).toBe('car1');
});
globals_1.test('SimpleDoc', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    sorter.add('car1', 'car', ['owner1', 'brand1']);
    sorter.add('brand1', 'brand');
    sorter.add('brand2', 'brand');
    sorter.add('owner1', 'user', ['brand1']);
    sorter.add('owner2', 'user', ['brand2']);
    const result = sorter.sort();
    globals_1.expect(result).toEqual('brand1, brand2, owner1, owner2, car1'.split(', '));
    globals_1.expect(sorter.getGroups()).toEqual([
        { type: 'brand', items: ['brand1', 'brand2'] },
        { type: 'user', items: ['owner1', 'owner2'] },
        { type: 'car', items: ['car1'] },
    ]);
});
globals_1.test('simple', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    sorter.add('car1', 'car', ['brand1']);
    sorter.add('owner1', 'owner', ['car1', 'brand1']);
    sorter.add('owner2', 'owner', ['car2', 'brand1']);
    sorter.add('car2', 'car', ['brand2']);
    sorter.add('brand1', 'brand');
    sorter.add('brand2', 'brand');
    const result = sorter.sort();
    globals_1.expect(result).toEqual('brand1, brand2, car1, car2, owner1, owner2'.split(', '));
    globals_1.expect(sorter.getGroups()).toEqual([
        { type: 'brand', items: ['brand1', 'brand2'] },
        { type: 'car', items: ['car1', 'car2'] },
        { type: 'owner', items: ['owner1', 'owner2'] },
    ]);
});
globals_1.test('implementation', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    for (let i = 0; i < 3; i++) {
        sorter.add('car' + i, 'car', ['owner' + i, 'brand' + i]);
        sorter.add('owner' + i, 'owner', ['brand' + i]);
        sorter.add('brand' + i, 'brand');
    }
    const result = sorter.sort();
    globals_1.expect(result).toEqual('brand0, brand1, brand2, owner0, owner1, owner2, car0, car1, car2'.split(', '));
    globals_1.expect(sorter.getGroups()).toEqual([
        { type: 'brand', items: ['brand0', 'brand1', 'brand2'] },
        { type: 'owner', items: ['owner0', 'owner1', 'owner2'] },
        { type: 'car', items: ['car0', 'car1', 'car2'] },
    ]);
});
globals_1.test('implementation2', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    for (let i = 0; i < 3; i++) {
        sorter.add('brand' + i, 'brand');
        sorter.add('car' + i, 'car', ['owner' + i, 'brand' + i]);
        sorter.add('owner' + i, 'owner', ['brand' + i]);
    }
    const result = sorter.sort();
    globals_1.expect(result).toEqual('brand0, brand1, brand2, owner0, owner1, owner2, car0, car1, car2'.split(', '));
    globals_1.expect(sorter.getGroups()).toEqual([
        { type: 'brand', items: ['brand0', 'brand1', 'brand2'] },
        { type: 'owner', items: ['owner0', 'owner1', 'owner2'] },
        { type: 'car', items: ['car0', 'car1', 'car2'] },
    ]);
});
globals_1.test('implementation3', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    for (let i = 0; i < 3; i++) {
        sorter.add('brand' + i, 'brand');
        sorter.add('owner' + i, 'owner', ['brand' + i]);
        sorter.add('car' + i, 'car', ['owner' + i, 'brand' + i]);
    }
    const result = sorter.sort();
    globals_1.expect(result).toEqual('brand0, brand1, brand2, owner0, owner1, owner2, car0, car1, car2'.split(', '));
    globals_1.expect(sorter.getGroups()).toEqual([
        { type: 'brand', items: ['brand0', 'brand1', 'brand2'] },
        { type: 'owner', items: ['owner0', 'owner1', 'owner2'] },
        { type: 'car', items: ['car0', 'car1', 'car2'] },
    ]);
});
globals_1.test('implementation4', () => {
    const sorter = new group_array_sort_1.GroupArraySort();
    for (let i = 0; i < 3; i++) {
        sorter.add('owner' + i, 'owner', ['brand' + i]);
        sorter.add('brand' + i, 'brand');
        sorter.add('car' + i, 'car', ['owner' + i, 'brand' + i]);
    }
    const result = sorter.sort();
    globals_1.expect(result).toEqual('brand0, brand1, brand2, owner0, owner1, owner2, car0, car1, car2'.split(', '));
    globals_1.expect(sorter.getGroups()).toEqual([
        { type: 'brand', items: ['brand0', 'brand1', 'brand2'] },
        { type: 'owner', items: ['owner0', 'owner1', 'owner2'] },
        { type: 'car', items: ['car0', 'car1', 'car2'] },
    ]);
});
//# sourceMappingURL=group-sort.spec.js.map