import { BaseImplementation } from './base';
interface ItemElement<T, TYPE> {
    item: T;
    type: TYPE;
    dependencies: T[];
    dependenciesCount: number;
    visited: boolean;
    addedAtLevel: number;
}
interface Group<T> {
    type: T;
    level: number;
    position: number;
    length: number;
}
export declare class GroupArraySort<T = string, TYPE = string> extends BaseImplementation<T> {
    protected elements: Map<T, ItemElement<T, TYPE>>;
    protected sorted: T[];
    protected position: number;
    groups: Group<TYPE>[];
    protected groupLevel: number;
    sameTypeExtraGrouping: boolean;
    throwOnNonExistingDependency: boolean;
    set(elements: Map<{
        item: T;
        type: TYPE;
    }, T[]>): void;
    add(item: T, type: TYPE, dependencies?: T[]): void;
    visit(element: ItemElement<T, TYPE>, parents?: Set<T>): number;
    protected injectElement(element: ItemElement<T, TYPE>, minLevel: number): void;
    protected addItemAt(position: number, element: T): void;
    protected getFirstGroup(type: TYPE, minLevel: number): Group<TYPE> | undefined;
    getGroups(): {
        type: TYPE;
        items: T[];
    }[];
    /**
     * Sorts dependencies and returns internal used data structure.
     *
     * @throws CircularDependencyException if a circular dependency has been found
     * @throws ElementNotFoundException if a dependency can not be found
     */
    sort(): T[];
    protected doSort(): T[];
}
export {};
