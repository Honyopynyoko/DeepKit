/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { BaseImplementation, ElementNotFoundException } from './base';
export class GroupArraySort extends BaseImplementation {
    constructor() {
        super(...arguments);
        this.elements = new Map();
        this.sorted = [];
        this.position = 0;
        this.groups = [];
        this.groupLevel = 0;
        this.sameTypeExtraGrouping = false;
        this.throwOnNonExistingDependency = true;
    }
    set(elements) {
        for (const [key, deps] of elements.entries()) {
            this.add(key.item, key.type, deps);
        }
    }
    add(item, type, dependencies = []) {
        this.elements.set(item, {
            item, type, dependencies,
            dependenciesCount: dependencies.length,
            visited: false,
            addedAtLevel: -1,
        });
    }
    visit(element, parents) {
        if (parents)
            this.throwCircularExceptionIfNeeded(element.item, parents);
        if (!element.visited) {
            element.visited = true;
            let minLevel = -1;
            if (element.dependencies.length) {
                parents = parents || new Set();
                parents.add(element.item);
                for (const dependency of element.dependencies) {
                    let item = this.elements.get(dependency);
                    if (!item) {
                        if (this.throwOnNonExistingDependency) {
                            throw new ElementNotFoundException(element.item, dependency);
                        }
                        continue;
                    }
                    const addedAtGroupLevel = this.visit(item, parents);
                    if (addedAtGroupLevel > minLevel)
                        minLevel = addedAtGroupLevel;
                    if (this.sameTypeExtraGrouping) {
                        if (item.type === element.type)
                            minLevel = this.groupLevel;
                    }
                }
            }
            this.injectElement(element, minLevel);
            return minLevel === -1 ? element.addedAtLevel : minLevel;
        }
        return element.addedAtLevel;
    }
    injectElement(element, minLevel) {
        const group = this.getFirstGroup(element.type, minLevel);
        if (group) {
            this.addItemAt(group.position + group.length, element.item);
            group.length++;
            // console.log("   ->added into group {$group->type}, position: {$group->position}, level: {$group->level}");
            //increase all following groups +1
            for (const ref of this.groups) {
                if (ref.position > group.position) {
                    ref.position++;
                }
            }
            element.addedAtLevel = group.level;
            this.position++;
        }
        else {
            this.groups.push({
                type: element.type,
                level: this.groupLevel,
                position: this.position,
                length: 1,
            });
            element.addedAtLevel = this.groupLevel;
            this.sorted.push(element.item);
            this.position++;
            // console.log("   ->just added. New group {$element->id}, position: {$this->position}, level: {$this->groupLevel}");
            this.groupLevel++;
        }
    }
    addItemAt(position, element) {
        this.sorted.splice(position, 0, element);
    }
    getFirstGroup(type, minLevel) {
        let i = this.groupLevel;
        while (i--) {
            const group = this.groups[i];
            if (group.type === type && i >= minLevel) {
                return group;
            }
        }
        return;
    }
    getGroups() {
        const groups = [];
        for (const group of this.groups) {
            groups.push({ type: group.type, items: this.sorted.slice(group.position, group.position + group.length) });
        }
        return groups;
    }
    /**
     * Sorts dependencies and returns internal used data structure.
     *
     * @throws CircularDependencyException if a circular dependency has been found
     * @throws ElementNotFoundException if a dependency can not be found
     */
    sort() {
        return this.doSort();
    }
    doSort() {
        if (this.sorted.length) {
            //reset state when already executed
            for (const element of this.elements.values()) {
                element.visited = false;
            }
        }
        this.sorted = [];
        this.groups = [];
        this.position = 0;
        this.groupLevel = 0;
        for (const element of this.elements.values()) {
            this.visit(element);
        }
        return this.sorted;
    }
}
//# sourceMappingURL=group-array-sort.js.map