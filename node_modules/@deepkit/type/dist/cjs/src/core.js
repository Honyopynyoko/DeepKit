"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayBufferTo = exports.arrayBufferFrom = exports.typedArrayToBase64 = exports.arrayBufferToBase64 = exports.typedArrayToBuffer = exports.nodeBufferToArrayBuffer = exports.base64ToArrayBuffer = exports.base64ToTypedArray = exports.nodeBufferToTypedArray = void 0;
const buffer_1 = require("buffer");
function nodeBufferToTypedArray(buf, type) {
    return new type(buf.buffer, buf.byteOffset, buf.length / type.BYTES_PER_ELEMENT);
}
exports.nodeBufferToTypedArray = nodeBufferToTypedArray;
/**
 * This function is only used in browser context, where atob is actually faster than
 * using `Buffer.from` by the `buffer.js` library.
 */
function base64ToUint8ArrayAtoB(base64) {
    const raw = window.atob(base64);
    const rawLength = raw.length;
    const array = new Uint8Array(new ArrayBuffer(rawLength));
    for (let i = 0; i < rawLength; i++) {
        array[i] = raw.charCodeAt(i);
    }
    return array;
}
/**
 * When using Buffer.from() node is using a buffer from the buffer pool.
 * This makes it necessary to create the given TypedArray using byteOffset and byteLength accordingly.
 *
 * Note: The created TypedArray.buffer is pointing probably to a larger Buffer. Make sure
 * to use byteLength/byeOffset correctly or use typedArrayToArrayBuffer() if you want to use
 * a raw ArrayBuffer that represents the actual data correctly.
 */
function base64ToTypedArray(base64, type) {
    if ('function' === typeof atob) {
        return new type(base64ToUint8ArrayAtoB(base64).buffer);
    }
    return nodeBufferToTypedArray(buffer_1.Buffer.from(base64, 'base64'), type);
}
exports.base64ToTypedArray = base64ToTypedArray;
/**
 * Creates a new fresh ArrayBuffer with given data.
 * Note: Regular Buffer.from(base64, 'base64) creates in Node a shared buffer, this function makes
 * sure a copy happens and the ArrayBuffer is not shared.
 */
function base64ToArrayBuffer(base64) {
    if ('function' === typeof atob) {
        return base64ToUint8ArrayAtoB(base64).buffer;
    }
    return nodeBufferToArrayBuffer(buffer_1.Buffer.from(base64, 'base64'));
}
exports.base64ToArrayBuffer = base64ToArrayBuffer;
/**
 * When using Buffer.from() node is using a buffer from the buffer pool.
 * This makes it necessary to create the a new ArrayType using slice to make a copy.
 *
 * This makes a copy.
 */
function nodeBufferToArrayBuffer(buf) {
    if (ArrayBuffer.isView(buf))
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    return buf;
}
exports.nodeBufferToArrayBuffer = nodeBufferToArrayBuffer;
/**
 * In node environment the TypedArray.buffer is probably a larger buffer from the buffer pool.
 * This makes it necessary to create a Buffer with offset & length so that it accurately represents
 * the given TypedArray.
 */
function typedArrayToBuffer(typedArray) {
    if (typedArray instanceof buffer_1.Buffer)
        return typedArray;
    return buffer_1.Buffer.from(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
}
exports.typedArrayToBuffer = typedArrayToBuffer;
function arrayBufferToBase64(arrayBuffer) {
    return buffer_1.Buffer.from(arrayBuffer).toString('base64');
}
exports.arrayBufferToBase64 = arrayBufferToBase64;
function typedArrayToBase64(typedArray) {
    return typedArrayToBuffer(typedArray).toString('base64');
}
exports.typedArrayToBase64 = typedArrayToBase64;
/**
 * Same as Buffer.from() but creates a ArrayBuffer that is not shared.
 */
function arrayBufferFrom(data, encoding) {
    return nodeBufferToArrayBuffer(buffer_1.Buffer.from(data, encoding));
}
exports.arrayBufferFrom = arrayBufferFrom;
/**
 * Same as Buffer.from(arrayBuffer).toString(encoding), but more in line with the current API.
 */
function arrayBufferTo(arrayBuffer, encoding) {
    return buffer_1.Buffer.from(arrayBuffer).toString(encoding);
}
exports.arrayBufferTo = arrayBufferTo;
//# sourceMappingURL=core.js.map