import { AbstractClassType, ClassType } from '@deepkit/core';
export declare type ClassDecoratorFn = (classType: AbstractClassType, property?: string, parameterIndexOrDescriptor?: any) => void;
export declare type PropertyDecoratorFn = (prototype: object, property?: string, parameterIndexOrDescriptor?: any) => void;
export declare type FluidDecorator<T, D extends Function> = {
    [name in keyof T]: T[name] extends (...args: infer K) => any ? (...args: K) => D & FluidDecorator<T, D> : D & FluidDecorator<T, D>;
};
export declare function createFluidDecorator<API extends APIClass<any> | APIProperty<any>, D extends Function>(api: API, modifier: {
    name: string;
    args?: any;
}[], collapse: (modifier: {
    name: string;
    args?: any;
}[], target: any, property?: string, parameterIndexOrDescriptor?: any) => void, returnCollapse?: boolean, fluidFunctionSymbol?: symbol): FluidDecorator<ExtractClass<API>, D>;
export declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
export declare function mergeDecorator<T extends any[]>(...args: T): Omit<UnionToIntersection<T[number]>, '_fetch'>;
export interface ClassApiTypeInterface<T> {
    t: T;
    onDecorator?: (classType: ClassType, property?: string, parameterIndexOrDescriptor?: any) => void;
}
export declare type APIClass<T> = ClassType<ClassApiTypeInterface<T>>;
export declare type ExtractClass<T> = T extends AbstractClassType<infer K> ? K : never;
export declare type ExtractApiDataType<T> = T extends AbstractClassType<infer K> ? K extends {
    t: infer P;
} ? P : never : (T extends {
    t: infer P;
} ? P : never);
export declare type ClassDecoratorResult<API extends APIClass<any>> = FluidDecorator<ExtractClass<API>, ClassDecoratorFn> & {
    (classType: AbstractClassType): void;
} & {
    _fetch: (classType: ClassType) => ExtractApiDataType<API> | undefined;
};
export declare function createClassDecoratorContext<API extends APIClass<any>, T = ExtractApiDataType<API>>(apiType: API): ClassDecoratorResult<API>;
export interface PropertyApiTypeInterface<T> {
    t: T;
    onDecorator?: (target: ClassType, property: string, parameterIndexOrDescriptor?: any) => void;
}
export declare type APIProperty<T> = ClassType<PropertyApiTypeInterface<T>>;
export declare type PropertyDecoratorResult<API extends APIProperty<any>> = FluidDecorator<ExtractClass<API>, PropertyDecoratorFn> & {
    (prototype: object, property: string, parameterIndexOrDescriptor?: any): void;
} & {
    _fetch: (classType: ClassType, property: string, parameterIndexOrDescriptor?: any) => ExtractApiDataType<API> | undefined;
};
export declare function createPropertyDecoratorContext<API extends APIProperty<any>, T = ExtractApiDataType<API>>(apiType: API): PropertyDecoratorResult<API>;
export declare type FreeDecoratorFn<API> = {
    (): ExtractApiDataType<API>;
};
export declare type FreeFluidDecorator<API> = {
    [name in keyof ExtractClass<API>]: ExtractClass<API>[name] extends (...args: infer K) => any ? (...args: K) => FreeFluidDecorator<API> : FreeFluidDecorator<API>;
} & FreeDecoratorFn<API>;
export declare type FreeDecoratorResult<API extends APIClass<any>> = FreeFluidDecorator<API> & {
    _fluidFunctionSymbol: symbol;
};
export declare function createFreeDecoratorContext<API extends APIClass<any>, T = ExtractApiDataType<API>>(apiType: API): FreeDecoratorResult<API>;
export declare function isDecoratorContext<API extends APIClass<any>>(context: FreeDecoratorResult<API>, fn: Function): fn is FreeFluidDecorator<API>;
