import { PropertyValidatorError } from './jit-validation';
import { ClassType } from '@deepkit/core';
import { ClassDecoratorResult } from './decorator-builder';
import { ClassSchema, ForwardRef, ForwardRefFn, IndexOptions, PropertySchema, SingleTableInheritance } from './model';
import { PartialField } from './types';
import { FieldDecoratorResult, ValidatorFn } from './field-decorator';
export declare type PlainSchemaProps = {
    [name: string]: FieldDecoratorResult<any> | PlainSchemaProps | ClassSchema | string | number | boolean;
};
export declare type ExtractDefinition<T extends FieldDecoratorResult<any>> = T extends FieldDecoratorResult<infer K> ? K : never;
export declare type MergeSchemaAndBase<T extends PlainSchemaProps, BASE extends ClassSchema | ClassType | undefined> = BASE extends ClassSchema | ClassType ? ExtractType<BASE> & ExtractClassDefinition<T> : ExtractClassDefinition<T>;
export declare type ExtractClassProperty<T> = T extends PlainSchemaProps ? ExtractClassDefinition<T> : T extends ClassSchema<infer K> ? K : T extends FieldDecoratorResult<any> ? ExtractDefinition<T> : T;
export declare type OptionalProps<T> = {
    [name in keyof T]: undefined extends T[name] ? name : never;
}[keyof T];
export declare type RequiredProps<T> = {
    [name in keyof T]: undefined extends T[name] ? never : name;
}[keyof T];
export declare type MakeUndefinedOptional<T> = {
    [name in RequiredProps<T>]: T[name];
} & {
    [name in OptionalProps<T>]?: T[name];
};
export declare type ExtractClassDefinition<T extends PlainSchemaProps> = MakeUndefinedOptional<{
    [name in keyof T]: ExtractClassProperty<T[name]>;
}>;
/**
 * Used to define a entity name for an entity.
 *
 * The name is used for an internal registry, so ot should be a unique one.
 *
 * deepkit/type's database abstraction uses this name to generate the collection name / table name.
 *
 * @category Decorator
 */
export declare function Entity<T>(name: string, collectionName?: string): (target: ClassType<T>) => void;
declare class EntityApi {
    t: ClassSchema<any>;
    constructor(target: object);
    name(name: string): void;
    description(description: string): void;
    collectionName(name: string): void;
    singleTableInheritance(options?: SingleTableInheritance): void;
}
export declare const entity: ClassDecoratorResult<typeof EntityApi>;
/**
 * Used to define a database name for an entity. Per default deepkit's database abstraction
 * uses the default database, but you can change that using this decorator.
 *
 * @category Decorator
 */
export declare function DatabaseName<T>(name: string): (target: ClassType<T>) => void;
export declare function createValidatorFromFunction(validator: ValidatorFn): {
    new (): {
        validate<T>(value: any, property: PropertySchema, classType?: ClassType<any> | undefined): PropertyValidatorError | undefined | void;
    };
};
/**
 * Helper for decorators that are allowed to be placed in property declaration and constructor property declaration.
 * We detect the name by reading the constructor' signature, which would be otherwise lost.
 */
export declare function FieldDecoratorWrapper<T>(cb: (target: object, property: PropertySchema, returnType: any) => void, root?: boolean): FieldDecoratorResult<T>;
/**
 * Used to define a field as a reference to a parent.
 *
 * Example one direction.
 *
 * ```typescript
 * class JobConfig {
 *     @t.type(() => Job).parentReference //forward necessary since circular dependency
 *     job: Job;
 *
 * }
 *
 * class Job {
 *     @f config: JobConfig;
 * }
 * ```
 *
 * Example circular parent-child setup.
 *
 * ```typescript
 * export class PageClass {
 *     @t.uuid
 *     id: string = uuid();
 *
 *     @f
 *     name: string;
 *
 *     @t.type(() => PageClass) //forward necessary since circular dependency
 *     children: PageClass[] = [];
 *
 *     @t.type(() => PageClass).optional.parentReference //forward necessary since circular dependency
 *     parent?: PageClass;
 *
 *     constructor(name: string) {
 *         this.name = name;
 *     }
 * ```
 *
 * @internal
 */
export declare function ParentReference(): (target: object, property: PropertySchema) => void;
/**
 * Used to define a method as callback which will be called when the object has been completely serialized.
 * When fullLoad is true the callback is called when all references are loaded as well. This is particularly useful
 * when you have @ParentReference() properties, which will be undefined in regular OnLoad callback.
 *
 * Example
 * ```typescript
 * class User {
 *     @OnLoad()
 *     onLoad() {
 *         console.log('self loaded!');
 *     }
 *
 *     @OnLoad({fullLoad: true})
 *     onFullLoad() {
 *         console.log('fully loaded, including parent references');
 *     }
 * }
 *
 * ```
 *
 * @category Decorator
 */
export declare function OnLoad<T>(options?: {
    fullLoad?: boolean;
}): (target: T, property: string) => void;
declare type EnumValue<T> = T[keyof T];
declare type ExtractType<T> = T extends ForwardRef<infer K> ? ExtractSimpleType<K> : T extends () => infer K ? ExtractSimpleType<K> : ExtractSimpleType<T>;
declare type ExtractSimpleType<T> = T extends ClassType<infer K> ? K : T extends ClassSchema<infer K> ? K : T extends PlainSchemaProps ? ExtractClassDefinition<T> : T extends FieldDecoratorResult<any> ? ExtractDefinition<T> : T;
export interface MainDecorator {
    /**
     * Defines a type for a certain field. This is only necessary for custom classes
     * if the Typescript compiler does not include the reflection type in the build output.
     *
     * ```typescript
     * class User {
     *     //not necessary
     *     @t.type(MyClass)
     *     tags: MyClass = new MyClass;
     * }
     * ```
     */
    type<T extends string | ClassType | ForwardRefFn<any> | ClassSchema | PlainSchemaProps | FieldDecoratorResult<any>>(type: T): FieldDecoratorResult<ExtractType<T>>;
    /**
     * Defines a discriminated union type.
     *
     * ```typescript
     * class ConfigA {
     *     @t.discriminator
     *     kind: string = 'a';
     *
     *     @f
     *     myValue: string = '';
     * }
     *
     * class ConfigB {
     *     @t.discriminator
     *     kind: string = 'b';
     *
     *     @f
     *     myValue2: string = '';
     * }
     *
     * class User {
     *     @t.union(ConfigA, ConfigB)
     *     config: ConfigA | ConfigB = new ConfigA;
     * }
     * ```
     */
    union<T extends (ClassType | ForwardRefFn<any> | ClassSchema | PlainSchemaProps | FieldDecoratorResult<any> | string | number | boolean)[]>(...type: T): FieldDecoratorResult<ExtractType<T[number]>>;
    /**
     * Marks a field as array.
     *
     * ```typescript
     * class User {
     *     @t.array(@t.string)
     *     tags: string[] = [];
     * }
     * ```
     */
    array<T extends ClassType | ForwardRefFn<any> | ClassSchema | PlainSchemaProps | FieldDecoratorResult<any>>(type: T): FieldDecoratorResult<ExtractType<T>[]>;
    /**
     * Creates a new ClassSchema from a plain schema definition object.
     * If you want to decorate an external/already existing class, use `options.classType`.
     */
    schema<T extends PlainSchemaProps>(props: T, options?: {
        name?: string;
        collectionName?: string;
        classType?: ClassType;
    }): ClassSchema<ExtractClassDefinition<T>>;
    extendSchema<T extends PlainSchemaProps, BASE extends ClassSchema | ClassType>(base: BASE, props: T, options?: {
        name?: string;
        classType?: ClassType;
    }): ClassSchema<MergeSchemaAndBase<T, BASE>>;
    /**
     * Creates a new javascript class from a plain schema definition object.
     */
    class<T extends PlainSchemaProps>(props: T, options?: {
        name?: string;
    }): ClassType<ExtractClassDefinition<T>>;
    extendClass<T extends PlainSchemaProps, BASE extends ClassSchema | ClassType>(base: BASE, props: T, options?: {
        name?: string;
    }): ClassType<MergeSchemaAndBase<T, BASE>>;
    /**
     * Marks a field as string.
     */
    string: FieldDecoratorResult<string>;
    /**
     * Marks a field as literal type.
     *
     * When no value is given, it tries to detect it from the default value.
     * This strategy is only possible in TypeScript strict mode, since literals need a default value and can not be optional.
     * For non-strict mode when no literal value is given, an error is thrown.
     *
     *
     * ```typescript
     * @t.literal('a')
     *
     * @t.union(t.literal('a'), t.literal('b')) //'a' | 'b'
     *
     * @t.union('a', 'b') //'a' | 'b'
     *
     * //works in strict mode
     * class Model {
     *     @t.literal() type: 'bar' = 'bar';
     * }
     *
     * //non strict mode requires to define the type
     * class Model {
     *     @t.literal('bar') type!: 'bar';
     * }
     * ```
     */
    literal<T extends number | string | boolean>(type: T): FieldDecoratorResult<T>;
    /**
     * Marks a field as number.
     */
    number: FieldDecoratorResult<number>;
    /**
     * Marks a field as bigint.
     */
    bigint: FieldDecoratorResult<bigint>;
    /**
     * Marks a field as boolean.
     */
    boolean: FieldDecoratorResult<boolean>;
    /**
     * Marks a field as Date.
     */
    date: FieldDecoratorResult<Date>;
    /**
     * Marks a field as enum.
     *
     * ```typescript
     * enum MyEnum {
     *     low;
     *     medium;
     *     hight;
     * }
     *
     * class User {
     *     @t.enum(MyEnum)
     *     level: MyEnum = MyEnum.low;
     * }
     * ```
     *
     * If allowLabelsAsValue is set, you can use the enum labels as well for setting the property value using plainToClass().
     *
     * Note: const enums are not supported.
     */
    enum<T>(type: T, allowLabelsAsValue?: boolean): FieldDecoratorResult<EnumValue<T extends ForwardRef<infer K> ? K : T>>;
    /**
     * Marks a field as partial of a class entity. It differs in a way to standard Partial<> that
     * it allows path based sub values, like you know from JSON patch.
     *
     * ```typescript
     * class Config {
     *     @f
     *     name?: string;
     *
     *     @f
     *     sub?: Config;
     *
     *     @f
     *     prio: number = 0;
     * }
     *
     * class User {
     *     @t.partial(Config)
     *     config: PartialField<Config> = {};
     * }
     * ```
     */
    partial<T extends ClassType | ForwardRefFn<any> | ClassSchema | PlainSchemaProps>(type: T): FieldDecoratorResult<PartialField<ExtractType<T>>>;
    /**
     * Marks a field as type any. It does not transform the value and directly uses JSON.parse/stringify.
     */
    any: FieldDecoratorResult<any>;
    /**
     * Marks a field as map.
     *
     * ```typescript
     * class User {
     *     @t.map(f.string)
     *     tags: {[k: string]: string};
     *
     *     @t.map(@t.type(() => MyClass))
     *     tags: {[k: string]: MyClass};
     * }
     * ```
     */
    map<T extends ClassType | ForwardRefFn<any> | ClassSchema | PlainSchemaProps | FieldDecoratorResult<any>>(type: T): FieldDecoratorResult<{
        [name: string]: ExtractType<T>;
    }>;
}
/**
 * This is the main decorator to define a properties on class or arguments on methods.
 *
 * ```typescript
 * class SubModel {
 *    @f label: string;
 * }
 *
 * export enum Plan {
 *   DEFAULT,
 *   PRO,
 *   ENTERPRISE,
 * }
 *
 * class SimpleModel {
 *   @t.primary.uuid
 *   id: string = uuid();
 *
 *   @t.array(f.string)
 *   tags: string[] = [];
 *
 *   @t.type(ArrayBuffer).optional() //binary
 *   picture?: ArrayBuffer;
 *
 *   @f
 *   type: number = 0;
 *
 *   @t.enum(Plan)
 *   plan: Plan = Plan.DEFAULT;
 *
 *   @f
 *   created: Date = new Date;
 *
 *   @t.array(SubModel)
 *   children: SubModel[] = [];
 *
 *   @t.map(SubModel)
 *   childrenMap: {[key: string]: SubModel} = {};
 *
 *   constructor(
 *       @t.index().name('name') //name is required for minimized code
 *       public name: string
 *   ) {}
 * }
 * ```
 *
 * @category Decorator
 */
export declare const f: MainDecorator & FieldDecoratorResult<any>;
export declare const field: MainDecorator & FieldDecoratorResult<any>;
export declare const type: MainDecorator & FieldDecoratorResult<any>;
export declare const t: MainDecorator & FieldDecoratorResult<any>;
/**
 * Used to define an index on a class.
 *
 * @category Decorator
 */
export declare function MultiIndex(fields: string[], options?: IndexOptions, name?: string): (target: object, property?: string | undefined, parameterIndexOrDescriptor?: any) => void;
export {};
