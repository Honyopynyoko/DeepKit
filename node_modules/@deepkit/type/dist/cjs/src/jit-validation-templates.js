"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = require("./model");
const jit_validation_registry_1 = require("./jit-validation-registry");
const jit_validation_1 = require("./jit-validation");
const core_1 = require("@deepkit/core");
const union_1 = require("./union");
const json_typeguards_1 = require("./json-typeguards");
const reference_1 = require("./reference");
jit_validation_registry_1.registerCheckerCompiler('number', (accessor, property, utils) => {
    return `
    if ('number' !== typeof ${accessor}) {
        if ('string' === typeof ${accessor}) {
            if (!Number.isFinite(parseFloat(${accessor}))) {
                ${utils.raise('invalid_number', 'No number given')}
            }
        } else {
            ${utils.raise('invalid_number', 'No number given')}
        }
    } else if (${accessor} !== ${accessor}) {
        ${utils.raise('invalid_number', 'No valid number given, got NaN')}
    }
    `;
});
jit_validation_registry_1.registerCheckerCompiler('string', (accessor, property, utils) => {
    return `if ('string' !== typeof ${accessor}) ${utils.raise('invalid_string', 'No string given')};`;
});
jit_validation_registry_1.registerCheckerCompiler('enum', (accessor, property, utils) => {
    //this is a candidate where we can extract ENUM information during build time and check very fast during
    //runtime, so we don't need a call to getResolvedClassTypeForValidType(), isValidEnumValue(), etc in runtime anymore.
    const allowLabelsAsValue = property.allowLabelsAsValue;
    const typeValue = utils.reserveVariable();
    const valids = core_1.getEnumValues(property.resolveClassType);
    if (allowLabelsAsValue) {
        for (const label of core_1.getEnumLabels(property.resolveClassType)) {
            valids.push(label);
        }
    }
    return {
        template: `
        var typeValue = ${typeValue};
        if (undefined !== ${accessor} && !isValidEnumValue(typeValue, ${accessor}, ${allowLabelsAsValue})) {
            ${utils.raise('invalid_enum', `Invalid enum value received. Allowed: ${valids.join(',')}`)};
        }
    `,
        context: {
            [typeValue]: property.resolveClassType,
            isValidEnumValue: core_1.isValidEnumValue,
            getEnumValues: core_1.getEnumValues,
            getEnumLabels: core_1.getEnumLabels,
            getValidEnumValue: core_1.getValidEnumValue
        }
    };
});
jit_validation_registry_1.registerCheckerCompiler('boolean', (accessor, property, utils) => {
    return `
    if ('boolean' !== typeof ${accessor}) {
        if (${accessor} === '1' || ${accessor} === '0' || ${accessor} === 'true' || ${accessor} === 'false' || ${accessor} === 0 || ${accessor} === 1) {
        } else {
            ${utils.raise('invalid_boolean', 'No Boolean given')};
        }
    }`;
});
jit_validation_registry_1.registerCheckerCompiler('uuid', (accessor, property, utils) => {
    return {
        template: `
        if ('string' !== typeof ${accessor} || !${accessor}.match(uuidValidation)) {
            ${utils.raise('invalid_uuid', 'No UUID given')};
        }
        `,
        context: {
            uuidValidation: new RegExp(/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)
        }
    };
});
jit_validation_registry_1.registerCheckerCompiler('objectId', (accessor, property, utils) => {
    return {
        template: `
        if ('string' !== typeof ${accessor} || !${accessor}.match(objectIdValidation)) {
            ${utils.raise('invalid_objectId', 'No Mongo ObjectID given')};
        }
        `,
        context: {
            objectIdValidation: new RegExp(/^[a-fA-F0-9]{24}$/)
        }
    };
});
jit_validation_registry_1.registerCheckerCompiler('date', (accessor, property, utils) => {
    return `
    if (${accessor} instanceof Date) {
        if (isNaN(new Date(${accessor}).getTime())) {
            ${utils.raise('invalid_date', 'No valid Date given')};
        }
    } else if ('string' !== typeof ${accessor} || !${accessor}) {
        ${utils.raise('invalid_date', 'No Date string given')};
    } else if (isNaN(new Date(${accessor}).getTime())) {
        ${utils.raise('invalid_date', 'No valid Date string given')};
    }
    `;
});
jit_validation_registry_1.registerCheckerCompiler('class', (accessor, property, utils, jitStack) => {
    const jitValidateThis = utils.reserveVariable('jitValidate');
    const classSchema = model_1.getClassSchema(property.resolveClassType);
    utils.context.set('referenceSymbol', reference_1.referenceSymbol);
    return {
        template: `
            if ('object' === typeof ${accessor} && 'function' !== typeof ${accessor}.slice) {
                if ((!_stack || _stack.length === 0 || !_stack.includes(${accessor})) && !(referenceSymbol in ${accessor})) {
                    ${jitValidateThis}.fn(${accessor}, ${utils.path}, _errors, _stack);
                }
            } else {
                ${utils.raise('invalid_type', 'Type is not an object')};
            }
        `,
        context: {
            [jitValidateThis]: jitStack.getOrCreate(classSchema, () => jit_validation_1.jitValidate(classSchema, jitStack))
        }
    };
});
jit_validation_registry_1.registerCheckerCompiler('literal', (accessor, property, utils) => {
    //todo. really necessary? Because we force set the literal value always, no matter what value comes in.
    return '';
});
jit_validation_registry_1.registerCheckerCompiler('union', (accessor, property, utils, jitStack) => {
    const context = new Map();
    let discriminator = [`if (false) { }`];
    for (const unionType of union_1.getSortedUnionTypes(property, json_typeguards_1.jsonTypeGuards)) {
        const guardVar = utils.reserveVariable('guard_' + unionType.property.type);
        context.set(guardVar, unionType.guard);
        discriminator.push(`
                //guard:${unionType.property.type}
                else if (${guardVar}(${accessor})) {
                    //validate this type: ${unionType.property.type}
                    ${jit_validation_1.getDataCheckerJS(utils.path, accessor, unionType.property, context, jitStack)}
                }
            `);
    }
    return {
        template: `
             ${discriminator.join('\n')}
             else {
                if (${accessor} === null) {
                    if (!${property.isNullable}) {
                        ${utils.raise('required', 'Required value is null')};
                    }
                } else if (${accessor} === undefined) {
                    if (!${property.isUndefinedAllowed()}) {
                        ${utils.raise('required', 'Required value is undefined')};
                    }
                } else {
                    ${utils.raise('invalid_union', 'No compatible type for union found')};
                }
             }
        `,
        context: context,
    };
});
//# sourceMappingURL=jit-validation-templates.js.map