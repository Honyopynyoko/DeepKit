"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertArray = exports.compilerToNumber = exports.cloneClass = exports.isBigIntJSON = exports.isBinaryJSON = exports.validatedPlainToClass = exports.plainToClass = exports.classToPlain = exports.compilerToString = exports.jsonSerializer = exports.JSONSerializer = void 0;
const core_1 = require("@deepkit/core");
const core_2 = require("./core");
const jit_1 = require("./jit");
const json_typeguards_1 = require("./json-typeguards");
const model_1 = require("./model");
const serializer_1 = require("./serializer");
const serializer_compiler_1 = require("./serializer-compiler");
const union_1 = require("./union");
const validation_1 = require("./validation");
const reference_1 = require("./reference");
class JSONSerializer extends serializer_1.Serializer {
    constructor() {
        super('json');
    }
}
exports.JSONSerializer = JSONSerializer;
exports.jsonSerializer = new JSONSerializer();
function compilerToString(property, state) {
    state.addSetter(`typeof ${state.accessor} === 'string' ? ${state.accessor} : ''+${state.accessor};`);
}
exports.compilerToString = compilerToString;
/**
 * Converts a class instance into a plain object, which can be used with JSON.stringify() to convert it into a JSON string.
 */
function classToPlain(classTypeOrSchema, target, options) {
    return jit_1.getClassToXFunction(model_1.getClassSchema(classTypeOrSchema), exports.jsonSerializer)(target, options);
}
exports.classToPlain = classToPlain;
/**
 * Take a regular object literal and returns an instance of classType.
 * Missing data is either replaced by the default value of that property or undefined.
 *
 * This method does not validate the given data. Use either [[validatedPlainToClass]] to validate beforehand
 * or use [[validate]] on your newly created instance.
 *
 * ```typescript
 * const entity = plainToClass(MyEntity, {field1: 'value'});
 * entity instanceof MyEntity; //true
 * ```
 */
function plainToClass(classTypeOrSchema, data, options) {
    return jit_1.getXToClassFunction(model_1.getClassSchema(classTypeOrSchema), exports.jsonSerializer)(data, options);
}
exports.plainToClass = plainToClass;
/**
 * Same as [plainToClass] but with validation before creating the class instance.
 *
 * ```typescript
 * try {
 *     const entity = await validatedPlainToClass(MyEntity, {field1: 'value'});
 *     entity instanceof MyEntity; //true
 * } catch (error) {
 *     if (error instanceof ValidationFailed) {
 *         //handle that case.
 *     }
 * }
 * ```
 */
function validatedPlainToClass(classType, data, options) {
    const errors = validation_1.validate(classType, data);
    if (errors.length) {
        throw new validation_1.ValidationFailed(errors);
    }
    return plainToClass(classType, data, options);
}
exports.validatedPlainToClass = validatedPlainToClass;
function isBinaryJSON(v) {
    return v && v['$type'] === 'binary' && typeof v.data === 'string';
}
exports.isBinaryJSON = isBinaryJSON;
function isBigIntJSON(v) {
    return v && v['$type'] === 'bigint' && typeof v.data === 'string';
}
exports.isBigIntJSON = isBigIntJSON;
/**
 * Clones a class instance deeply.
 */
function cloneClass(target, options) {
    const s = exports.jsonSerializer.for(model_1.getClassTypeFromInstance(target));
    return s.deserialize(s.serialize(target, options), options, options === null || options === void 0 ? void 0 : options.parents);
}
exports.cloneClass = cloneClass;
exports.jsonSerializer.toClass.register('string', compilerToString);
exports.jsonSerializer.fromClass.register('string', compilerToString);
function compilerToNumber(property, state) {
    state.addSetter(`typeof ${state.accessor} === 'number' ? ${state.accessor} : +${state.accessor};`);
}
exports.compilerToNumber = compilerToNumber;
exports.jsonSerializer.toClass.register('number', compilerToNumber);
exports.jsonSerializer.fromClass.register('number', compilerToNumber);
exports.jsonSerializer.toClass.register('literal', (property, state) => {
    const literalValue = state.setVariable('_literal_value_' + property.name, property.literalValue);
    state.addSetter(literalValue);
});
exports.jsonSerializer.toClass.register('uuid', (property, state) => {
    state.addCodeForSetter(`if ('string' === typeof ${state.accessor}) ${state.setter} = ${state.accessor};`);
});
exports.jsonSerializer.fromClass.register('uuid', (property, state) => {
    state.addCodeForSetter(`if ('string' === typeof ${state.accessor}) ${state.setter} = ${state.accessor};`);
});
exports.jsonSerializer.toClass.prepend('undefined', (property, state) => {
    if (property.type === 'literal' && !property.isOptional) {
        const literalValue = state.setVariable('_literal_value_' + property.name, property.literalValue);
        state.addSetter(literalValue);
    }
    return;
});
exports.jsonSerializer.fromClass.prepend('undefined', (property, state) => {
    if (property.type === 'literal' && !property.isOptional) {
        const literalValue = state.setVariable('_literal_value_' + property.name, property.literalValue);
        state.addSetter(literalValue);
    }
    return;
});
exports.jsonSerializer.toClass.prepend('null', (property, state) => {
    if (property.type === 'literal' && !property.isNullable) {
        const literalValue = state.setVariable('_literal_value_' + property.name, property.literalValue);
        state.addSetter(literalValue);
    }
});
exports.jsonSerializer.fromClass.prepend('null', (property, state) => {
    if (property.type === 'literal' && !property.isNullable) {
        const literalValue = state.setVariable('_literal_value_' + property.name, property.literalValue);
        state.addSetter(literalValue);
    }
});
exports.jsonSerializer.toClass.register('date', (property, state) => {
    state.addSetter(`new Date(${state.accessor});`);
});
exports.jsonSerializer.toClass.register('boolean', (property, state) => {
    state.addCodeForSetter(`
    if ('boolean' === typeof ${state.accessor}) {
        ${state.setter} = ${state.accessor};
    } else {
        if ('true' === ${state.accessor} || '1' === ${state.accessor} || 1 === ${state.accessor}) ${state.setter} = true;
        if ('false' === ${state.accessor} || '0' === ${state.accessor} || 0 === ${state.accessor}) ${state.setter} = false;
    }
    `);
});
exports.jsonSerializer.toClass.register('enum', (property, state) => {
    //this a candidate where we can extract ENUM information during build time and check very fast during
    //runtime, so we don't need a call to getResolvedClassTypeForValidType(), isValidEnumValue(), etc in runtime anymore.
    const allowLabelsAsValue = property.allowLabelsAsValue;
    const typeValue = state.setVariable('typeValue', property.resolveClassType);
    state.setContext({
        isValidEnumValue: core_1.isValidEnumValue,
        getEnumValues: core_1.getEnumValues,
        getEnumLabels: core_1.getEnumLabels,
        getValidEnumValue: core_1.getValidEnumValue
    });
    state.addCodeForSetter(`
        var typeValue = ${typeValue};
        if (undefined !== ${state.accessor} && !isValidEnumValue(typeValue, ${state.accessor}, ${allowLabelsAsValue})) {
            const valids = getEnumValues(typeValue);
            if (${allowLabelsAsValue}) {
                //IE11 compatible way
                getEnumLabels(typeValue).forEach(function(label){valids.push(label);});
            }
            throw new Error('Invalid ENUM given in property ${property.name}: ' + ${state.accessor} + ', valid: ' + valids.join(','));
        }
        ${state.setter} = getValidEnumValue(typeValue, ${state.accessor}, ${allowLabelsAsValue});
    `);
});
exports.jsonSerializer.toClass.registerForBinary((property, state) => {
    state.setContext({ base64ToTypedArray: core_2.base64ToTypedArray });
    state.setContext({ isBinaryJSON });
    //property.type maps to global type constructor names
    state.addSetter(`${state.accessor} instanceof ${property.type} ? ${state.accessor} : (isBinaryJSON(${state.accessor}) ? base64ToTypedArray(${state.accessor}.data, ${property.type}) : new ${property.type}())`);
});
exports.jsonSerializer.toClass.register('arrayBuffer', (property, state) => {
    state.setContext({ base64ToArrayBuffer: core_2.base64ToArrayBuffer });
    state.setContext({ isBinaryJSON });
    state.addSetter(`${state.accessor} instanceof ArrayBuffer ? ${state.accessor} : (isBinaryJSON(${state.accessor}) ? base64ToArrayBuffer(${state.accessor}.data): new ArrayBuffer())`);
});
//we need to add '$type' to make union with auto-detection work
exports.jsonSerializer.fromClass.registerForBinary((property, state) => {
    state.setContext({ typedArrayToBase64: core_2.typedArrayToBase64 });
    state.addSetter(`{'$type': 'binary', data: typedArrayToBase64(${state.accessor})}`);
});
exports.jsonSerializer.fromClass.register('arrayBuffer', (property, state) => {
    state.setContext({ arrayBufferToBase64: core_2.arrayBufferToBase64 });
    state.addSetter(`{'$type': 'binary', data: arrayBufferToBase64(${state.accessor})}`);
});
exports.jsonSerializer.toClass.register('bigint', (property, state) => {
    state.setContext({ isBigIntJSON });
    state.addSetter(`typeof ${state.accessor} === 'bigint' ? ${state.accessor} : (isBigIntJSON(${state.accessor}) ? BigInt('0x' + ${state.accessor}.data): 0n)`);
});
exports.jsonSerializer.fromClass.register('bigint', (property, state) => {
    state.addSetter(`{'$type': 'bigint', data: ${state.accessor}.toString(16)}`);
});
const convertToPlainUsingToJson = (property, state) => {
    state.addSetter(`${state.accessor}.toJSON();`);
};
exports.jsonSerializer.fromClass.register('date', convertToPlainUsingToJson);
function convertArray(property, state) {
    const a = state.setVariable('a');
    const l = state.setVariable('l');
    let setDefault = property.isOptional ? '' : `${state.setter} = [];`;
    //we just use `a.length` to check whether its array-like, because Array.isArray() is way too slow.
    state.addCodeForSetter(`
    if (${state.accessor}.length === undefined || 'string' === typeof ${state.accessor} || 'function' !== typeof ${state.accessor}.slice) {
        ${setDefault}
    } else {
         let ${l} = ${state.accessor}.length;
         let ${a} = ${state.accessor}.slice();
         while (${l}--) {
            //make sure all elements have the correct type
            if (${state.accessor}[${l}] !== undefined && ${state.accessor}[${l}] !== null) {
                let itemValue;
                ${serializer_compiler_1.getDataConverterJS(`itemValue`, `${a}[${l}]`, property.getSubType(), state.serializerCompilers, state.rootContext, state.jitStack)}
                if (${!property.getSubType().isOptional} && itemValue === undefined) {
                    ${a}.splice(${l}, 1);
                } else {
                    ${a}[${l}] = itemValue;
                }
            }
         }
         ${state.setter} = ${a};
    }
    `);
}
exports.convertArray = convertArray;
exports.jsonSerializer.fromClass.register('array', convertArray);
exports.jsonSerializer.toClass.register('array', convertArray);
function convertMap(property, state) {
    const a = state.setVariable('a');
    const i = state.setVariable('i');
    let setDefault = property.isOptional ? '' : `${state.setter} = {};`;
    state.addCodeForSetter(`
        let ${a} = {};
        //we make sure its a object and not an array
        if (${state.accessor} && 'object' === typeof ${state.accessor} && 'function' !== typeof ${state.accessor}.slice) {
            for (let ${i} in ${state.accessor}) {
                if (!${state.accessor}.hasOwnProperty(${i})) continue;
                if (${!property.getSubType().isOptional} && ${state.accessor}[${i}] === undefined) {
                    continue;
                }
                ${serializer_compiler_1.getDataConverterJS(`${a}[${i}]`, `${state.accessor}[${i}]`, property.getSubType(), state.serializerCompilers, state.rootContext, state.jitStack)}
            }
            ${state.setter} = ${a};
        } else {
            ${setDefault}
        }
    `);
}
exports.jsonSerializer.fromClass.register('map', convertMap);
exports.jsonSerializer.toClass.register('map', convertMap);
exports.jsonSerializer.fromClass.register('class', (property, state) => {
    const foreignClassSchema = model_1.getClassSchema(property.resolveClassType);
    const classToX = state.setVariable('classToX', state.jitStack.getOrCreate(foreignClassSchema, () => jit_1.getClassToXFunction(foreignClassSchema, state.serializerCompilers.serializer, state.jitStack)));
    state.setContext({ isObject: core_1.isObject, isReference: reference_1.isReference, isReferenceHydrated: reference_1.isReferenceHydrated });
    let serializeObject = `
        ${state.setter} = ${classToX}.fn(${state.accessor}, _options, _stack, _depth);
    `;
    let serialize;
    if (property.isReference && foreignClassSchema.hasPrimaryFields()) {
        serializeObject = `
        if (isReference(${state.accessor}) && !isReferenceHydrated(${state.accessor})) {
            ${serializer_compiler_1.getDataConverterJS(state.setter, `${state.accessor}.${foreignClassSchema.getPrimaryField().name}`, foreignClassSchema.getPrimaryField(), state.serializerCompilers, state.rootContext, state.jitStack)}
        } else {
            ${state.setter} = ${classToX}.fn(${state.accessor}, _options, _stack, _depth);
        }
        `;
    }
    state.addCodeForSetter(`
    if (isObject(${state.accessor})) {
        ${serializeObject}
    } else if (${property.isReference}) {
        ${state.setter} = ${state.accessor};
    }
    `);
});
exports.jsonSerializer.toClass.register('class', (property, state) => {
    if (!property.resolveClassType) {
        throw new Error(`Property ${property.name} has no classType defined`);
    }
    const foreignClassSchema = model_1.getClassSchema(property.resolveClassType);
    const xToClass = state.setVariable('xToClass', state.jitStack.getOrCreate(foreignClassSchema, () => jit_1.getXToClassFunction(foreignClassSchema, state.serializerCompilers.serializer, state.jitStack)));
    if (foreignClassSchema.decorator) {
        //the actual type checking happens within getXToClassFunction()'s constructor param
        //so we dont check here for object.
        state.addSetter(`${xToClass}.fn(${state.accessor}, _options, getParents(), _state)`);
        return;
    }
    state.setContext({ isObject: core_1.isObject, isReference: reference_1.isReference, createReference: reference_1.createReference });
    let primaryKeyHandling = '';
    if (property.isReference) {
        const referenceClassTypeVar = state.setVariable('referenceClassType', reference_1.createReferenceClass(foreignClassSchema));
        //when its a primary key only, we need to convert it to the a real object.
        //if we
        primaryKeyHandling = `
            if (isObject(${state.accessor})) {
                ${serializer_compiler_1.getDataConverterJS(state.setter, state.accessor, property.getResolvedClassSchema().getPrimaryField(), state.serializerCompilers, state.rootContext, state.jitStack)}
            } else {
                ${state.setter} = createReference(${referenceClassTypeVar}, {${foreignClassSchema.getPrimaryField().name}: ${state.accessor}});
            }
        `;
    }
    state.addCodeForSetter(`
        //object and not an array
        if ('object' === typeof ${state.accessor} && 'function' !== typeof ${state.accessor}.slice) {
            if (isReference(${state.accessor})) {
                ${state.setter} = ${state.accessor};
            } else {
                ${state.setter} = ${xToClass}.fn(${state.accessor}, _options, getParents(), _state);
            }
        } else if (${!property.isReference} && 'string' === typeof ${state.accessor} && '{' === ${state.accessor}[0]) {
            try {
                ${state.setter} = ${xToClass}.fn(JSON.parse(${state.accessor}), _options, getParents(), _state);
            } catch (e) {}
        } else if (${property.isReference}) {
            ${primaryKeyHandling}
        }
    `);
});
exports.jsonSerializer.toClass.register('union', (property, state) => {
    let discriminator = [`if (false) { }`];
    const discriminants = [];
    for (const unionType of union_1.getSortedUnionTypes(property, json_typeguards_1.jsonTypeGuards)) {
        discriminants.push(unionType.property.type);
    }
    let elseBranch = `throw new Error('No valid discriminant was found, so could not determine class type. Guard tried: [${discriminants.join(',')}].');`;
    if (property.isOptional) {
        elseBranch = '';
    }
    else if (property.isNullable) {
        elseBranch = `${state.setter} = null;`;
    }
    else if (property.hasManualDefaultValue()) {
        const defaultVar = state.setVariable('default', property.defaultValue);
        elseBranch = `${state.setter} = ${defaultVar}();`;
    }
    for (const unionType of union_1.getSortedUnionTypes(property, json_typeguards_1.jsonTypeGuards)) {
        const guardVar = state.setVariable('guard_' + unionType.property.type, unionType.guard);
        discriminator.push(`
                //guard:${unionType.property.type}
                else if (${guardVar}(${state.accessor})) {
                    ${serializer_compiler_1.getDataConverterJS(state.setter, state.accessor, unionType.property, state.serializerCompilers, state.rootContext, state.jitStack)}
                }
            `);
    }
    state.addCodeForSetter(`
        ${discriminator.join('\n')}
        else {
            ${elseBranch}
        }
    `);
});
exports.jsonSerializer.fromClass.register('union', (property, state) => {
    let discriminator = [`if (false) { }`];
    const discriminants = [];
    for (const unionType of union_1.getSortedUnionTypes(property, json_typeguards_1.jsonTypeGuards)) {
        discriminants.push(unionType.property.type);
    }
    let elseBranch = `throw new Error('No valid discriminant was found, so could not determine class type. Guard tried: [${discriminants.join(',')}].');`;
    if (property.isOptional) {
        elseBranch = '';
    }
    else if (property.isNullable) {
        elseBranch = `${state.setter} = null;`;
    }
    else if (property.hasManualDefaultValue()) {
        const defaultVar = state.setVariable('default', property.defaultValue);
        elseBranch = `${state.setter} = ${defaultVar}();`;
    }
    for (const unionType of union_1.getSortedUnionTypes(property, json_typeguards_1.jsonTypeGuards)) {
        const guardVar = state.setVariable('guard_' + unionType.property.type, unionType.guard);
        discriminator.push(`
                //guard:${unionType.property.type}
                else if (${guardVar}(${state.accessor})) {
                    ${serializer_compiler_1.getDataConverterJS(state.setter, state.accessor, unionType.property, state.serializerCompilers, state.rootContext, state.jitStack)}
                }
            `);
    }
    state.addCodeForSetter(`
        ${discriminator.join('\n')}
        else {
            ${elseBranch}
        }
    `);
});
exports.jsonSerializer.toClass.register('partial', (property, state) => {
    const classSchema = model_1.getClassSchema(property.getSubType().resolveClassType);
    const partialXToClass = state.setVariable('partialXToClass', state.jitStack.getOrCreate(classSchema, () => jit_1.getPartialXToClassFunction(classSchema, state.serializerCompilers.serializer)));
    state.addSetter(`${partialXToClass}.fn(${state.accessor}, _options, getParents(), _state);`);
});
exports.jsonSerializer.fromClass.register('partial', (property, state) => {
    const classSchema = model_1.getClassSchema(property.getSubType().resolveClassType);
    const partialClassToX = state.setVariable('partialClassToX', state.jitStack.getOrCreate(classSchema, () => jit_1.getPartialClassToXFunction(classSchema, state.serializerCompilers.serializer)));
    state.addSetter(`${partialClassToX}.fn(${state.accessor}, _options, _stack, _depth)`);
});
//# sourceMappingURL=json-serializer.js.map