"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClassSchema = exports.getClassSchema = exports.hasClassSchema = exports.getOrCreateEntitySchema = exports.classSchemaSymbol = exports.getKnownClassSchemasNames = exports.getClassSchemaByName = exports.hasClassSchemaByName = exports.mixin = exports.sliceClass = exports.ClassSlicer = exports.ClassSchema = exports.PropertySchema = exports.isRegisteredEntity = exports.isClassInstance = exports.getClassTypeFromInstance = exports.unpopulatedSymbol = exports.forwardRef = exports.ForwardRef = exports.isPropertyValidator = exports.resolveClassTypeOrForward = exports.getGlobalStore = exports.UnpopulatedCheck = exports.getSingleTableInheritanceTypeValue = void 0;
const core_1 = require("@deepkit/core");
const decorators_1 = require("./decorators");
const inheritance_1 = require("./inheritance");
const types_1 = require("./types");
const utils_1 = require("./utils");
function getSingleTableInheritanceTypeValue(classSchema) {
    if (!classSchema.singleTableInheritance)
        throw new Error(`${classSchema.getClassName()} has no singleTableInheritance enabled.`);
    let value = classSchema.singleTableInheritance.type;
    return value || classSchema.name || classSchema.getClassName().toLowerCase();
}
exports.getSingleTableInheritanceTypeValue = getSingleTableInheritanceTypeValue;
var UnpopulatedCheck;
(function (UnpopulatedCheck) {
    UnpopulatedCheck[UnpopulatedCheck["None"] = 0] = "None";
    UnpopulatedCheck[UnpopulatedCheck["Throw"] = 1] = "Throw";
    UnpopulatedCheck[UnpopulatedCheck["ReturnSymbol"] = 2] = "ReturnSymbol";
})(UnpopulatedCheck = exports.UnpopulatedCheck || (exports.UnpopulatedCheck = {}));
const globalStore = {
    RegisteredEntities: {},
    unpopulatedCheck: UnpopulatedCheck.Throw,
    enableForwardRefDetection: true,
};
function getGlobalStore() {
    return globalStore;
}
exports.getGlobalStore = getGlobalStore;
function resolveClassTypeOrForward(type) {
    return core_1.isFunction(type) ? type() : type;
}
exports.resolveClassTypeOrForward = resolveClassTypeOrForward;
function isPropertyValidator(object) {
    return core_1.isClass(object);
}
exports.isPropertyValidator = isPropertyValidator;
class ForwardRef {
    constructor(forwardRef) {
        this.forwardRef = forwardRef;
    }
}
exports.ForwardRef = ForwardRef;
function forwardRef(forwardRef) {
    return new ForwardRef(forwardRef);
}
exports.forwardRef = forwardRef;
function resolveForwardRef(forwardRef) {
    if (forwardRef instanceof ForwardRef) {
        return forwardRef.forwardRef();
    }
    else {
        try {
            return forwardRef();
        }
        catch (_a) {
            return undefined;
        }
    }
}
exports.unpopulatedSymbol = Symbol('unpopulated');
/**
 * Returns the ClassType for a given instance.
 */
function getClassTypeFromInstance(target) {
    if (!isClassInstance(target)) {
        throw new Error('Target does not seem to be a class instance.');
    }
    return target['constructor'];
}
exports.getClassTypeFromInstance = getClassTypeFromInstance;
/**
 * Returns true when target is a class instance.
 */
function isClassInstance(target) {
    return target
        && target['constructor']
        && Object.getPrototypeOf(target) === target['constructor'].prototype
        && !core_1.isPlainObject(target)
        && core_1.isObject(target);
}
exports.isClassInstance = isClassInstance;
/**
 * Returns true if given class has an @entity() or @t defined, and thus became
 * a deepkit/type entity.
 */
function isRegisteredEntity(classType) {
    return classType.prototype.hasOwnProperty(exports.classSchemaSymbol);
}
exports.isRegisteredEntity = isRegisteredEntity;
/**
 * Represents a class property or method argument/return-type definition.
 */
class PropertySchema {
    constructor(name, parent) {
        this.name = name;
        this.parent = parent;
        this.type = 'any';
        this.noValidation = false;
        /**
         * Object to store JIT function for this schema.
         */
        this.jit = {};
        this.groupNames = [];
        this.isOptional = false;
        this.isNullable = false;
        /**
         * When the a property is defined as ! you have to manually use t.required.
         */
        this.manuallySetToRequired = false;
        this.isDiscriminant = false;
        //for enums
        this.allowLabelsAsValue = false;
        this.isParentReference = false;
        this.validators = [];
        /**
         * Whether its a owning reference.
         */
        this.isReference = false;
        this.referenceOptions = {
            onDelete: 'CASCADE',
            onUpdate: 'CASCADE',
        };
        /**
         * When the constructor sets a default value.
         */
        this.hasDefaultValue = false;
        this.templateArgs = [];
        /**
         * Whether its a foreign key from a owning reference.
         */
        this.isReferenceKey = false;
        /**
         * Used in decorator to check whether type has been set manually using @t decorator.
         */
        this.typeSet = false;
        /**
         * Whether this property is decorated.
         */
        this.isDecorated = false;
        this.isId = false;
        this.isAutoIncrement = false;
        this.symbol = Symbol(this.name);
        /**
         * Custom user data.
         */
        this.data = {};
        this.description = '';
        /**
         * Transformer for serialization.
         */
        this.serialization = new Map();
        /**
         * Transformer for deserialization.
         */
        this.deserialization = new Map();
    }
    /**
     * Returns true when user manually set a default value via PropertySchema/decorator.
     */
    hasManualDefaultValue() {
        return !this.hasDefaultValue && this.defaultValue !== undefined;
    }
    hasCircularDependency(lookingFor, classSchemaStack = [], propertyStack = []) {
        if (this.isParentReference)
            return false;
        if (this.type === 'class') {
            const s = getClassSchema(this.resolveClassType);
            return s === lookingFor || s.hasCircularDependency(lookingFor, classSchemaStack);
        }
        if (propertyStack.includes(this))
            return true;
        propertyStack.push(this);
        for (const arg of this.templateArgs) {
            if (arg.hasCircularDependency(lookingFor, classSchemaStack, propertyStack))
                return true;
        }
        return false;
    }
    /**
     * Returns true when `undefined` or a missing value is allowed.
     * This is now only true when `optional` is set, but alos when type is `any`,
     * or when the property has an actual default value (then a undefined value sets the default value instead).
     */
    isUndefinedAllowed() {
        return this.isOptional || this.type === 'any' || this.hasManualDefaultValue() || this.hasDefaultValue;
    }
    get isArray() {
        return this.type === 'array';
    }
    get isMap() {
        return this.type === 'map';
    }
    get isPatch() {
        return this.type === 'partial';
    }
    get isPartial() {
        return this.type === 'partial';
    }
    get isTypedArray() {
        return types_1.typedArrayNamesMap.has(this.type);
    }
    get isBinary() {
        return this.type === 'arrayBuffer' || this.isTypedArray;
    }
    setType(type) {
        this.type = type;
        this.typeSet = true;
    }
    getDefaultValue() {
        if (this.literalValue)
            return this.literalValue;
        if (this.defaultValue) {
            this.lastGeneratedDefaultValue = this.defaultValue();
            return this.lastGeneratedDefaultValue;
        }
        return this.extractedDefaultValue;
    }
    toString(optionalAffix = true) {
        let affix = this.isOptional && optionalAffix ? '?' : '';
        if (this.isNullable)
            affix += '|null';
        if (this.type === 'array') {
            return `${this.templateArgs[0]}[]${affix}`;
        }
        if (this.type === 'map') {
            return `Map<${this.templateArgs[0]}, ${this.templateArgs[1]}>${affix}`;
        }
        if (this.type === 'partial') {
            return `Partial<${this.templateArgs[0]}>${affix}`;
        }
        if (this.type === 'union') {
            return this.templateArgs.map(v => v.toString()).join(' | ') + affix;
        }
        if (this.type === 'enum') {
            return 'enum' + affix;
        }
        if (this.type === 'class') {
            if (this.classTypeName)
                return this.classTypeName + affix;
            if (this.classTypeForwardRef) {
                const resolved = resolveForwardRef(this.classTypeForwardRef);
                if (resolved)
                    return core_1.getClassName(resolved) + affix;
                return 'ForwardedRef' + affix;
            }
            else {
                return this.classType ? core_1.getClassName(this.classType) + affix : '[not-loaded]' + affix;
            }
        }
        return `${this.type}${affix}`;
    }
    getSubType() {
        if (this.type === 'partial')
            return this.templateArgs[0];
        if (this.type === 'array')
            return this.templateArgs[0];
        if (this.type === 'map')
            return this.templateArgs[1];
        throw new Error('No array or map type');
    }
    setClassType(classType) {
        this.classType = classType;
    }
    toJSON() {
        const props = {
            name: this.name,
            type: this.type
        };
        if (this.literalValue !== undefined)
            props.literalValue = this.literalValue;
        if (this.extractedDefaultValue !== undefined)
            props.extractedDefaultValue = this.extractedDefaultValue;
        if (this.isDecorated)
            props.isDecorated = true;
        if (this.isDiscriminant)
            props.isDiscriminant = true;
        if (this.isParentReference)
            props.isParentReference = true;
        if (this.isOptional)
            props.isOptional = true;
        if (this.isId)
            props.isId = true;
        if (this.allowLabelsAsValue)
            props.allowLabelsAsValue = true;
        if (this.typeSet)
            props.typeSet = true;
        if (this.methodName)
            props.methodName = this.methodName;
        if (this.groupNames.length)
            props.groupNames = this.groupNames;
        if (this.defaultValue)
            props.defaultValue = this.defaultValue();
        if (this.isReference)
            props.isReference = this.isReference;
        if (this.type === 'enum')
            props.enum = this.getResolvedClassType();
        if (this.isAutoIncrement)
            props.autoIncrement = true;
        props.noValidation = this.noValidation;
        if (this.templateArgs.length)
            props.templateArgs = this.templateArgs.map(v => v.toJSON());
        if (this.backReference) {
            let via = '';
            if (this.backReference.via) {
                const classType = resolveClassTypeOrForward(this.backReference.via);
                via = getClassSchema(classType).getName();
            }
            props.backReference = { mappedBy: this.backReference.mappedBy, via };
        }
        const resolved = this.getResolvedClassTypeForValidType();
        if (resolved) {
            const name = getClassSchema(resolved).name;
            if (!name) {
                props.classTypeName = core_1.getClassName(resolved);
            }
            else {
                props.classType = name;
            }
        }
        return props;
    }
    static fromJSON(props, parent, throwForInvalidClassType = true) {
        const p = new PropertySchema(props['name']);
        p.type = props['type'];
        p.literalValue = props.literalValue;
        p.extractedDefaultValue = props.extractedDefaultValue;
        if (props.isDecorated)
            p.isDecorated = true;
        if (props.isParentReference)
            p.isParentReference = true;
        if (props.isDiscriminant)
            p.isDiscriminant = true;
        if (props.isOptional)
            p.isOptional = true;
        if (props.isId)
            p.isId = true;
        if (props.allowLabelsAsValue)
            p.allowLabelsAsValue = true;
        if (props.typeSet)
            p.typeSet = true;
        if (props.methodName)
            p.methodName = props.methodName;
        if (props.groupNames)
            p.groupNames = props.groupNames;
        if (props.noValidation)
            p.noValidation = props.noValidation;
        if (props.isReference)
            p.isReference = props.isReference;
        if (props.autoIncrement)
            p.isAutoIncrement = props.autoIncrement;
        if (props.enum)
            p.classType = props.enum;
        if (props.defaultValue)
            p.defaultValue = () => props.defaultValue;
        if (props.templateArgs) {
            p.templateArgs = props.templateArgs.map(v => PropertySchema.fromJSON(v, p, throwForInvalidClassType));
        }
        if (props.backReference) {
            p.backReference = { mappedBy: props.backReference.mappedBy };
            if (props.backReference.via) {
                const entity = getGlobalStore().RegisteredEntities[props.backReference.via];
                if (entity) {
                    p.backReference.via = getClassSchema(entity).classType;
                }
                else if (throwForInvalidClassType) {
                    throw new Error(`Could not unserialize type information for ${p.methodName ? p.methodName + '.' : ''}${p.name}, got entity name ${props.backReference.via} . ` +
                        `Make sure given entity is loaded (imported at least once globally) and correctly annoated using @entity.name('${props.backReference.via}')`);
                }
            }
        }
        if (props.classType) {
            const entity = getGlobalStore().RegisteredEntities[props.classType];
            if (entity) {
                p.classType = getClassSchema(entity).classType;
            }
            else if (throwForInvalidClassType) {
                throw new Error(`Could not unserialize type information for ${p.methodName ? p.methodName + '.' : ''}${p.name}, got entity name ${props.classType} . ` +
                    `Make sure given entity is loaded (imported at least once globally) and correctly annoated using @entity.name('${props.classType}')`);
            }
            // } else if (p.type === 'class' && !props['classType']) {
            //     throw new Error(`Could not unserialize type information for ${p.methodName ? p.methodName + '.' : ''}${p.name}, got class name ${props['classTypeName']}. ` +
            //         `Make sure this class has a @entity.name(name) decorator with a unique name assigned and given entity is loaded (imported at least once globally)`);
        }
        p.classTypeName = props.classTypeName;
        return p;
    }
    static getTypeFromJSType(type) {
        if (type && types_1.typedArrayMap.has(type)) {
            return types_1.typedArrayMap.get(type);
        }
        return 'any';
    }
    setFromJSValue(value) {
        if (value === undefined || value === null)
            return;
        this.setFromJSType(value.constructor);
    }
    setFromJSType(type, detectForwardRef = getGlobalStore().enableForwardRefDetection) {
        if (type === undefined || type === null)
            return;
        this.type = PropertySchema.getTypeFromJSType(type);
        this.typeSet = this.type !== 'any';
        if (type === Array) {
            //array doesnt have any other options, so we only know its an array
            //of any type
            this.type = 'array';
            this.typeSet = true;
            this.templateArgs[0] = new PropertySchema('0', this);
            return;
        }
        const isCustomObject = !types_1.typedArrayMap.has(type)
            && type !== 'any'
            && type !== Array
            && type !== Object;
        if (isCustomObject) {
            this.type = 'class';
            this.classType = type;
            if (detectForwardRef && core_1.isFunction(type) && !core_1.isConstructable(type)) {
                this.classTypeForwardRef = type;
                this.classType = undefined;
            }
            if (type instanceof ForwardRef) {
                this.classTypeForwardRef = type;
                this.classType = undefined;
            }
            this.typeSet = true;
        }
    }
    /**
     * Internal note: for multi pk support, this will return a string[] in the future.
     */
    getForeignKeyName() {
        //we stop using capitalizeFirstLetter(this.getResolvedClassSchema().getPrimaryField().name)
        //because that making things easier in the class:mongo compiler templates
        return this.name;
    }
    getResolvedClassSchema() {
        return getClassSchema(this.getResolvedClassType());
    }
    clone() {
        const s = new PropertySchema(this.name, this.parent);
        for (const i of core_1.eachKey(this)) {
            s[i] = this[i];
        }
        s.data = { ...this.data };
        s.symbol = Symbol(this.name);
        s.classType = this.classType;
        // s.classTypeResolved = undefined;
        s.templateArgs = this.templateArgs.slice(0);
        s.serialization = new Map(this.serialization);
        s.deserialization = new Map(this.deserialization);
        return s;
    }
    getTemplateArg(position) {
        return this.templateArgs ? this.templateArgs[position] : undefined;
    }
    get resolveClassType() {
        if (this.type === 'class' || this.type === 'enum') {
            return this.getResolvedClassType();
        }
        return;
    }
    getResolvedClassTypeForValidType() {
        if (this.type === 'class' || this.type === 'enum') {
            return this.getResolvedClassType();
        }
        return;
    }
    isResolvedClassTypeIsDecorated() {
        if (this.type === 'class') {
            const foreignSchema = getClassSchema(this.getResolvedClassType());
            return Boolean(foreignSchema.decorator);
        }
        return false;
    }
    getResolvedClassType() {
        if (this.isArray || this.isMap || this.isPartial)
            return this.getSubType().getResolvedClassType();
        if (this.classTypeResolved) {
            return this.classTypeResolved;
        }
        if (this.classTypeForwardRef) {
            this.classTypeResolved = resolveForwardRef(this.classTypeForwardRef);
            if (this.classTypeResolved) {
                return this.classTypeResolved;
            }
            throw new Error(`ForwardRef returns no value for field ${this.name}`);
        }
        if (!this.classType || utils_1.isArray(this.classType)) {
            throw new Error(`No ClassType given for field ${this.name}. Use @t.type(() => MyClass) for circular dependencies. Did you \`import 'reflect-metadata'\` in your root script?`);
        }
        return this.classType;
    }
}
exports.PropertySchema = PropertySchema;
class ClassSchema {
    constructor(classType) {
        /**
         * The build id. When a property is added, this buildId changes, so JIT compiler knows when to refresh
         * its cache.
         */
        this.buildId = 0;
        this.subClasses = [];
        /**
         * Each method can have its own PropertySchema definition for each argument, where map key = method name.
         */
        this.methodProperties = new Map();
        this.methods = {};
        /**
         * Object to store JIT function for this schema. This object is automatically cleared once the schema changes (added property for example).
         */
        this.jit = {};
        /**
         * Arbitrary data container to assign additional data to a schema.
         */
        this.data = {};
        this.symbol = Symbol('ClassSchema');
        /**
         * @internal
         */
        this.initializedMethods = new Set();
        this.propertiesMap = new Map();
        this.properties = [];
        this.propertyNames = [];
        this.methodsParamNames = new Map();
        this.methodsParamNamesAutoResolved = new Map();
        this.indices = new Map();
        /**
         * Contains all references, owning reference and back references.
         */
        this.references = new Set();
        this.referenceInitialized = false;
        this.onLoad = [];
        this.hasFullLoadHooksCheck = false;
        this.detectedDefaultValueProperties = [];
        this.assignedInConstructor = [];
        this.extractedDefaultValues = {};
        /**
         * Whether this schema comes from an actual class (not t.schema);
         */
        this.fromClass = true;
        if (!classType)
            throw new Error('No classType given');
        this.classType = classType;
        this.parseDefaults();
    }
    /**
     * Whether this schema annotated an actual custom class.
     */
    isCustomClass() {
        return this.classType !== Object;
    }
    toString() {
        return `<ClassSchema ${this.getClassName()}>\n` + this.properties.map(v => '   ' + v.name + '=' + v.toString()).join('\n') + '\n</ClassSchema>';
    }
    getAssignedSingleTableInheritanceSubClassesByIdentifier() {
        if (!this.subClasses.length)
            return;
        const discriminant = this.getSingleTableInheritanceDiscriminant();
        for (const schema of this.subClasses) {
            if (schema.singleTableInheritance) {
                if (!this.assignedSingleTableInheritanceSubClassesByIdentifier)
                    this.assignedSingleTableInheritanceSubClassesByIdentifier = {};
                const value = schema.getProperty(discriminant.name).getDefaultValue() || getSingleTableInheritanceTypeValue(schema);
                this.assignedSingleTableInheritanceSubClassesByIdentifier[value] = schema;
            }
        }
        if (this.subClasses.length === 1)
            throw new Error('wat');
        return this.assignedSingleTableInheritanceSubClassesByIdentifier;
    }
    hasSingleTableInheritanceSubClasses() {
        return this.getAssignedSingleTableInheritanceSubClassesByIdentifier() !== undefined;
    }
    getSingleTableInheritanceDiscriminant() {
        if (this.data.singleTableInheritanceProperty)
            return this.data.singleTableInheritanceProperty;
        let discriminant = inheritance_1.findCommonDiscriminant(this.subClasses);
        //when no discriminator was found, find a common literal
        if (!discriminant)
            discriminant = inheritance_1.findCommonLiteral(this.subClasses);
        if (!discriminant) {
            throw new Error(`Sub classes of ${this.getClassName()} single-table inheritance [${this.subClasses.map(v => v.getClassName())}] have no common discriminant or common literal. Please define one.`);
        }
        return this.data.singleTableInheritanceProperty = this.getProperty(discriminant);
    }
    /**
     * To not force the user to always annotate `.optional` to properties that
     * are actually optional (properties with default values),
     * we automatically read the code of the constructor and check if properties
     * are actually optional. If we find an assignment, we assume it has a default value,
     * and set property.hasDefaultValue = true;
     */
    parseDefaults() {
        const originCode = this.classType.toString();
        const constructorCode = originCode.startsWith('class') ? core_1.extractMethodBody(originCode, 'constructor') : originCode;
        const findAssignment = RegExp(String.raw `this\.([^ \t\.=]+)[^=]*=([^ \n\t;]+)?`, 'g');
        let match;
        while ((match = findAssignment.exec(constructorCode)) !== null) {
            const lname = match[1];
            const rname = match[2];
            this.assignedInConstructor.push(lname);
            if (lname === rname) {
                //its a `this.name=name` assignment, very likely to be a direct construct dependency
                //so it's not per-se optional. If it's optional it can be marked as once later on.
                continue;
            }
            this.detectedDefaultValueProperties.push(lname);
        }
    }
    getCollectionName() {
        const name = this.collectionName || this.name;
        if (!name)
            throw new Error(`No entity name set for ${this.getClassName()}`);
        return name;
    }
    getClassPropertyName(name) {
        return this.getClassName() + '.' + name;
    }
    getName() {
        if (!this.name)
            throw new Error(`Class ${this.getClassName()} has no entity name set`);
        return this.name;
    }
    getClassName() {
        return core_1.getClassName(this.classType);
    }
    getJit(symbol, generator) {
        let jit = this.jit[symbol];
        if (jit !== undefined)
            return jit;
        jit = generator(this);
        this.jit[symbol] = jit;
        core_1.toFastProperties(this.jit);
        return jit;
    }
    hasFullLoadHooks() {
        if (this.hasFullLoadHooksCheck)
            return false;
        this.hasFullLoadHooksCheck = true;
        for (const prop of this.properties) {
            if (prop.type === 'class' && prop.getResolvedClassSchema().hasFullLoadHooks()) {
                return true;
            }
        }
        this.hasFullLoadHooksCheck = false;
        return !!this.onLoad.find(v => !!v.options.fullLoad);
    }
    /**
     * Whether a (deep) property references this schema again. Some validation/serialization code
     * needs to add additional check to avoid an call stack overflow.
     */
    hasCircularDependency(lookingFor, stack = []) {
        lookingFor = lookingFor || this;
        if (stack.includes(this))
            return true;
        stack.push(this);
        for (const property of this.properties) {
            if (property.isParentReference)
                continue;
            if (property.hasCircularDependency(lookingFor, stack))
                return true;
        }
        return false;
    }
    addIndex(fieldNames, name, options) {
        name = name || fieldNames.join('_');
        this.indices.set(name, { fields: fieldNames, options: options || {} });
    }
    clone(classType) {
        classType || (classType = class {
        });
        const s = new ClassSchema(classType);
        classType.prototype[exports.classSchemaSymbol] = s;
        s.name = this.name;
        s.name = this.name;
        s.collectionName = this.collectionName;
        s.databaseSchemaName = this.databaseSchemaName;
        s.decorator = this.decorator;
        s.discriminant = this.discriminant;
        s.fromClass = this.fromClass;
        s.singleTableInheritance = this.singleTableInheritance ? { ...this.singleTableInheritance } : undefined;
        s.subClasses = this.subClasses.slice();
        s.superClass = this.superClass;
        s.propertiesMap = new Map();
        s.properties = [];
        for (const [i, v] of this.propertiesMap) {
            const p = v.clone();
            s.propertiesMap.set(i, p);
            s.properties.push(p);
        }
        s.methodProperties = new Map();
        for (const [i, properties] of this.methodProperties.entries()) {
            const obj = [];
            for (const v of properties) {
                obj.push(s.propertiesMap.get(v.name) || v.clone());
            }
            s.methodProperties.set(i, obj);
        }
        s.propertyNames = this.propertyNames.slice(0);
        s.methodsParamNames = new Map();
        s.methodsParamNamesAutoResolved = new Map();
        for (const [m, p] of this.methodsParamNames.entries())
            s.methodsParamNames.set(m, p.slice(0));
        for (const [m, p] of this.methodsParamNamesAutoResolved.entries())
            s.methodsParamNamesAutoResolved.set(m, p.slice(0));
        s.indices = new Map;
        for (const [name, v] of this.indices.entries()) {
            s.indices.set(name, { ...v });
        }
        s.onLoad = [];
        for (const v of this.onLoad) {
            s.onLoad.push({ ...v });
        }
        return s;
    }
    /**
     * Adds dynamically new properties to the class schema definition.
     * Use the `f` decorator as you already do at the class directly.
     *
     * Note: Once a transform method is called like plainToClass/classToPlain etc
     * this method has no effect anymore since compiler templates are then already built.
     * So make sure to call this addProperty() before calling transform methods.
     *
     * @example
     * ```typescript
     * const schema = getClassSchema(MyClass);
     * //or
     * const schema = createClassSchema(MyClass);
     *
     * schema.addProperty('fieldName', f.string);
     * ```
     */
    addProperty(name, decorator) {
        //apply decorator, which adds properties automatically
        decorator(this.classType, name);
        this.resetCache();
    }
    removeProperty(name) {
        const property = this.propertiesMap.get(name);
        if (!property)
            return;
        this.propertiesMap.delete(name);
        core_1.arrayRemoveItem(this.properties, property);
        core_1.arrayRemoveItem(this.propertyNames, name);
    }
    registerProperty(property) {
        if (this.fromClass && !property.methodName) {
            property.hasDefaultValue = this.detectedDefaultValueProperties.includes(property.name);
            if (this.extractedDefaultValues[property.name]) {
                property.extractedDefaultValue = this.extractedDefaultValues[property.name];
            }
            if (!property.manuallySetToRequired && !property.hasDefaultValue && !this.assignedInConstructor.includes(property.name)) {
                //when we have no default value AND the property was never seen in the constructor, its
                //a optional one.
                property.isOptional = true;
            }
        }
        const constructorProperties = this.methodProperties.get('constructor');
        if (constructorProperties) {
            //during decorator calls it might be that `constructorProperties` is not completely populated
            for (let i = 0; i < constructorProperties.length; i++) {
                if (!constructorProperties[i])
                    continue;
                if (constructorProperties[i].name === property.name) {
                    constructorProperties[i] = property;
                }
            }
        }
        if (this.propertiesMap.has(property.name)) {
            core_1.arrayRemoveItem(this.properties, this.propertiesMap.get(property.name));
        }
        else {
            this.propertyNames.push(property.name);
        }
        this.propertiesMap.set(property.name, property);
        this.properties.push(property);
    }
    /**
     * Resets all cached data for this class schema.
     * This includes all JIT generated functions, like serializer, change detector, and validator functions.
     */
    resetCache() {
        this.jit = {};
        this.primaryKeys = undefined;
        this.autoIncrements = undefined;
        this.buildId++;
    }
    /**
     * Adds dynamically new properties to the class schema definition.
     * Use the `f` decorator as you already do at the class directly.
     *
     * Note: Once a transform method is called like plainToClass/classToPlain etc
     * this method has no effect anymore since compiler templates are then already built.
     * So make sure to call this addMethodProperty() before calling transform methods.
     *
     * @example
     * ```typescript
     * const schema = getClassSchema(MyClass);
     * //or
     * const schema = createClassSchema(MyClass);
     *
     * schema.addMethodProperty('constructor', 0, f.type(String));
     * schema.addMethodProperty('constructor', 1, f.type(String));
     *
     * schema.addMethodProperty('myMethod', 0, f.type(String));
     * ```
     */
    addMethodProperty(name, position, decorator) {
        decorator(this.classType, name, position);
        this.buildId++;
    }
    /**
     * Returns all annotated arguments as PropertSchema for given method name.
     */
    getMethodProperties(name) {
        this.initializeMethod(name);
        return this.methodProperties.get(name) || [];
    }
    getMethod(name) {
        this.initializeMethod(name);
        if (!this.methods[name]) {
            throw new Error(`Method ${name} not found on ${this.getClassName()}`);
        }
        return this.methods[name];
    }
    extractForeignKeyToPrimaryKey(property, item) {
        const primaryKey = {};
        const pks = this.getPrimaryFields();
        if (pks.length === 1) {
            primaryKey[pks[0].name] = item[property.name];
        }
        else {
            for (const pk of pks) {
                primaryKey[pk.name] = item[property.name + core_1.capitalize(pk.name)];
            }
        }
        return primaryKey;
    }
    extractPrimaryKey(item) {
        const primaryKey = {};
        for (const pk of this.getPrimaryFields()) {
            primaryKey[pk.name] = item[pk.name];
        }
        return primaryKey;
    }
    /**
     * Internal note: for multi pk support, this will be removed.
     */
    getPrimaryField() {
        const pks = this.getPrimaryFields();
        if (pks.length === 0) {
            throw new Error(`Class ${core_1.getClassName(this.classType)} has no primary field. Use @t.primary to define one.`);
        }
        if (pks.length > 1) {
            throw new Error(`Class ${core_1.getClassName(this.classType)} has multiple primary fields. This is not supported.`);
        }
        return pks[0];
    }
    hasCircularReference(stack = []) {
        if (stack.includes(this))
            return true;
        stack.push(this);
        for (const property of this.properties) {
            if (property.type === 'partial' && property.getSubType().type === 'class' && property.getSubType().getResolvedClassSchema().hasCircularReference(stack))
                return true;
            if (property.type === 'map' && property.getSubType().type === 'class' && property.getSubType().getResolvedClassSchema().hasCircularReference(stack))
                return true;
            if (property.type === 'array' && property.getSubType().type === 'class' && property.getSubType().getResolvedClassSchema().hasCircularReference(stack))
                return true;
            if (property.type === 'class' && property.getResolvedClassSchema().hasCircularReference(stack))
                return true;
        }
        stack.pop();
        return false;
    }
    getPrimaryFieldName() {
        return this.getPrimaryField().name;
    }
    getAutoIncrementField() {
        for (const property of this.properties) {
            if (property.isAutoIncrement)
                return property;
        }
        return;
    }
    hasPrimaryFields() {
        if (!this.primaryKeys)
            this.getPrimaryFields();
        return this.primaryKeys.length > 0;
    }
    getPrimaryFields() {
        if (this.primaryKeys)
            return this.primaryKeys;
        this.primaryKeys = [];
        for (const property of this.properties) {
            if (property.isId)
                this.primaryKeys.push(property);
        }
        return this.primaryKeys;
    }
    /**
     * Returns true if the method got a @f decorator.
     */
    hasMethod(name) {
        return !!this.methods[name];
    }
    registerReference(property) {
        this.references.add(property);
    }
    isSchemaOf(classTypeOrSchema) {
        const classSchema = getClassSchema(classTypeOrSchema);
        if (this === classSchema)
            return true;
        if (classSchema.classType) {
            let currentProto = Object.getPrototypeOf(this.classType.prototype);
            while (currentProto && currentProto !== Object.prototype) {
                if (getClassSchema(currentProto) === classSchema)
                    return true;
                currentProto = Object.getPrototypeOf(currentProto);
            }
        }
        return false;
    }
    exclude(...properties) {
        const cloned = this.clone();
        for (const name of properties)
            cloned.removeProperty(name);
        return cloned;
    }
    include(...properties) {
        const cloned = this.clone();
        for (const name of this.propertiesMap.keys()) {
            if (properties.includes(name))
                continue;
            cloned.removeProperty(name);
        }
        return cloned;
    }
    extend(props, options) {
        const cloned = this.clone();
        const schema = decorators_1.t.schema(props);
        for (const property of schema.properties) {
            cloned.registerProperty(property);
        }
        return cloned;
    }
    initializeMethod(name) {
        if (!this.initializedMethods.has(name)) {
            if (name !== 'constructor' && (!Reflect.getMetadata || !Reflect.hasMetadata('design:returntype', this.classType.prototype, name))) {
                throw new Error(`Method ${this.getClassPropertyName(name)} has no decorators used or is not defined, so reflection does not work. Use @t on the method or arguments. Is emitDecoratorMetadata enabled? Correctly 'reflect-metadata' imported? Return type annotated?`);
            }
            if (name !== 'constructor' && !this.methods[name]) {
                const returnType = Reflect.getMetadata && Reflect.getMetadata('design:returntype', this.classType.prototype, name);
                this.methods[name] = new PropertySchema(name);
                this.methods[name].setFromJSType(returnType);
                this.methods[name].typeSet = false;
            }
            const properties = this.getOrCreateMethodProperties(name);
            const paramtypes = name === 'constructor'
                ? Reflect.getMetadata && Reflect.getMetadata('design:paramtypes', this.classType)
                : Reflect.getMetadata && Reflect.getMetadata('design:paramtypes', this.classType.prototype, name);
            const names = core_1.extractParameters(this.classType.prototype[name]);
            for (const [i, t] of core_1.eachPair(paramtypes)) {
                if (!properties[i]) {
                    properties[i] = new PropertySchema(names[i] || String(i));
                    properties[i].methodName = name;
                    if (paramtypes[i] !== Object) {
                        properties[i].setFromJSType(t, false);
                        properties[i].typeSet = false;
                    }
                }
            }
            this.initializedMethods.add(name);
        }
    }
    /**
     * @internal
     */
    getOrCreateMethodProperties(name) {
        if (!this.methodProperties.has(name)) {
            this.methodProperties.set(name, []);
        }
        return this.methodProperties.get(name);
    }
    getProperties() {
        return this.properties;
    }
    getPropertiesMap() {
        return this.propertiesMap;
    }
    /**
     * @internal
     */
    getMethodsParamNames(methodName) {
        if (!this.methodsParamNames.has(methodName))
            this.methodsParamNames.set(methodName, []);
        return this.methodsParamNames.get(methodName);
    }
    /**
     * @internal
     */
    getMethodsParamNamesAutoResolved(methodName) {
        if (!this.methodsParamNamesAutoResolved.has(methodName))
            this.methodsParamNamesAutoResolved.set(methodName, []);
        return this.methodsParamNamesAutoResolved.get(methodName);
    }
    getDiscriminantPropertySchema() {
        if (!this.discriminant) {
            throw new Error(`No discriminant property found at class ${this.getClassName()}`);
        }
        return this.getProperty(this.discriminant);
    }
    getDecoratedPropertySchema() {
        if (!this.decorator) {
            throw new Error(`No decorated property found`);
        }
        return this.getProperty(this.decorator);
    }
    getIndex(name) {
        return this.indices.get(name);
    }
    getPropertyOrUndefined(name) {
        return this.propertiesMap.get(name);
    }
    hasProperty(name) {
        return this.propertiesMap.has(name);
    }
    // public isOneToOne(propertyName: string): boolean {
    //     const property = this.getProperty(propertyName);
    //     return property.isOwningReference() && property.isId;
    // }
    //
    // public isManyToOne(propertyName: string): boolean {
    //     const property = this.getProperty(propertyName);
    //     return property.isOwningReference() && !property.isId;
    // }
    //
    // public isOneToMany(propertyName: string): boolean {
    //     const property = this.getProperty(propertyName);
    //     return property.isBackReference() && !property.isId;
    // }
    //
    // public isManyToMany(propertyName: string): boolean {
    //     const property = this.getProperty(propertyName);
    //     if (property.isBackReference()) {
    //         const reverseRef = this.findReverseReference(property.getResolvedClassType(), property);
    //         return reverseRef.isArray;
    //     }
    //     return false;
    // }
    /**
     * All references have a counter-part. This methods finds it and errors if not possible.
     *
     * If the given reference is a owning reference it finds the correct backReference,
     *    which can be found by checking all reference options.mappedBy.
     *
     * If the given reference is a back reference it finds the owning reference,
     *    which can be found by using its options.mappedBy.
     *
     * Alternatively we simply check for resolvedClassType to be given `classType`, and if only one
     * found, we return it. When more than one found, we throw an error saying the user he
     * should make its relation mapping not ambiguous.
     */
    findReverseReference(toClassType, fromReference) {
        if (fromReference.backReference && fromReference.backReference.mappedBy) {
            if (fromReference.getResolvedClassTypeForValidType() === this.classType) {
                return this.getProperty(fromReference.backReference.mappedBy);
            }
        }
        const candidates = [];
        for (const backRef of this.references) {
            if (backRef === fromReference)
                continue;
            //backRef points to something completely different
            if (!backRef.isArray && backRef.getResolvedClassTypeForValidType() !== toClassType)
                continue;
            if (backRef.isArray && backRef.getSubType().getResolvedClassTypeForValidType() !== toClassType)
                continue;
            //we found the perfect match, manually annotated
            if (backRef.backReference && backRef.backReference.mappedBy) {
                if (backRef.backReference.mappedBy === fromReference.name) {
                    return backRef;
                }
                continue;
            }
            if (fromReference.backReference && fromReference.backReference.mappedBy && !fromReference.backReference.via) {
                if (fromReference.backReference.mappedBy === backRef.name) {
                    //perfect match
                    return backRef;
                }
                continue;
            }
            //add to candidates if possible
            if (fromReference.backReference && fromReference.backReference.via && backRef.backReference && backRef.backReference.via) {
                if (resolveClassTypeOrForward(fromReference.backReference.via) === resolveClassTypeOrForward(backRef.backReference.via)) {
                    candidates.push(backRef);
                }
                continue;
            }
            if (fromReference.backReference && fromReference.isArray && !fromReference.backReference.via) {
                //other side must be non-array
                if (backRef.isArray)
                    continue;
            }
            candidates.push(backRef);
        }
        if (candidates.length > 1) {
            throw new Error(`Class ${core_1.getClassName(this.classType)} has multiple potential reverse references [${candidates.map(v => v.name).join(', ')}] for ${fromReference.name} to class ${core_1.getClassName(toClassType)}. ` +
                `Please specify each back reference by using 'mappedBy', e.g. @t.backReference({mappedBy: 'fieldNameOnTheOtherSide'} so its not ambiguous anymore.`);
        }
        if (candidates.length === 1)
            return candidates[0];
        throw new Error(`Class ${core_1.getClassName(this.classType)} has no reference to class ${core_1.getClassName(toClassType)} defined.`);
    }
    getPropertiesByGroup(...groupNames) {
        const result = [];
        for (const property of this.properties) {
            for (const groupName of property.groupNames) {
                if (groupNames.includes(groupName)) {
                    result.push(property);
                    break;
                }
            }
        }
        return result;
    }
    getProperty(name) {
        const property = this.propertiesMap.get(name);
        if (!property) {
            throw new Error(`Property ${this.getClassName()}.${name} not found`);
        }
        return property;
    }
}
exports.ClassSchema = ClassSchema;
const deletedExcludedProperties = Symbol();
class ClassSlicer {
    constructor(schema) {
        this.schema = schema;
    }
    exclude(...properties) {
        for (const name of properties) {
            this.schema.removeProperty(name);
            this.schema.classType[deletedExcludedProperties].push(name);
        }
        return this.schema.classType;
    }
    include(...properties) {
        for (const property of this.schema.getProperties()) {
            if (properties.includes(property.name))
                continue;
            this.schema.removeProperty(property.name);
        }
        return this.schema.classType;
    }
    extend(props) {
        //this changes this.schema.classType directly
        decorators_1.t.schema(props, { classType: this.schema.classType });
        return this.schema.classType;
    }
}
exports.ClassSlicer = ClassSlicer;
function sliceClass(classType) {
    var _a;
    const base = classType instanceof ClassSchema ? classType.classType : classType;
    class Class extends base {
        constructor(...args) {
            super(...args);
            for (const prop of Class[deletedExcludedProperties]) {
                delete this[prop];
            }
        }
    }
    _a = deletedExcludedProperties;
    Class[_a] = [];
    Class[deletedExcludedProperties].push('nix');
    return new ClassSlicer(getClassSchema(base).clone(Class));
}
exports.sliceClass = sliceClass;
/**
 * Function to mixin multiple classes together and create a new class, which can be extended from.
 *
 * @example
 * ```typescript
 *
 *   class Timestampable {
 *       @t createdAt: Date = new Date;
 *       @t updatedAt: Date = new Date;
 *   }
 *
 *   class SoftDeleted {
 *       @t deletedAt?: Date;
 *       @t deletedBy?: string;
 *   }
 *
 *   class User extends mixin(Timestampable, SoftDeleted) {
 *       @t.primary.autoIncrement id: number = 0;
 *       @t.minLength(3).required public username!: string;
 *   }
 * ```
 */
function mixin(...classTypes) {
    const constructors = [];
    const schema = createClassSchema(class {
        constructor(...args) {
            for (const c of constructors) {
                c.call(this, ...args);
            }
        }
    });
    for (const classType of classTypes) {
        const foreignSchema = getClassSchema(classType);
        for (const i in foreignSchema.classType.prototype) {
            schema.classType.prototype[i] = foreignSchema.classType.prototype[i];
        }
        for (const prop of foreignSchema.getProperties()) {
            schema.registerProperty(prop.clone());
        }
        constructors.push(function (...args) {
            const item = new foreignSchema.classType(...args);
            for (const prop of foreignSchema.getProperties()) {
                this[prop.name] = item[prop.name];
            }
        });
    }
    return schema.classType;
}
exports.mixin = mixin;
/**
 * Returns true if there is a class annotated with @Entity(name).
 */
function hasClassSchemaByName(name) {
    return !!getGlobalStore().RegisteredEntities[name];
}
exports.hasClassSchemaByName = hasClassSchemaByName;
/**
 * Returns the ClassSchema for an class annotated with @Entity(name).
 * @throws Error if not exists
 */
function getClassSchemaByName(name) {
    if (!getGlobalStore().RegisteredEntities[name]) {
        throw new Error(`No deepkit/type class found with name '${name}'`);
    }
    return getClassSchema(getGlobalStore().RegisteredEntities[name]);
}
exports.getClassSchemaByName = getClassSchemaByName;
/**
 * Returns all names registered as @Entity() known to deepkit/type.
 */
function getKnownClassSchemasNames() {
    return Object.keys(getGlobalStore().RegisteredEntities);
}
exports.getKnownClassSchemasNames = getKnownClassSchemasNames;
exports.classSchemaSymbol = Symbol.for('deepkit/type/classSchema');
/**
 * @hidden
 */
function getOrCreateEntitySchema(target) {
    const proto = target['prototype'] ? target['prototype'] : target;
    const classType = target['prototype'] ? target : target.constructor;
    if (!proto.hasOwnProperty(exports.classSchemaSymbol)) {
        Object.defineProperty(proto, exports.classSchemaSymbol, { writable: true, enumerable: false });
    }
    if (!proto[exports.classSchemaSymbol]) {
        //check if parent has a EntitySchema, if so clone and use it as base.
        let currentProto = Object.getPrototypeOf(proto);
        let found = false;
        while (currentProto && currentProto !== Object.prototype) {
            // if (ClassSchemas.has(currentProto)) {
            if (currentProto[exports.classSchemaSymbol]) {
                found = true;
                const parent = currentProto[exports.classSchemaSymbol];
                const classSchema = parent.clone(classType);
                classSchema.subClasses = [];
                proto[exports.classSchemaSymbol] = classSchema;
                classSchema.superClass = parent;
                parent.subClasses.push(classSchema);
                break;
            }
            currentProto = Object.getPrototypeOf(currentProto);
        }
        if (!found) {
            proto[exports.classSchemaSymbol] = new ClassSchema(classType);
        }
    }
    return proto[exports.classSchemaSymbol];
}
exports.getOrCreateEntitySchema = getOrCreateEntitySchema;
function hasClassSchema(target) {
    const proto = target['prototype'] ? target['prototype'] : target;
    return proto.hasOwnProperty(exports.classSchemaSymbol);
}
exports.hasClassSchema = hasClassSchema;
/**
 * Returns meta information / schema about given entity class.
 */
function getClassSchema(classTypeIn) {
    if (classTypeIn instanceof ClassSchema)
        return classTypeIn;
    const classType = classTypeIn['prototype'] ? classTypeIn : classTypeIn.constructor;
    if (!classType.prototype.hasOwnProperty(exports.classSchemaSymbol)) {
        Object.defineProperty(classType.prototype, exports.classSchemaSymbol, { writable: true, enumerable: false });
    }
    if (!classType.prototype[exports.classSchemaSymbol]) {
        //check if parent has a ClassSchema, if so clone and use it as base.
        let currentProto = Object.getPrototypeOf(classType.prototype);
        let found = false;
        while (currentProto && currentProto !== Object.prototype) {
            if (currentProto[exports.classSchemaSymbol]) {
                found = true;
                const parent = currentProto[exports.classSchemaSymbol];
                const classSchema = parent.clone(classType);
                classSchema.subClasses = [];
                classType.prototype[exports.classSchemaSymbol] = classSchema;
                classSchema.superClass = parent;
                parent.subClasses.push(classSchema);
                break;
            }
            currentProto = Object.getPrototypeOf(currentProto);
        }
        if (!found) {
            classType.prototype[exports.classSchemaSymbol] = new ClassSchema(classType);
        }
    }
    return classType.prototype[exports.classSchemaSymbol];
}
exports.getClassSchema = getClassSchema;
/**
 * Creates a new ClassSchema for a given external class (you might have no write access to),
 * which can be used to transform data for the given class. You can dynamically add properties
 * and use then the external class as usual with plainToClass, classToPlain, etc.
 *
 * @example
 * ```typescript
 * class ExternalClass {
 *     id!: string;
 *     version!: number;
 *     lists!: number[];
 * }
 *
 * const schema = createClassSchema(ExternalClass);
 * schema.addProperty('id', f.type(String));
 * schema.addProperty('version', f.type(Number));
 * schema.addProperty('lists', f.array(Number));
 *
 * const obj = plainToClass(ExternalClass, {
 *     id: '23',
 *     version: 1,
 *     lists: [12, 23]
 * });
 * ```
 */
function createClassSchema(clazz, name = '') {
    const fromClass = clazz !== undefined;
    const c = clazz || class {
    };
    if (name) {
        Object.defineProperty(c, 'name', { value: name });
    }
    const classSchema = getOrCreateEntitySchema(c);
    classSchema.name = name;
    classSchema.fromClass = fromClass;
    return classSchema;
}
exports.createClassSchema = createClassSchema;
//# sourceMappingURL=model.js.map