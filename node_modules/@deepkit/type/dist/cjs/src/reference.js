"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createReferenceClass = exports.createReference = exports.referenceItemSymbol = exports.referenceSymbol = exports.markAsHydrated = exports.isReferenceHydrated = exports.getOrCreateReferenceItemInfo = exports.getReferenceItemInfo = exports.getReferenceInfo = exports.isReference = void 0;
const core_1 = require("@deepkit/core");
const model_1 = require("./model");
function isReference(obj) {
    return core_1.isObject(obj) && exports.referenceSymbol in obj;
}
exports.isReference = isReference;
function getReferenceInfo(obj) {
    return obj[exports.referenceSymbol];
}
exports.getReferenceInfo = getReferenceInfo;
function getReferenceItemInfo(obj) {
    return obj[exports.referenceItemSymbol];
}
exports.getReferenceItemInfo = getReferenceItemInfo;
function getOrCreateReferenceItemInfo(obj) {
    if (!obj[exports.referenceItemSymbol])
        obj[exports.referenceItemSymbol] = { hydrated: false };
    return obj[exports.referenceItemSymbol];
}
exports.getOrCreateReferenceItemInfo = getOrCreateReferenceItemInfo;
function isReferenceHydrated(obj) {
    if (!(exports.referenceItemSymbol in obj))
        return false;
    const info = getReferenceItemInfo(obj);
    return info ? info.hydrated : false;
}
exports.isReferenceHydrated = isReferenceHydrated;
function markAsHydrated(item) {
    getOrCreateReferenceItemInfo(item).hydrated = true;
}
exports.markAsHydrated = markAsHydrated;
exports.referenceSymbol = Symbol('reference');
exports.referenceItemSymbol = Symbol('reference/item');
function createReference(referenceClass, pk) {
    const args = [];
    const classSchema = model_1.getClassSchema(referenceClass);
    if (!(exports.referenceSymbol in referenceClass.prototype)) {
        referenceClass = createReferenceClass(classSchema);
    }
    for (const prop of classSchema.getMethodProperties('constructor')) {
        args.push(pk[prop.name]);
    }
    const old = model_1.getGlobalStore().unpopulatedCheck;
    model_1.getGlobalStore().unpopulatedCheck = model_1.UnpopulatedCheck.None;
    try {
        const ref = new referenceClass(...args);
        Object.assign(ref, pk);
        return ref;
    }
    finally {
        model_1.getGlobalStore().unpopulatedCheck = old;
    }
}
exports.createReference = createReference;
function createReferenceClass(classSchema) {
    const type = classSchema.classType;
    if (classSchema.data.referenceClass)
        return classSchema.data.referenceClass;
    const Reference = class extends type {
    };
    Object.defineProperty(Reference.prototype, exports.referenceSymbol, { value: { hydrator: undefined }, enumerable: false });
    Object.defineProperty(Reference.prototype, exports.referenceItemSymbol, { value: null, writable: true, enumerable: false });
    Object.defineProperty(Reference.prototype, model_1.classSchemaSymbol, { writable: true, enumerable: false, value: classSchema });
    Reference.buildId = classSchema.buildId;
    const globalStore = model_1.getGlobalStore();
    Object.defineProperty(Reference, 'name', {
        value: classSchema.getClassName() + 'Reference'
    });
    classSchema.data.referenceClass = Reference;
    for (const property of classSchema.getProperties()) {
        if (property.isId)
            continue;
        const message = property.isReference || property.backReference ?
            `Reference ${classSchema.getClassName()}.${property.name} was not loaded. Use joinWith(), useJoinWith(), etc to populate the reference.`
            :
                `Can not access ${classSchema.getClassName()}.${property.name} since class was not completely hydrated. Use 'await hydrate(item)' to completely load it.`;
        Object.defineProperty(Reference.prototype, property.name, {
            enumerable: false,
            configurable: true,
            get() {
                if (this.hasOwnProperty(property.symbol)) {
                    return this[property.symbol];
                }
                if (globalStore.unpopulatedCheck === model_1.UnpopulatedCheck.Throw) {
                    throw new Error(message);
                }
                if (globalStore.unpopulatedCheck === model_1.UnpopulatedCheck.ReturnSymbol) {
                    return model_1.unpopulatedSymbol;
                }
            },
            set(v) {
                if (globalStore.unpopulatedCheck === model_1.UnpopulatedCheck.None) {
                    //when this check is off, this item is being constructed
                    //so we ignore initial set operations
                    return;
                }
                // when we set value, we just accept it and treat all
                // properties accessors that don't throw the Error above as "updated"
                Object.defineProperty(this, property.symbol, {
                    enumerable: false,
                    writable: true,
                    value: v
                });
            }
        });
    }
    return Reference;
}
exports.createReferenceClass = createReferenceClass;
//# sourceMappingURL=reference.js.map