import { ClassSchema, PropertySchema } from './model';
import { TypeConverterCompiler } from './serializer-compiler';
import { ClassType } from '@deepkit/core';
import { JitConverterOptions } from './jit';
import { AnyEntity, ExtractClassType, PlainOrFullEntityFromClassTypeOrSchema } from './utils';
import { Types } from './types';
declare type CompilerTypes = Types | 'undefined' | 'null';
export declare class SerializerCompilers {
    serializer: Serializer;
    parent?: SerializerCompilers | undefined;
    compilers: Map<string, TypeConverterCompiler>;
    constructor(serializer: Serializer, parent?: SerializerCompilers | undefined);
    append(type: CompilerTypes, compiler: TypeConverterCompiler): void;
    prepend(type: CompilerTypes, compiler: TypeConverterCompiler): void;
    /**
     * Registers a new compiler template for a certain type in certain direction
     * (for example: plain to class or class to plain).
     *
     * Note: Don't handle isArray/isMap/isPartial or isOptional at `property` as those are already handled before
     * your compiler code is called. Focus on marshalling the given type as fast and clear as possible.
     * The value you can access via `accessor` is at this stage never undefined and never null.
     *
     * Note: When you come from `class` to x (fromClass.register) then values additionally are
     * guaranteed to have certain value types since the TS system enforces it.
     * If a user overwrites with `as any` its not our business to convert them implicitly.
     *
     * Warning: Context is shared across types, so make sure either your assigned names are unique or generate new variable
     * name using `reserveVariable`.
     *
     * INTERNAL WARNING: Coming from `plain` to `x` the property values usually come from user input which makes
     * it necessary to check the type and convert it if necessary. This is extremely important to not
     * introduce security issues. Serializing from plain to your target format is made by calling first jsonSerializer.deserialize()
     * and then yourSerializer.serialize() with the result, deepkit/type is fast enough to buy this convenience
     * (of not having to declare too many compiler templates).
     */
    register(type: CompilerTypes, compiler: TypeConverterCompiler): void;
    /**
     * Removes a compiler.
     */
    reset(type: CompilerTypes): void;
    /**
     * Sets a noop compiler, basically disabling serialization for this type.
     */
    noop(type: CompilerTypes): void;
    /**
     * Adds a compiler template all typed arrays (Uint8Array, ...) and ArrayBuffer.
     */
    registerForBinary(compiler: TypeConverterCompiler): void;
    fork(serializer: Serializer): SerializerCompilers;
    get(type: CompilerTypes): TypeConverterCompiler | undefined;
    has(type: CompilerTypes): boolean;
}
export declare class Serializer {
    readonly name: string;
    /**
     * Serializer compiler for serializing from the serializer format to the class instance. Used in .for().deserialize().
     */
    toClass: SerializerCompilers;
    /**
     * Serializer compiler for serializing from the class instance to the serializer format. Used in .for().serialize().
     */
    fromClass: SerializerCompilers;
    toClassSymbol: symbol;
    fromClassSymbol: symbol;
    partialToClassSymbol: symbol;
    partialFromClassSymbol: symbol;
    constructor(name: string);
    fork(name: string): ClassType<Serializer>;
    for<T extends ClassType | ClassSchema>(schemaOrType: T): ScopedSerializer<ClassSchema<ExtractClassType<T>>>;
    /**
     * Serializes given class instance value to the serializer format.
     */
    serializeProperty(property: PropertySchema, value: any): any;
    /**
     * Converts serialized value to class type.
     */
    deserializeProperty(property: PropertySchema, value: any): any;
    /**
     * Converts given serialized data to the class instance.
     */
    deserializeMethodResult(property: PropertySchema, value: any): any;
}
declare type FirstParameter<T> = T extends ((a: infer A) => any) ? A : never;
export declare class ScopedSerializer<T extends ClassSchema> {
    readonly serializer: Serializer;
    protected schema: T;
    protected _serialize?: (instance: ExtractClassType<T>, options?: JitConverterOptions) => any;
    protected _deserialize?: (data: any, options?: JitConverterOptions, parents?: any[]) => ExtractClassType<T>;
    protected _partialSerialize?: (instance: {
        [name: string]: any;
    }, options?: JitConverterOptions) => any;
    protected _partialDeserialize?: <P extends {
        [name: string]: any;
    }>(data: P, options?: JitConverterOptions) => Pick<ExtractClassType<T>, keyof P>;
    constructor(serializer: Serializer, schema: T);
    from<S extends Serializer, SC extends ReturnType<S['for']>>(serializer: S, ...args: Parameters<SC['deserialize']>): ReturnType<this['serialize']>;
    to<S extends Serializer, SC extends ReturnType<S['for']>>(serializer: S, ...args: Parameters<this['deserialize']>): ReturnType<SC['serialize']>;
    fromPartial<S extends Serializer, SC extends ReturnType<S['for']>>(serializer: S, a: FirstParameter<ReturnType<S['for']>['partialDeserialize']>, options?: JitConverterOptions): AnyEntity<Pick<ExtractClassType<T, never>, keyof FirstParameter<ReturnType<S["for"]>["partialDeserialize"]>>>;
    toPartial<S extends Serializer, SC extends ReturnType<S['for']>, A extends FirstParameter<this['partialDeserialize']>>(serializer: S, a: A): ReturnType<SC['partialSerialize']>;
    fromPatch<S extends Serializer>(serializer: S, a: FirstParameter<ReturnType<S['for']>['patchDeserialize']>, options?: JitConverterOptions): { [F_1 in keyof { [F in keyof FirstParameter<ReturnType<S["for"]>["patchDeserialize"]>]?: any; }]?: any; };
    toPatch<S extends Serializer, SC extends ReturnType<S['for']>>(serializer: S, ...args: Parameters<this['patchDeserialize']>): {
        [x: string]: any;
    };
    /**
     * Serializes given class instance to the serialization format.
     * -> class to serializer.
     */
    serialize(instance: ExtractClassType<T>, options?: JitConverterOptions): any;
    /**
     * Same as `deserialize` but with validation after creating the class instance.
     *
     * ```typescript
     * try {
     *     const entity = jsonSerializer.for(MyEntity).validatedDeserialize({field1: 'value'});
     *     entity instanceof MyEntity; //true
     * } catch (error) {
     *     if (error instanceof ValidationFailed) {
     *         //handle that case.
     *     }
     * }
     * ```
     * @throws ValidationFailed
     */
    validatedDeserialize(data: PlainOrFullEntityFromClassTypeOrSchema<T>, options?: JitConverterOptions): ExtractClassType<T>;
    /**
     * Converts given data in form of this serialization format to the target (default JS primitive/class) type.
     * -> serializer to class.
     */
    deserialize(data: PlainOrFullEntityFromClassTypeOrSchema<T>, options?: JitConverterOptions, parents?: any[]): ExtractClassType<T>;
    /**
     * Serialized one property value from class instance to serialization target.
     *
     * Property name is either a property name or a deep path (e.g. config.value)
     */
    serializeProperty(name: (keyof ExtractClassType<T> & string) | string, value: any): any;
    /**
     * Converts given data in form of this serialization format to the target (default JS primitive/class) type.
     *
     * Property name is either a property name or a deep path (e.g. config.value)
     */
    deserializeProperty(name: (keyof ExtractClassType<T> & string) | string, value: any): any;
    serializeMethodArgument(methodName: string, property: number, value: any): ReturnType<this['serializeProperty']>;
    deserializeMethodArgument(methodName: string, property: number, value: any): any;
    serializeMethodResult(methodName: string, value: any): ReturnType<this['serializeProperty']>;
    deserializeMethodResult(methodName: string, value: any): any;
    /**
     * Serialized a partial instance to the serialization format.
     */
    partialSerialize<R extends {
        [name: string]: any;
    }>(data: R, options?: JitConverterOptions): AnyEntity<R>;
    /**
     * Converts data in form of this serialization format to the same partial target (default JS primitive/class) type.
     */
    partialDeserialize<P extends {
        [name: string]: any;
    }>(data: P, options?: JitConverterOptions): Pick<ExtractClassType<T>, keyof P>;
    patchDeserialize<R extends {
        [name: string]: any;
    }>(partial: R, options?: JitConverterOptions): {
        [F in keyof R]?: any;
    };
    patchSerialize<T, R extends object>(partial: R, options?: JitConverterOptions): {
        [F in keyof R]?: any;
    };
}
export declare const emptySerializer: {
    /**
     * Serializer compiler for serializing from the serializer format to the class instance. Used in .for().deserialize().
     */
    toClass: SerializerCompilers;
    /**
     * Serializer compiler for serializing from the class instance to the serializer format. Used in .for().serialize().
     */
    fromClass: SerializerCompilers;
    toClassSymbol: symbol;
    fromClassSymbol: symbol;
    partialToClassSymbol: symbol;
    partialFromClassSymbol: symbol;
    readonly name: string;
    fork(name: string): ClassType<Serializer>;
    for<T extends ClassSchema<any> | ClassType<any>>(schemaOrType: T): ScopedSerializer<ClassSchema<ExtractClassType<T, never>>>;
    /**
     * Serializes given class instance value to the serializer format.
     */
    serializeProperty(property: PropertySchema, value: any): any;
    /**
     * Converts serialized value to class type.
     */
    deserializeProperty(property: PropertySchema, value: any): any;
    /**
     * Converts given serialized data to the class instance.
     */
    deserializeMethodResult(property: PropertySchema, value: any): any;
};
export {};
