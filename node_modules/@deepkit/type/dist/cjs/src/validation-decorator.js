"use strict";
/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validators = void 0;
const core_1 = require("@deepkit/core");
const jit_validation_1 = require("./jit-validation");
const validator_1 = __importDefault(require("validator"));
exports.validators = {
    pattern(regex) {
        return (value) => {
            if ('string' !== typeof value)
                return;
            if (regex.exec(value))
                return;
            throw new jit_validation_1.PropertyValidatorError('pattern', `Pattern ${regex.source} does not match`);
        };
    },
    alpha(locale = 'en-US') {
        return (value) => {
            if ('string' !== typeof value)
                return;
            if (validator_1.default.isAlpha(value, locale))
                return;
            throw new jit_validation_1.PropertyValidatorError('alpha', 'Not alpha');
        };
    },
    alphanumeric(locale = 'en-US') {
        return (value) => {
            if ('string' !== typeof value)
                return;
            if (validator_1.default.isAlphanumeric(value, locale))
                return;
            throw new jit_validation_1.PropertyValidatorError('alphanumeric', 'Not alphanumeric');
        };
    },
    ascii() {
        return (value) => {
            if ('string' !== typeof value)
                return;
            if (validator_1.default.isAscii(value))
                return;
            throw new jit_validation_1.PropertyValidatorError('ascii', 'Not ASCII');
        };
    },
    dataURI() {
        return (value) => {
            if ('string' !== typeof value)
                return;
            if (validator_1.default.isDataURI(value))
                return;
            throw new jit_validation_1.PropertyValidatorError('dataURI', 'Not a data URI');
        };
    },
    decimal(options) {
        return (value) => {
            if ('string' !== typeof value)
                return;
            if (validator_1.default.isDecimal(value, options))
                return;
            throw new jit_validation_1.PropertyValidatorError('decimal', 'Not a decimal');
        };
    },
    multipleOf(num) {
        return (value) => {
            if ('number' !== typeof value)
                return;
            if (value % num === 0)
                return;
            throw new jit_validation_1.PropertyValidatorError('multipleOf', 'Not a multiple of ' + num);
        };
    },
    minLength(length) {
        return (value) => {
            if ('string' !== typeof value && !core_1.isArray(value))
                return;
            if (value.length >= length)
                return;
            throw new jit_validation_1.PropertyValidatorError('minLength', 'Min length is ' + length);
        };
    },
    maxLength(length) {
        return (value) => {
            if ('string' !== typeof value && !core_1.isArray(value))
                return;
            if (value.length <= length)
                return;
            throw new jit_validation_1.PropertyValidatorError('maxLength', 'Max length is ' + length);
        };
    },
    includes(include) {
        return (value) => {
            if ('string' !== typeof value && !core_1.isArray(value))
                return;
            if (value.includes(include))
                return;
            throw new jit_validation_1.PropertyValidatorError('includes', `Needs to include '${include}'`);
        };
    },
    excludes(excludes) {
        return (value) => {
            if ('string' !== typeof value && !core_1.isArray(value))
                return;
            if (!value.includes(excludes))
                return;
            throw new jit_validation_1.PropertyValidatorError('excludes', `Needs to exclude '${excludes}'`);
        };
    },
    minimum(min) {
        return (value) => {
            if ('number' !== typeof value && 'bigint' !== typeof value)
                return;
            if (value < min)
                throw new jit_validation_1.PropertyValidatorError('minimum', 'Number needs to be greater than or equal to ' + min);
        };
    },
    exclusiveMinimum(min) {
        return (value) => {
            if ('number' !== typeof value && 'bigint' !== typeof value)
                return;
            if (value <= min)
                throw new jit_validation_1.PropertyValidatorError('minimum', 'Number needs to be greater than ' + min);
        };
    },
    maximum(max) {
        return (value) => {
            if ('number' !== typeof value && 'bigint' !== typeof value)
                return;
            if (value > max)
                throw new jit_validation_1.PropertyValidatorError('maximum', 'Number needs to be smaller than or equal to ' + max);
        };
    },
    exclusiveMaximum(max) {
        return (value) => {
            if ('number' !== typeof value && 'bigint' !== typeof value)
                return;
            if (value >= max)
                throw new jit_validation_1.PropertyValidatorError('maximum', 'Number needs to be smaller than ' + max);
        };
    },
    positive(includingZero = true) {
        return (value) => {
            if ('number' !== typeof value && 'bigint' !== typeof value)
                return;
            if (value > 0)
                return;
            if (includingZero && value === 0)
                return;
            throw new jit_validation_1.PropertyValidatorError('positive', 'Number needs to be positive');
        };
    },
    negative(includingZero = true) {
        return (value) => {
            if ('number' !== typeof value && 'bigint' !== typeof value)
                return;
            if (value < 0)
                return;
            if (includingZero && value === 0)
                return;
            throw new jit_validation_1.PropertyValidatorError('negative', 'Number needs to be negative');
        };
    },
};
//# sourceMappingURL=validation-decorator.js.map