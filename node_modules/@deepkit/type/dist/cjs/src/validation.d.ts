import { ClassType, CustomError } from '@deepkit/core';
import { ClassSchema } from './model';
import { ValidationFailedItem } from './jit-validation';
import { ExtractClassType, PlainOrFullEntityFromClassTypeOrSchema } from './utils';
/**
 *
 */
export declare class ValidationFailed extends CustomError {
    readonly errors: ValidationFailedItem[];
    constructor(errors: ValidationFailedItem[]);
    static from(errors: {
        path: string;
        message: string;
        code?: string;
    }[]): ValidationFailed;
}
/**
 * Validates a set of method arguments and returns the number of errors found.
 */
export declare function validateMethodArgs<T>(classType: ClassType<T>, methodName: string, args: any[]): ValidationFailedItem[];
/**
 * Validates a object or class instance and returns all errors.
 * Returns an empty array if not errors found and validation succeeded.
 *
 * Warning: If `item` is a plain object this does not check if `item` is exactly of type T, but if it can safely be
 * converted to one using plainToClass/deserialize. For example `t.string` allows numbers because it can be safely converted to string.
 *
 * @example
 * ```
 * validate(SimpleModel, {id: false});
 * ```
 */
export declare function validate<T extends ClassType | ClassSchema>(classType: T, item: PlainOrFullEntityFromClassTypeOrSchema<T>, path?: string): ValidationFailedItem[];
/**
 * Same as `validate` but as prepared JIT function.
 */
export declare function validateFactory<T extends ClassType | ClassSchema>(classType: T): (value: any, path?: string | undefined, errors?: ValidationFailedItem[] | undefined) => ValidationFailedItem[];
/**
 * A type guarded way of using deepkit/type.
 *
 * Note: Methods are not type guarded.
 *
 * Warning: If `item` is a plain object this does not check if `item` is exactly of type T, but if it can safely be
 * converted to one using plainToClass. For example `t.string` allows numbers because it can be safely converted to string.
 *
 * @example
 * ```
 * if (validates(SimpleMode, item)) {
 *     //data is now typeof SimpleMode
 * }
 * ```
 */
export declare function validates<T extends ClassType | ClassSchema>(classType: T, item: PlainOrFullEntityFromClassTypeOrSchema<T>): item is ExtractClassType<T>;
/**
 * A type guarded way of using deepkit/type as factory for faster access.
 *
 * Note: Methods are not type guarded.
 *
 * Warning: If `item` is a plain object this does not check if `item` is exactly of type T, but if it can safely be
 * converted to one using deserialize. For example `t.string` allows numbers because it can be safely converted to string.
 *
 * @example
 * ```
 * const simpleModelValidates = validatesFactory(SimpleMode);
 * if (simpleModelValidates(item)) {
 *     //item is now typeof SimpleMode
 * }
 * ```
 */
export declare function validatesFactory<T extends ClassType | ClassSchema>(classType: T): (item: PlainOrFullEntityFromClassTypeOrSchema<T>) => item is ExtractClassType<T>;
