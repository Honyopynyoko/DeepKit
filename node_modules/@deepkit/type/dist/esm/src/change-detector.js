/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { empty, getObjectKeysSize } from '@deepkit/core';
import { Changes, changeSetSymbol, ItemChanges } from './changes';
import { JitStack } from './jit';
import { reserveVariable } from './serializer-compiler';
import { getConverterForSnapshot } from './snapshot';
function genericEqualArray(a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        if (!genericEqual(a[i], b[i]))
            return false;
    }
    return true;
}
function genericEqualObject(a, b) {
    for (let i in a) {
        if (!a.hasOwnProperty(i))
            continue;
        if (!genericEqual(a[i], b[i]))
            return false;
    }
    //is there a faster way?
    for (let i in b) {
        if (!b.hasOwnProperty(i))
            continue;
        if (!genericEqual(a[i], b[i]))
            return false;
    }
    return true;
}
/**
 * This is a comparator function for the snapshots. They are either string, number, boolean, array, or objects.
 * No date, moment, or custom classes involved here.
 */
function genericEqual(a, b) {
    //is array, the fast way
    const aIsArray = a && 'string' !== typeof a && 'function' === a.slice && 'number' === typeof a.length;
    const bIsArray = b && 'string' !== typeof b && 'function' === b.slice && 'number' === typeof b.length;
    if (aIsArray)
        return bIsArray ? genericEqualArray(a, b) : false;
    if (bIsArray)
        return aIsArray ? genericEqualArray(a, b) : false;
    const aIsObject = 'object' === typeof a && a !== null;
    const bIsObject = 'object' === typeof b && b !== null;
    if (aIsObject)
        return bIsObject ? genericEqualObject(a, b) : false;
    if (aIsObject)
        return bIsObject ? genericEqualObject(a, b) : false;
    return a === b;
}
function createJITChangeDetectorForSnapshot(schema, jitStack = new JitStack()) {
    const context = new Map();
    const prepared = jitStack.prepare(schema);
    context.set('genericEqual', genericEqual);
    context.set('empty', empty);
    const props = [];
    function has(accessor) {
        return `(changeSet.$inc && '${accessor}' in changeSet.$inc) || (changeSet.$unset && '${accessor}' in changeSet.$unset)`;
    }
    function getComparator(property, last, current, accessor, changedName, onChanged, jitStack) {
        if (property.isArray) {
            const l = reserveVariable(context, 'l');
            return `
                if (!${has(changedName)}) {
                if (!${current} && !${last}) {

                } else if ((${current} && !${last}) || (!${current} && ${last})) {
                    changes.${changedName} = item.${changedName};
                    ${onChanged}
                } else if (${current}.length !== ${last}.length) {
                    changes.${changedName} = item.${changedName};
                    ${onChanged}
                } else {
                    let ${l} = ${last}.length;
                    ${onChanged ? '' : 'root:'}
                    while (${l}--) {
                         ${getComparator(property.getSubType(), `${last}[${l}]`, `${current}[${l}]`, `${accessor}[${l}]`, changedName, 'break root;', jitStack)}
                    }
                }
                }
            `;
        }
        else if (property.isMap || property.isPartial) {
            context.set('getObjectKeysSize', getObjectKeysSize);
            const i = reserveVariable(context, 'i');
            return `
                if (!${has(changedName)}) {
                if (!${current} && !${last}) {

                } else if ((${current} && !${last}) || (!${current} && ${last})) {
                    changes.${changedName} = item.${changedName};
                    ${onChanged}
                } else if (getObjectKeysSize(${current}) !== getObjectKeysSize(${last})) {
                    changes.${changedName} = item.${changedName};
                    ${onChanged}
                } else {
                    ${onChanged ? '' : 'root:'}
                    for (let ${i} in ${last}) {
                        if (!${last}.hasOwnProperty(${i})) continue;
                         ${getComparator(property.getSubType(), `${last}[${i}]`, `${current}[${i}]`, `${accessor}[${i}]`, changedName, 'break root;', jitStack)}
                    }
                }
                }
            `;
        }
        else if (property.type === 'class') {
            if (property.isReference) {
                const checks = [];
                for (const primaryField of property.getResolvedClassSchema().getPrimaryFields()) {
                    checks.push(`
                         ${getComparator(primaryField, `${last}.${primaryField.name}`, `${current}.${primaryField.name}`, `${accessor}.${primaryField.name}`, changedName, onChanged, jitStack)}
                    `);
                }
                return `
                if (!${has(changedName)}) {
                if (!${current} && !${last}) {

                } else if ((${current} && !${last}) || (!${current} && ${last})) {
                    changes.${changedName} = item.${changedName};
                    ${onChanged}
                } else {
                    ${checks.join('\n')}
                }
                }
            `;
            }
            const classSchema = property.getResolvedClassSchema();
            const jitChangeDetectorThis = reserveVariable(context, 'jitChangeDetector');
            context.set(jitChangeDetectorThis, jitStack.getOrCreate(classSchema, () => createJITChangeDetectorForSnapshot(classSchema, jitStack)));
            return `
                if (!${has(changedName)}) {
                    if (!${current} && !${last}) {

                    } else if ((${current} && !${last}) || (!${current} && ${last})) {
                        changes.${changedName} = item.${changedName};
                        ${onChanged}
                    } else {
                        const thisChanged = ${jitChangeDetectorThis}.fn(${last}, ${current}, ${accessor});
                        if (!empty(thisChanged)) {
                            changes.${changedName} = item.${changedName};
                            ${onChanged}
                        }
                    }
                }
            `;
        }
        else if (property.isBinary || property.type === 'any' || property.type === 'union') {
            return `
                if (!${has(changedName)}) {
                    if (!genericEqual(${last}, ${current})) {
                        changes.${changedName} = item.${changedName};
                        ${onChanged}
                    }
                }
            `;
        }
        else {
            //binary, date, boolean, etc are encoded as simple JSON objects (number, boolean, or string) primitives
            return `
            if (!${has(changedName)}) {
                if (${last} !== ${current}) {
                    changes.${changedName} = item.${changedName};
                    ${onChanged}
                }
            }
            `;
        }
    }
    for (const property of schema.getProperties()) {
        if (property.isParentReference)
            continue;
        if (property.backReference)
            continue;
        props.push(getComparator(property, `last.${property.name}`, `current.${property.name}`, 'item.' + property.name, property.name, '', jitStack));
    }
    context.set('changeSetSymbol', changeSetSymbol);
    context.set('ItemChanges', ItemChanges);
    const functionCode = `
        return function(last, current, item) {
            var changeSet = item[changeSetSymbol] || new ItemChanges(undefined, item);
            var changes = {};
            ${props.join('\n')}
            changeSet.mergeSet(changes);
            return changeSet.empty ? undefined : changeSet;
        }
        `;
    // console.log('functionCode', functionCode);
    try {
        const compiled = new Function(...context.keys(), functionCode);
        const fn = compiled(...context.values());
        prepared(fn);
        fn.buildId = schema.buildId;
        return fn;
    }
    catch (error) {
        console.log('functionCode', functionCode);
        throw error;
    }
}
const changeDetectorSymbol = Symbol('changeDetector');
export function getChangeDetector(classSchema) {
    return classSchema.getJit(changeDetectorSymbol, () => createJITChangeDetectorForSnapshot(classSchema));
}
export function buildChanges(classSchema, lastSnapshot, item) {
    const currentSnapshot = getConverterForSnapshot(classSchema)(item);
    return getChangeDetector(classSchema)(lastSnapshot, currentSnapshot, item) || new Changes();
}
//# sourceMappingURL=change-detector.js.map