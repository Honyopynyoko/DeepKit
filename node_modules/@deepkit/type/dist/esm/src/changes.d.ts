export declare type NumberFields<T> = {
    [K in keyof T]: T[K] extends number | bigint ? K : never;
}[keyof T];
export declare type Expression<T> = {
    [P in keyof T & string]?: string;
};
export declare type Partial<T> = {
    [P in keyof T & string]?: T[P];
};
export interface ChangesInterface<T> {
    $set?: Partial<T> | T;
    $unset?: {
        [path: string]: number;
    };
    $inc?: Partial<Pick<T, NumberFields<T>>>;
}
export declare class Changes<T> {
    $set?: Partial<T> | T;
    $unset?: {
        [path: string]: number;
    };
    $inc?: Partial<Pick<T, NumberFields<T>>>;
    empty: boolean;
    constructor(changes?: ChangesInterface<T>);
    clear(): void;
    getReturning(): string[];
    protected detectEmpty(): void;
    replaceSet($set: Partial<T> | T): void;
    mergeSet($set: Partial<T> | T): void;
    increase(property: NumberFields<T>, increase?: number): void;
    set(property: keyof T & string, value: any): void;
    unset(property: keyof T & string, unset?: boolean): void;
    has(name: keyof T & string): boolean;
}
export declare class ItemChanges<T> extends Changes<T> {
    protected item: T;
    constructor(changes: ChangesInterface<T> | undefined, item: T);
    increase(property: NumberFields<T>, increase?: number): void;
    set(property: keyof T & string, value: any): void;
    unset(property: keyof T & string, unset?: boolean): void;
}
export declare const changeSetSymbol: unique symbol;
export declare class AtomicChangeInstance<T> {
    protected object: any;
    readonly changeSet: Changes<T>;
    constructor(object: any);
    increase(property: NumberFields<T>, increase?: number): void;
}
export declare function atomicChange<T>(object: T): AtomicChangeInstance<T>;
