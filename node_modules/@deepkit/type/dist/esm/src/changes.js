/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { empty } from '@deepkit/core';
export class Changes {
    constructor(changes) {
        this.empty = true;
        if (changes) {
            this.$set = empty(changes.$set) ? undefined : changes.$set;
            this.$unset = empty(changes.$unset) ? undefined : changes.$unset;
            this.$inc = empty(changes.$inc) ? undefined : changes.$inc;
            this.detectEmpty();
        }
    }
    clear() {
        this.empty = true;
        this.$set = undefined;
        this.$unset = undefined;
        this.$inc = undefined;
    }
    getReturning() {
        const names = [];
        if (this.$inc) {
            for (const i in this.$inc)
                if (this.$inc.hasOwnProperty(i))
                    names.push(i);
        }
        return names;
    }
    detectEmpty() {
        this.empty = this.$set === undefined && this.$unset === undefined && this.$inc === undefined;
    }
    replaceSet($set) {
        this.$set = empty($set) ? undefined : $set;
        this.detectEmpty();
    }
    mergeSet($set) {
        if (empty($set))
            return;
        if (!this.$set)
            this.$set = {};
        for (const i in $set) {
            this.$set[i] = $set[i];
        }
        this.detectEmpty();
    }
    increase(property, increase = 1) {
        if (!this.$inc)
            this.$inc = {};
        this.$inc[property] = increase;
        this.empty = false;
    }
    set(property, value) {
        if (!this.$set)
            this.$set = {};
        this.$set[property] = value;
        this.empty = false;
    }
    unset(property, unset = true) {
        if (!this.$unset)
            this.$unset = {};
        this.$unset[property] = unset;
        this.empty = false;
    }
    has(name) {
        return Boolean((this.$set && name in this.$set) || (this.$unset && name in this.$unset) || (this.$inc && name in this.$inc));
    }
}
export class ItemChanges extends Changes {
    constructor(changes = {}, item) {
        super(changes);
        this.item = item;
    }
    increase(property, increase = 1) {
        super.increase(property, increase);
        this.item[property] += increase;
    }
    set(property, value) {
        super.set(property, value);
        this.item[property] = value;
    }
    unset(property, unset = true) {
        super.unset(property, unset);
        this.item[property] = undefined;
    }
}
export const changeSetSymbol = Symbol('changeSet');
export class AtomicChangeInstance {
    constructor(object) {
        this.object = object;
        this.changeSet = new Changes();
        this.changeSet.$inc = {};
        object[changeSetSymbol] = this.changeSet;
    }
    increase(property, increase = 1) {
        this.object[property] += increase;
        this.changeSet.$inc[property] = increase;
        this.changeSet.empty = false;
    }
}
export function atomicChange(object) {
    return new AtomicChangeInstance(object);
}
//# sourceMappingURL=changes.js.map