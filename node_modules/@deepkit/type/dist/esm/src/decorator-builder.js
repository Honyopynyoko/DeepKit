/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
export function createFluidDecorator(api, modifier, collapse, returnCollapse = false, fluidFunctionSymbol) {
    const fn = function (target, property, parameterIndexOrDescriptor) {
        const res = collapse(modifier, target, property, parameterIndexOrDescriptor);
        if (returnCollapse)
            return res;
    };
    const methods = [];
    Object.defineProperty(fn, '_methods', { value: methods });
    if (fluidFunctionSymbol)
        Object.defineProperty(fn, fluidFunctionSymbol, { value: true });
    let current = api;
    while (current.prototype) {
        let proto = current.prototype;
        for (const name of Object.getOwnPropertyNames(proto)) {
            if (name === 'constructor')
                continue;
            if (name === 'onDecorator')
                continue;
            const descriptor = Object.getOwnPropertyDescriptor(proto, name);
            methods.push(name);
            if (descriptor && descriptor.get) {
                //its a magic shizzle
                Object.defineProperty(fn, name, {
                    configurable: true,
                    enumerable: false,
                    get: () => {
                        return createFluidDecorator(api, [...modifier, { name }], collapse, returnCollapse, fluidFunctionSymbol);
                    }
                });
            }
            else {
                //regular method
                Object.defineProperty(fn, name, {
                    configurable: true,
                    enumerable: false,
                    get: () => {
                        return (...args) => {
                            return createFluidDecorator(api, [...modifier, { name, args }], collapse, returnCollapse, fluidFunctionSymbol);
                        };
                    }
                });
            }
        }
        //resolve parent
        current = Object.getPrototypeOf(current);
    }
    return fn;
}
export function mergeDecorator(...args) {
    const res = {};
    for (const arg of args) {
        for (const method of arg._methods) {
            Object.defineProperty(res, method, {
                get() {
                    return arg[method];
                }
            });
        }
    }
    return res;
}
export function createClassDecoratorContext(apiType) {
    const map = new Map();
    function collapse(modifier, target) {
        var _a;
        const api = (_a = map.get(target)) !== null && _a !== void 0 ? _a : new apiType(target);
        for (const fn of modifier) {
            if (fn.args) {
                api[fn.name].bind(api)(...fn.args);
            }
            else {
                //just call the getter
                api[fn.name];
            }
        }
        if (api.onDecorator)
            api.onDecorator(target);
        map.set(target, api);
    }
    const fn = createFluidDecorator(apiType, [], collapse);
    Object.defineProperty(fn, '_fetch', {
        configurable: true,
        enumerable: false,
        get: () => {
            return (target) => {
                const api = map.get(target);
                return api ? api.t : undefined;
            };
        }
    });
    return fn;
}
export function createPropertyDecoratorContext(apiType) {
    const targetMap = new Map();
    function collapse(modifier, target, property, parameterIndexOrDescriptor) {
        var _a;
        if (!property)
            throw new Error('Property decorators can only be used on class properties');
        target = target['constructor']; //property decorators get the prototype instead of the class.
        let map = targetMap.get(target);
        if (!map) {
            map = new Map();
            targetMap.set(target, map);
        }
        const secondIndex = ('number' === typeof parameterIndexOrDescriptor ? parameterIndexOrDescriptor : '');
        const index = property + '$$' + secondIndex;
        const api = (_a = map.get(index)) !== null && _a !== void 0 ? _a : new apiType(target, property);
        for (const fn of modifier) {
            if (fn.args) {
                api[fn.name].bind(api)(...fn.args);
            }
            else {
                //just call the getter
                api[fn.name];
            }
        }
        if (api.onDecorator)
            api.onDecorator(target, property, ('number' === typeof parameterIndexOrDescriptor ? parameterIndexOrDescriptor : undefined));
        map.set(index, api);
    }
    const fn = createFluidDecorator(apiType, [], collapse);
    Object.defineProperty(fn, '_fetch', {
        configurable: true,
        enumerable: false,
        get: () => {
            return (target, property, parameterIndexOrDescriptor) => {
                const map = targetMap.get(target);
                const secondIndex = ('number' === typeof parameterIndexOrDescriptor ? parameterIndexOrDescriptor : '');
                const index = property + '$$' + secondIndex;
                const api = map ? map.get(index) : undefined;
                return api ? api.t : undefined;
            };
        }
    });
    return fn;
}
export function createFreeDecoratorContext(apiType) {
    function collapse(modifier) {
        const api = new apiType;
        for (const fn of modifier) {
            if (fn.args) {
                api[fn.name].bind(api)(...fn.args);
            }
            else {
                //just call the getter
                api[fn.name];
            }
        }
        return api.t;
    }
    const fluidFunctionSymbol = Symbol('fluidFunctionSymbol');
    const fn = createFluidDecorator(apiType, [], collapse, true, fluidFunctionSymbol);
    Object.defineProperty(fn, '_fluidFunctionSymbol', {
        configurable: true,
        enumerable: false,
        value: fluidFunctionSymbol
    });
    return fn;
}
export function isDecoratorContext(context, fn) {
    const symbol = context._fluidFunctionSymbol;
    if (Object.getOwnPropertyDescriptor(fn, symbol))
        return true;
    return false;
}
//# sourceMappingURL=decorator-builder.js.map