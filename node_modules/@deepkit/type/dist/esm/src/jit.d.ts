import { ClassSchema, PropertySchema } from './model';
import { ClassType } from '@deepkit/core';
import { Serializer } from './serializer';
/**
 * This is used withing JIT functions.
 * @hidden
 */
export declare function findParent<T>(parents: any[], parentType: ClassType<T>): T | void;
/**
 * This resolves the PropertySchema for a property path.
 *
 * A property path can be a deep path, separated with dots. This function makes sure to return the
 * correct PropertySchema so that a correct compiler can be built to convert this type.
 */
export declare function resolvePropertySchema<T>(schema: ClassSchema<T>, propertyPath: string): PropertySchema;
export interface JitConverterOptions {
    /**
     * Which groups to include. If a property is not assigned to
     * a given group, it will be excluded.
     * Use an empty array to include only non-grouped properties.
     */
    groups?: string[];
    /**
     * Which groups to exclude. If a property is assigned to at least
     * one given group, it will be excluded. Basically the opposite of
     * `groups`, but you can combine both.
     * Use an empty array to exclude only non-grouped properties.
     */
    groupsExclude?: string[];
    /**
     * When target is class instance and a property has @ParentReference you can
     * pass instances so the reference can be resolved, for cases
     * where its impossible to resolve otherwise.
     */
    parents?: any[];
}
export declare function getPropertyClassToXFunction(property: PropertySchema, serializer: Serializer): (value: any, options?: JitConverterOptions) => any;
export declare function getPropertyXtoClassFunction(property: PropertySchema, serializer: Serializer): (value: any, parents?: any[], options?: JitConverterOptions) => any;
/**
 * Creates a new JIT compiled function to convert given property schema. Deep paths are not allowed.
 */
export declare function createPropertyClassToXFunction(property: PropertySchema, serializer: Serializer): (value: any, parents?: any[]) => any;
/**
 * Creates a new JIT compiled function to convert given property schema. Deep paths are not allowed.
 */
export declare function createPropertyXToClassFunction(property: PropertySchema, serializer: Serializer): (value: any, parents?: any[], options?: JitConverterOptions) => any;
export declare function getParentResolverJS<T>(schema: ClassSchema<T>, setter: string, property: PropertySchema, context: Map<string, any>): string;
export declare class ToClassState {
    onFullLoadCallbacks: (() => void)[];
}
export declare function createClassToXFunction<T>(schema: ClassSchema<T>, serializer: Serializer, jitStack?: JitStack): (instance: T, options?: JitConverterOptions) => any;
export declare function getClassToXFunction<T>(schema: ClassSchema<T>, serializer: Serializer, jitStack?: JitStack): (instance: T, options?: JitConverterOptions) => any;
export declare function getGeneratedJitFunctionFromClass(schema: ClassSchema, serializer: Serializer): any;
export declare function getJitFunctionXToClass(schema: ClassSchema, serializer: Serializer): any;
export declare class JitStackEntry {
}
/**
 * A tracker for generated jit functions. Necessary to detect and automatically resolves circular schemas.
 */
export declare class JitStack {
    protected stack?: Map<ClassSchema, {
        fn: Function | undefined;
    }>;
    protected schemaStack: ClassSchema[];
    getStack(): Map<ClassSchema<any>, {
        fn: Function | undefined;
    }>;
    has(schema: ClassSchema): boolean;
    get(schema: ClassSchema): {
        fn: Function | undefined;
    };
    getOrCreate(schema: ClassSchema, create: () => Function): {
        fn: Function | undefined;
    };
    get currentSchema(): ClassSchema | undefined;
    prepare(schema: ClassSchema): (fn: Function) => void;
}
export declare function createXToClassFunction<T>(schema: ClassSchema<T>, serializer: Serializer, jitStack?: JitStack): (data: any, options?: JitConverterOptions, parents?: any[], state?: ToClassState) => T;
export declare function getXToClassFunction<T>(schema: ClassSchema<T>, serializer: Serializer, jitStack?: JitStack): (data: any, options?: JitConverterOptions, parents?: any[], state?: ToClassState) => T;
export declare function getPartialXToClassFunction<T>(schema: ClassSchema<T>, serializer: Serializer): (data: any, options?: JitConverterOptions, parents?: any[]) => any;
export declare function getPartialClassToXFunction<T>(schema: ClassSchema<T>, serializer: Serializer): (data: any, options?: JitConverterOptions) => any;
export declare function createPartialXToClassFunction<T>(schema: ClassSchema<T>, serializer: Serializer): (data: any, options?: JitConverterOptions, parents?: any[]) => any;
export declare function createPartialClassToXFunction<T>(schema: ClassSchema<T>, serializer: Serializer): (data: any, options?: JitConverterOptions) => any;
