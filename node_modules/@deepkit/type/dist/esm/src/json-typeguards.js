/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { isValidEnumValue } from '@deepkit/core';
import { typedArrayNamesMap } from './types';
export const jsonTypeGuards = new Map();
export function registerJSONTypeGuard(type, factory) {
    jsonTypeGuards.set(type, factory);
}
registerJSONTypeGuard('class', (property) => {
    const schema = property.getResolvedClassSchema();
    if (schema.discriminant) {
        const discriminant = schema.getProperty(schema.discriminant);
        const discriminantValue = discriminant.type === 'literal' ? discriminant.literalValue : discriminant.getDefaultValue();
        if (discriminantValue === undefined) {
            throw new Error(`Discriminant ${schema.getClassPropertyName(discriminant.name)} has no default value.`);
        }
        return (v) => {
            return v && v[discriminant.name] === discriminantValue;
        };
    }
    //we need to figure out what could be the discriminant
    for (const property of schema.getProperties()) {
        if (property.type !== 'literal')
            continue;
        return (v) => {
            return v && v[property.name] === property.literalValue;
        };
    }
    throw new Error(`Type of property ${property.name} (${property.toString()}) has no discriminant or literal set. Could not discriminate the value.`);
});
registerJSONTypeGuard('string', (property) => {
    return (v) => {
        return 'string' === typeof v;
    };
});
registerJSONTypeGuard('enum', (property) => {
    return (v) => {
        return undefined !== v && !isValidEnumValue(property.resolveClassType, v, property.allowLabelsAsValue);
    };
});
registerJSONTypeGuard('objectId', (property) => {
    return (v) => {
        return 'string' === typeof v && v.length === 24;
    };
});
registerJSONTypeGuard('uuid', (property) => {
    return (v) => {
        return 'string' === typeof v && v.length === 36 && v[23] === '-' && v[19] === '-' && v[13] === '-' && v[8] === '-';
    };
});
registerJSONTypeGuard('arrayBuffer', (property) => {
    return (v) => {
        return v instanceof ArrayBuffer || (v && v['$type'] === 'binary');
    };
});
function typedArrayGuard(property) {
    return (v) => {
        return ArrayBuffer.isView(v) || (v && v['$type'] === 'binary');
    };
}
for (const name of typedArrayNamesMap.keys()) {
    registerJSONTypeGuard(name, typedArrayGuard);
}
const date = /^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}Z$/;
registerJSONTypeGuard('date', (property) => {
    return (v) => {
        return v instanceof Date || 'string' === typeof v && date.exec(v) !== null;
    };
});
registerJSONTypeGuard('any', (property) => {
    return (v) => {
        return true;
    };
});
registerJSONTypeGuard('union', (property) => {
    throw new Error('Union typechecking not implemented. Nested unions thus not supported yet.');
});
registerJSONTypeGuard('array', (property) => {
    return (v) => {
        return v && v.length !== undefined && 'string' !== typeof v || 'function' === typeof v.slice;
    };
});
registerJSONTypeGuard('map', (property) => {
    return (v) => {
        return v && 'object' === typeof v && 'function' !== typeof v.slice;
    };
});
registerJSONTypeGuard('patch', (property) => {
    return (v) => {
        return v && 'object' === typeof v && 'function' !== typeof v.slice;
    };
});
registerJSONTypeGuard('partial', (property) => {
    return (v) => {
        return v && 'object' === typeof v && 'function' !== typeof v.slice;
    };
});
registerJSONTypeGuard('number', (property) => {
    return (v) => {
        return 'number' === typeof v || ('string' === typeof v && !Number.isNaN(parseInt(v)));
    };
});
registerJSONTypeGuard('bigint', (property) => {
    return (v) => {
        return 'bigint' === typeof v || (v && v['$type'] === 'bigint');
    };
});
registerJSONTypeGuard('boolean', (property) => {
    return (v) => {
        return 'boolean' === typeof v || v === 1 || v === 0 || v === '1' || v === '2' || v === 'true' || v === 'false';
    };
});
registerJSONTypeGuard('literal', (property) => {
    if ('number' === typeof property.literalValue) {
        return (v) => {
            return 0 + v === property.literalValue;
        };
    }
    if ('string' === typeof property.literalValue) {
        return (v) => {
            return '' + v === property.literalValue;
        };
    }
    if (true === property.literalValue) {
        return (v) => {
            return v === 'true' || v === '1' || v === 1 || v === true;
        };
    }
    if (false === property.literalValue) {
        return (v) => {
            return v === 'false' || v === '0' || v === 0 || v === false;
        };
    }
    return (v) => {
        return v === property.literalValue;
    };
});
//# sourceMappingURL=json-typeguards.js.map