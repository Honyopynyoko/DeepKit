import { AbstractClassType, ClassType, ExtractClassType } from '@deepkit/core';
import { ExtractClassDefinition, PlainSchemaProps } from './decorators';
import { FieldDecoratorResult } from './field-decorator';
import { Types } from './types';
export declare function getSingleTableInheritanceTypeValue(classSchema: ClassSchema): any;
export declare enum UnpopulatedCheck {
    None = 0,
    Throw = 1,
    ReturnSymbol = 2
}
export interface GlobalStore {
    RegisteredEntities: {
        [name: string]: ClassType | ClassSchema;
    };
    unpopulatedCheck: UnpopulatedCheck;
    /**
     * Per default, @deepkit/types tries to detect forward-ref by checking the type in the metadata or given in @t.type(x) to be a function.
     * If so, we treat it as a forwardRef. This does not work for ES5 fake-classes, since everything there is a function.
     * Disable this feature flag to support IE11.
     */
    enableForwardRefDetection: boolean;
}
export declare function getGlobalStore(): GlobalStore;
export declare function resolveClassTypeOrForward(type: ClassType | ForwardRefFn<ClassType>): ClassType;
export declare type ReferenceActions = 'RESTRICT' | 'NO ACTION' | 'CASCADE' | 'SET NULL' | 'SET DEFAULT';
export interface BackReferenceOptions<T> {
    /**
     * Necessary for normalised many-to-many relations. This defines the class of the pivot table/collection.
     */
    via?: ClassType | ForwardRefFn<ClassType>;
    /**
     * A reference/backReference can define which reference on the other side
     * reference back. This is necessary when there are multiple outgoing references
     * to the same entity.
     */
    mappedBy?: keyof T & string;
}
export declare type IndexOptions = Partial<{
    size: number;
    unique: boolean;
    spatial: boolean;
    sparse: boolean;
    synchronize: boolean;
    fulltext: boolean;
    where: string;
}>;
export interface PropertySchemaSerialized {
    name: string;
    type: Types;
    literalValue?: string | number | boolean;
    extractedDefaultValue?: any;
    isDecorated?: true;
    isParentReference?: true;
    isOptional?: true;
    isId?: true;
    typeSet?: true;
    isDiscriminant?: true;
    allowLabelsAsValue?: true;
    methodName?: string;
    groupNames?: string[];
    defaultValue?: any;
    templateArgs?: PropertySchemaSerialized[];
    classType?: string;
    classTypeName?: string;
    noValidation?: boolean;
    isReference?: true;
    enum?: {
        [name: string]: any;
    };
    backReference?: {
        via?: string;
        mappedBy?: string;
    };
    autoIncrement?: true;
}
export interface PropertyValidator {
    /**
     * @throws PropertyValidatorError when validation invalid
     */
    validate<T>(value: any, property: PropertySchema, classType?: ClassType): void;
}
export declare function isPropertyValidator(object: any): object is ClassType<PropertyValidator>;
export declare type FieldTypes<T> = string | ClassType | ForwardRefFn<T>;
export declare type ForwardRefFn<T> = ForwardRef<T> | (() => T);
export declare class ForwardRef<T> {
    forwardRef: () => T;
    constructor(forwardRef: () => T);
}
export declare function forwardRef<T>(forwardRef: () => T): ForwardRef<T>;
export declare const unpopulatedSymbol: unique symbol;
/**
 * Returns the ClassType for a given instance.
 */
export declare function getClassTypeFromInstance<T>(target: T): ClassType<T>;
/**
 * Returns true when target is a class instance.
 */
export declare function isClassInstance(target: any): boolean;
/**
 * Returns true if given class has an @entity() or @t defined, and thus became
 * a deepkit/type entity.
 */
export declare function isRegisteredEntity<T>(classType: ClassType<T>): boolean;
/**
 * Represents a class property or method argument/return-type definition.
 */
export declare class PropertySchema {
    name: string;
    parent?: PropertySchema | undefined;
    /**
     * Returns true when user manually set a default value via PropertySchema/decorator.
     */
    hasManualDefaultValue(): boolean;
    hasCircularDependency(lookingFor: ClassSchema, classSchemaStack?: ClassSchema[], propertyStack?: PropertySchema[]): boolean;
    /**
     * Returns true when `undefined` or a missing value is allowed.
     * This is now only true when `optional` is set, but alos when type is `any`,
     * or when the property has an actual default value (then a undefined value sets the default value instead).
     */
    isUndefinedAllowed(): boolean;
    type: Types;
    literalValue?: string | number | boolean;
    /**
     * When the constructors sets a default value (for discriminants/literals), we try to extract the value.
     */
    extractedDefaultValue?: any;
    noValidation: boolean;
    /**
     * Object to store JIT function for this schema.
     */
    jit: any;
    get isArray(): boolean;
    get isMap(): boolean;
    get isPatch(): boolean;
    get isPartial(): boolean;
    get isTypedArray(): boolean;
    get isBinary(): boolean;
    groupNames: string[];
    isOptional: boolean;
    isNullable: boolean;
    /**
     * When the a property is defined as ! you have to manually use t.required.
     */
    manuallySetToRequired: boolean;
    isDiscriminant: boolean;
    allowLabelsAsValue: boolean;
    isParentReference: boolean;
    validators: ClassType<PropertyValidator>[];
    /**
     * Whether its a owning reference.
     */
    isReference: boolean;
    referenceOptions: {
        onDelete: ReferenceActions;
        onUpdate: ReferenceActions;
    };
    /**
     * When the constructor sets a default value.
     */
    hasDefaultValue: boolean;
    /**
     * The manual set default value. This is always a function, even if the user provided only a value.
     */
    defaultValue?: () => any;
    /**
     * In serializes that have a two-pass way to generate the data, here's the place to store the last
     * generated default value.
     */
    lastGeneratedDefaultValue?: any;
    templateArgs: PropertySchema[];
    /**
     * The getClassName() when the given classType is not registered using a @entity.name
     * Only used when PropertySchema.toJSON/PropertySchema.fromJSON operating on a classType that has no name.
     */
    classTypeName?: string;
    classType?: ClassType;
    /**
     * Whether its a back reference.
     */
    backReference?: BackReferenceOptions<any>;
    /**
     * Whether its a foreign key from a owning reference.
     */
    isReferenceKey: boolean;
    index?: IndexOptions;
    /**
     * Used in decorator to check whether type has been set manually using @t decorator.
     */
    typeSet: boolean;
    /**
     * Whether this property is decorated.
     */
    isDecorated: boolean;
    isId: boolean;
    isAutoIncrement: boolean;
    symbol: symbol;
    /**
     * Custom user data.
     */
    data: {
        [name: string]: any;
    };
    /**
     * When this property belongs to method as argument then this contains the name of the method.
     */
    methodName?: string;
    exclude?: 'all' | 'plain' | string;
    protected classTypeForwardRef?: ForwardRefFn<any>;
    protected classTypeResolved?: ClassType;
    description: string;
    /**
     * Transformer for serialization.
     */
    serialization: Map<string, (v: any) => any>;
    /**
     * Transformer for deserialization.
     */
    deserialization: Map<string, (v: any) => any>;
    constructor(name: string, parent?: PropertySchema | undefined);
    setType(type: Types): void;
    getDefaultValue(): any;
    toString(optionalAffix?: boolean): string;
    getSubType(): PropertySchema;
    setClassType(classType?: ClassType): void;
    toJSON(): PropertySchemaSerialized;
    static fromJSON(props: PropertySchemaSerialized, parent?: PropertySchema, throwForInvalidClassType?: boolean): PropertySchema;
    static getTypeFromJSType(type: any): Types;
    setFromJSValue(value: any): void;
    setFromJSType(type: any, detectForwardRef?: boolean): void;
    /**
     * Internal note: for multi pk support, this will return a string[] in the future.
     */
    getForeignKeyName(): string;
    getResolvedClassSchema(): ClassSchema;
    clone(): PropertySchema;
    getTemplateArg(position: number): PropertySchema | undefined;
    get resolveClassType(): ClassType | undefined;
    getResolvedClassTypeForValidType(): ClassType | undefined;
    isResolvedClassTypeIsDecorated(): boolean;
    getResolvedClassType(): ClassType;
}
export interface EntityIndex {
    fields: string[];
    options: IndexOptions;
}
export interface SingleTableInheritance {
    type?: string;
}
export declare class ClassSchema<T = any> {
    /**
     * The build id. When a property is added, this buildId changes, so JIT compiler knows when to refresh
     * its cache.
     */
    buildId: number;
    classType: ClassType<T>;
    name?: string;
    description?: string;
    collectionName?: string;
    databaseSchemaName?: string;
    /**
     * Whether the schema uses single-table inheritance in the database.
     * The actual collection name is then used from the parent class.
     */
    singleTableInheritance?: SingleTableInheritance;
    subClasses: ClassSchema[];
    superClass?: ClassSchema;
    /**
     * Name of the property which this class is decorating.
     * As soon as someone use this class, the actual value of this property is used to serialize.
     */
    decorator?: string;
    /**
     * Name of the property that is a discriminant of this class.
     * This is automatically set when at least one property has @t.discriminant.
     */
    discriminant?: string;
    /**
     * Each method can have its own PropertySchema definition for each argument, where map key = method name.
     */
    protected methodProperties: Map<string, PropertySchema[]>;
    methods: {
        [name: string]: PropertySchema;
    };
    /**
     * Object to store JIT function for this schema. This object is automatically cleared once the schema changes (added property for example).
     */
    jit: any;
    /**
     * Arbitrary data container to assign additional data to a schema.
     */
    data: {
        [key: string]: any;
    };
    symbol: symbol;
    /**
     * @internal
     */
    protected initializedMethods: Set<string>;
    protected propertiesMap: Map<string, PropertySchema>;
    protected properties: PropertySchema[];
    propertyNames: string[];
    protected methodsParamNames: Map<string, string[]>;
    protected methodsParamNamesAutoResolved: Map<string, string[]>;
    indices: Map<string, EntityIndex>;
    /**
     * Contains all references, owning reference and back references.
     */
    readonly references: Set<PropertySchema>;
    protected referenceInitialized: boolean;
    protected primaryKeys?: PropertySchema[];
    protected autoIncrements?: PropertySchema[];
    onLoad: {
        methodName: string;
        options: {
            fullLoad?: boolean;
        };
    }[];
    protected hasFullLoadHooksCheck: boolean;
    private detectedDefaultValueProperties;
    private assignedInConstructor;
    private extractedDefaultValues;
    /**
     * Whether this schema comes from an actual class (not t.schema);
     */
    fromClass: boolean;
    constructor(classType: ClassType);
    /**
     * Whether this schema annotated an actual custom class.
     */
    isCustomClass(): boolean;
    toString(): string;
    assignedSingleTableInheritanceSubClassesByIdentifier?: {
        [id: string]: ClassSchema;
    };
    getAssignedSingleTableInheritanceSubClassesByIdentifier(): {
        [id: string]: ClassSchema;
    } | undefined;
    hasSingleTableInheritanceSubClasses(): boolean;
    getSingleTableInheritanceDiscriminant(): PropertySchema;
    /**
     * To not force the user to always annotate `.optional` to properties that
     * are actually optional (properties with default values),
     * we automatically read the code of the constructor and check if properties
     * are actually optional. If we find an assignment, we assume it has a default value,
     * and set property.hasDefaultValue = true;
     */
    protected parseDefaults(): void;
    getCollectionName(): string;
    getClassPropertyName(name: string): string;
    getName(): string;
    getClassName(): string;
    getJit(symbol: symbol | string, generator: (classSchema: ClassSchema) => any): any;
    hasFullLoadHooks(): boolean;
    /**
     * Whether a (deep) property references this schema again. Some validation/serialization code
     * needs to add additional check to avoid an call stack overflow.
     */
    hasCircularDependency(lookingFor?: ClassSchema, stack?: ClassSchema[]): boolean;
    addIndex(fieldNames: (keyof T & string)[], name?: string, options?: IndexOptions): void;
    clone(classType?: ClassType): ClassSchema;
    /**
     * Adds dynamically new properties to the class schema definition.
     * Use the `f` decorator as you already do at the class directly.
     *
     * Note: Once a transform method is called like plainToClass/classToPlain etc
     * this method has no effect anymore since compiler templates are then already built.
     * So make sure to call this addProperty() before calling transform methods.
     *
     * @example
     * ```typescript
     * const schema = getClassSchema(MyClass);
     * //or
     * const schema = createClassSchema(MyClass);
     *
     * schema.addProperty('fieldName', f.string);
     * ```
     */
    addProperty(name: string, decorator: FieldDecoratorResult<any>): void;
    removeProperty(name: string): void;
    registerProperty(property: PropertySchema): void;
    /**
     * Resets all cached data for this class schema.
     * This includes all JIT generated functions, like serializer, change detector, and validator functions.
     */
    resetCache(): void;
    /**
     * Adds dynamically new properties to the class schema definition.
     * Use the `f` decorator as you already do at the class directly.
     *
     * Note: Once a transform method is called like plainToClass/classToPlain etc
     * this method has no effect anymore since compiler templates are then already built.
     * So make sure to call this addMethodProperty() before calling transform methods.
     *
     * @example
     * ```typescript
     * const schema = getClassSchema(MyClass);
     * //or
     * const schema = createClassSchema(MyClass);
     *
     * schema.addMethodProperty('constructor', 0, f.type(String));
     * schema.addMethodProperty('constructor', 1, f.type(String));
     *
     * schema.addMethodProperty('myMethod', 0, f.type(String));
     * ```
     */
    addMethodProperty(name: string, position: number, decorator: FieldDecoratorResult<any>): void;
    /**
     * Returns all annotated arguments as PropertSchema for given method name.
     */
    getMethodProperties(name: string): PropertySchema[];
    getMethod(name: string): PropertySchema;
    extractForeignKeyToPrimaryKey(property: PropertySchema, item: object): Partial<T>;
    extractPrimaryKey(item: object): Partial<T>;
    /**
     * Internal note: for multi pk support, this will be removed.
     */
    getPrimaryField(): PropertySchema;
    hasCircularReference(stack?: ClassSchema[]): boolean;
    getPrimaryFieldName(): keyof T & string;
    getAutoIncrementField(): PropertySchema | undefined;
    hasPrimaryFields(): boolean;
    getPrimaryFields(): PropertySchema[];
    /**
     * Returns true if the method got a @f decorator.
     */
    hasMethod(name: string): boolean;
    registerReference(property: PropertySchema): void;
    isSchemaOf(classTypeOrSchema: ClassType | ClassSchema): boolean;
    exclude<K extends (keyof T & string)[]>(...properties: K): ClassSchema<Omit<T, K[number]>>;
    include<K extends (keyof T & string)[]>(...properties: K): ClassSchema<Pick<T, K[number]>>;
    extend<E extends PlainSchemaProps>(props: E, options?: {
        name?: string;
        classType?: ClassType;
    }): ClassSchema<T & ExtractClassDefinition<E>>;
    protected initializeMethod(name: string): void;
    /**
     * @internal
     */
    getOrCreateMethodProperties(name: string): PropertySchema[];
    getProperties(): PropertySchema[];
    getPropertiesMap(): Map<string, PropertySchema>;
    /**
     * @internal
     */
    getMethodsParamNames(methodName: string): string[];
    /**
     * @internal
     */
    getMethodsParamNamesAutoResolved(methodName: string): string[];
    getDiscriminantPropertySchema(): PropertySchema;
    getDecoratedPropertySchema(): PropertySchema;
    getIndex(name: string): EntityIndex | undefined;
    getPropertyOrUndefined(name: string): PropertySchema | undefined;
    hasProperty(name: string): boolean;
    /**
     * All references have a counter-part. This methods finds it and errors if not possible.
     *
     * If the given reference is a owning reference it finds the correct backReference,
     *    which can be found by checking all reference options.mappedBy.
     *
     * If the given reference is a back reference it finds the owning reference,
     *    which can be found by using its options.mappedBy.
     *
     * Alternatively we simply check for resolvedClassType to be given `classType`, and if only one
     * found, we return it. When more than one found, we throw an error saying the user he
     * should make its relation mapping not ambiguous.
     */
    findReverseReference(toClassType: ClassType, fromReference: PropertySchema): PropertySchema;
    getPropertiesByGroup(...groupNames: string[]): PropertySchema[];
    getProperty(name: string): PropertySchema;
}
export declare class ClassSlicer<T> {
    protected schema: ClassSchema<T>;
    constructor(schema: ClassSchema<T>);
    exclude<K extends (keyof T & string)[]>(...properties: K): ClassType<Omit<T, K[number]>>;
    include<K extends (keyof T & string)[]>(...properties: K): ClassType<Pick<T, K[number]>>;
    extend<E extends PlainSchemaProps>(props: E): ClassType<T & ExtractClassDefinition<E>>;
}
export declare function sliceClass<T>(classType: ClassType<T> | ClassSchema<T>): ClassSlicer<T>;
declare type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
/**
 * Function to mixin multiple classes together and create a new class, which can be extended from.
 *
 * @example
 * ```typescript
 *
 *   class Timestampable {
 *       @t createdAt: Date = new Date;
 *       @t updatedAt: Date = new Date;
 *   }
 *
 *   class SoftDeleted {
 *       @t deletedAt?: Date;
 *       @t deletedBy?: string;
 *   }
 *
 *   class User extends mixin(Timestampable, SoftDeleted) {
 *       @t.primary.autoIncrement id: number = 0;
 *       @t.minLength(3).required public username!: string;
 *   }
 * ```
 */
export declare function mixin<T extends (ClassSchema | ClassType)[]>(...classTypes: T): ClassType<UnionToIntersection<ExtractClassType<T[number]>>>;
/**
 * Returns true if there is a class annotated with @Entity(name).
 */
export declare function hasClassSchemaByName(name: string): boolean;
/**
 * Returns the ClassSchema for an class annotated with @Entity(name).
 * @throws Error if not exists
 */
export declare function getClassSchemaByName<T = object>(name: string): ClassSchema<T>;
/**
 * Returns all names registered as @Entity() known to deepkit/type.
 */
export declare function getKnownClassSchemasNames(): string[];
export declare const classSchemaSymbol: unique symbol;
/**
 * @hidden
 */
export declare function getOrCreateEntitySchema<T>(target: object | AbstractClassType<T> | any): ClassSchema;
export declare function hasClassSchema(target: object | ClassType | any): boolean;
/**
 * Returns meta information / schema about given entity class.
 */
export declare function getClassSchema<T>(classTypeIn: AbstractClassType<T> | Object | ClassSchema): ClassSchema<T>;
/**
 * Creates a new ClassSchema for a given external class (you might have no write access to),
 * which can be used to transform data for the given class. You can dynamically add properties
 * and use then the external class as usual with plainToClass, classToPlain, etc.
 *
 * @example
 * ```typescript
 * class ExternalClass {
 *     id!: string;
 *     version!: number;
 *     lists!: number[];
 * }
 *
 * const schema = createClassSchema(ExternalClass);
 * schema.addProperty('id', f.type(String));
 * schema.addProperty('version', f.type(Number));
 * schema.addProperty('lists', f.array(Number));
 *
 * const obj = plainToClass(ExternalClass, {
 *     id: '23',
 *     version: 1,
 *     lists: [12, 23]
 * });
 * ```
 */
export declare function createClassSchema<T = any>(clazz?: ClassType<T>, name?: string): ClassSchema<T>;
export {};
