/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { isObject } from '@deepkit/core';
import { classSchemaSymbol, getClassSchema, getGlobalStore, UnpopulatedCheck, unpopulatedSymbol } from './model';
export function isReference(obj) {
    return isObject(obj) && referenceSymbol in obj;
}
export function getReferenceInfo(obj) {
    return obj[referenceSymbol];
}
export function getReferenceItemInfo(obj) {
    return obj[referenceItemSymbol];
}
export function getOrCreateReferenceItemInfo(obj) {
    if (!obj[referenceItemSymbol])
        obj[referenceItemSymbol] = { hydrated: false };
    return obj[referenceItemSymbol];
}
export function isReferenceHydrated(obj) {
    if (!(referenceItemSymbol in obj))
        return false;
    const info = getReferenceItemInfo(obj);
    return info ? info.hydrated : false;
}
export function markAsHydrated(item) {
    getOrCreateReferenceItemInfo(item).hydrated = true;
}
export const referenceSymbol = Symbol('reference');
export const referenceItemSymbol = Symbol('reference/item');
export function createReference(referenceClass, pk) {
    const args = [];
    const classSchema = getClassSchema(referenceClass);
    if (!(referenceSymbol in referenceClass.prototype)) {
        referenceClass = createReferenceClass(classSchema);
    }
    for (const prop of classSchema.getMethodProperties('constructor')) {
        args.push(pk[prop.name]);
    }
    const old = getGlobalStore().unpopulatedCheck;
    getGlobalStore().unpopulatedCheck = UnpopulatedCheck.None;
    try {
        const ref = new referenceClass(...args);
        Object.assign(ref, pk);
        return ref;
    }
    finally {
        getGlobalStore().unpopulatedCheck = old;
    }
}
export function createReferenceClass(classSchema) {
    const type = classSchema.classType;
    if (classSchema.data.referenceClass)
        return classSchema.data.referenceClass;
    const Reference = class extends type {
    };
    Object.defineProperty(Reference.prototype, referenceSymbol, { value: { hydrator: undefined }, enumerable: false });
    Object.defineProperty(Reference.prototype, referenceItemSymbol, { value: null, writable: true, enumerable: false });
    Object.defineProperty(Reference.prototype, classSchemaSymbol, { writable: true, enumerable: false, value: classSchema });
    Reference.buildId = classSchema.buildId;
    const globalStore = getGlobalStore();
    Object.defineProperty(Reference, 'name', {
        value: classSchema.getClassName() + 'Reference'
    });
    classSchema.data.referenceClass = Reference;
    for (const property of classSchema.getProperties()) {
        if (property.isId)
            continue;
        const message = property.isReference || property.backReference ?
            `Reference ${classSchema.getClassName()}.${property.name} was not loaded. Use joinWith(), useJoinWith(), etc to populate the reference.`
            :
                `Can not access ${classSchema.getClassName()}.${property.name} since class was not completely hydrated. Use 'await hydrate(item)' to completely load it.`;
        Object.defineProperty(Reference.prototype, property.name, {
            enumerable: false,
            configurable: true,
            get() {
                if (this.hasOwnProperty(property.symbol)) {
                    return this[property.symbol];
                }
                if (globalStore.unpopulatedCheck === UnpopulatedCheck.Throw) {
                    throw new Error(message);
                }
                if (globalStore.unpopulatedCheck === UnpopulatedCheck.ReturnSymbol) {
                    return unpopulatedSymbol;
                }
            },
            set(v) {
                if (globalStore.unpopulatedCheck === UnpopulatedCheck.None) {
                    //when this check is off, this item is being constructed
                    //so we ignore initial set operations
                    return;
                }
                // when we set value, we just accept it and treat all
                // properties accessors that don't throw the Error above as "updated"
                Object.defineProperty(this, property.symbol, {
                    enumerable: false,
                    writable: true,
                    value: v
                });
            }
        });
    }
    return Reference;
}
//# sourceMappingURL=reference.js.map