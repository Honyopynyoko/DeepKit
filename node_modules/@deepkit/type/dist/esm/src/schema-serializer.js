import { t } from './decorators';
import { createClassSchema, getGlobalStore, PropertySchema } from './model';
import { propertyDefinition } from './model-schema';
export const serializedSchemaDefinition = t.schema({
    name: t.string.optional,
    embeddedName: t.string.optional,
    className: t.string,
    collectionName: t.string.optional,
    properties: t.array(propertyDefinition),
});
export function deserializeSchemas(schemas, registryPrefix) {
    const result = [];
    function fixRelation(property) {
        if (property.type === 'class') {
            if (!property.classType) {
                console.log('Property has invalid classType value', property);
            }
            property.classType = registryPrefix + property.classType;
        }
        if (property.backReference && property.backReference.via) {
            property.backReference.via = registryPrefix + property.backReference.via;
        }
        if (property.templateArgs)
            for (const p of Object.values(property.templateArgs))
                fixRelation(p);
    }
    const entities = getGlobalStore().RegisteredEntities;
    for (const entity of schemas) {
        for (const property of Object.values(entity.properties))
            fixRelation(property);
    }
    for (const entity of schemas) {
        const schema = createClassSchema();
        Object.defineProperty(schema.classType, 'name', { value: entity.className });
        schema.name = entity.name || entity.embeddedName;
        schema.collectionName = entity.collectionName;
        result.push(schema);
        entities[registryPrefix + (entity.embeddedName || entity.name)] = schema;
    }
    for (let i = 0; i < result.length; i++) {
        for (const property of Object.values(schemas[i].properties)) {
            result[i].registerProperty(PropertySchema.fromJSON(property));
        }
    }
    return result;
}
export function serializeSchemas(schemas) {
    const result = [];
    const embeddedName = new Map();
    let nameId = 0;
    function fixProperty(property, json) {
        if (json.type === 'class') {
            if (!json.classType) {
                let name = embeddedName.get(property.getResolvedClassType());
                if (!name) {
                    //this embedded is not known yet, we register and assign a random number
                    // embedded.set(property.getResolvedClassType(), property.getResolvedClassSchema());
                    name = '@:embedded/' + (++nameId);
                    embeddedName.set(property.getResolvedClassType(), name);
                    registerClassSchema(property.getResolvedClassSchema(), name);
                }
                json.classType = name;
            }
        }
        if (json.templateArgs) {
            for (let i = 0; i < property.templateArgs.length; i++) {
                fixProperty(property.templateArgs[i], json.templateArgs[i]);
            }
        }
    }
    function registerClassSchema(schema, embeddedName) {
        const properties = [...schema.getProperties()].map(v => serializeProperty(v));
        const serializedSchema = {
            name: schema.name,
            embeddedName,
            className: schema.getClassName(),
            collectionName: schema.collectionName,
            properties,
        };
        result.push(serializedSchema);
    }
    function serializeProperty(property) {
        const json = property.toJSON();
        fixProperty(property, json);
        if (json.templateArgs) {
            for (let i = 0; i < property.templateArgs.length; i++) {
                fixProperty(property.templateArgs[i], json.templateArgs[i]);
            }
        }
        return json;
    }
    for (const schema of schemas) {
        registerClassSchema(schema);
    }
    return result;
}
//# sourceMappingURL=schema-serializer.js.map