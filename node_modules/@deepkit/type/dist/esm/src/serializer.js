/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { getClassSchema } from './model';
import { getClassToXFunction, getPartialClassToXFunction, getPartialXToClassFunction, getPropertyClassToXFunction, getPropertyXtoClassFunction, getXToClassFunction, resolvePropertySchema } from './jit';
import { validate, ValidationFailed } from './validation';
import { binaryTypes } from './types';
export class SerializerCompilers {
    constructor(serializer, parent) {
        this.serializer = serializer;
        this.parent = parent;
        this.compilers = new Map();
    }
    append(type, compiler) {
        const old = this.get(type);
        this.compilers.set(type, (property, compilerState) => {
            var _a;
            if (compilerState.ended)
                return;
            if (old) {
                old(property, compilerState);
                if (compilerState.ended)
                    return;
                compiler(property, compilerState);
                return;
            }
            const parent = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.get(type);
            if (parent) {
                parent(property, compilerState);
                if (compilerState.ended)
                    return;
                compiler(property, compilerState);
            }
            else {
                if (compilerState.ended)
                    return;
                compiler(property, compilerState);
                return;
            }
        });
    }
    prepend(type, compiler) {
        const old = this.get(type);
        this.compilers.set(type, (property, compilerState) => {
            var _a;
            compiler(property, compilerState);
            if (compilerState.ended)
                return;
            if (old) {
                old(property, compilerState);
                return;
            }
            const parent = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.get(type);
            if (!parent) {
                if (compilerState.ended)
                    return;
                compiler(property, compilerState);
                return;
            }
            parent(property, compilerState);
        });
    }
    /**
     * Registers a new compiler template for a certain type in certain direction
     * (for example: plain to class or class to plain).
     *
     * Note: Don't handle isArray/isMap/isPartial or isOptional at `property` as those are already handled before
     * your compiler code is called. Focus on marshalling the given type as fast and clear as possible.
     * The value you can access via `accessor` is at this stage never undefined and never null.
     *
     * Note: When you come from `class` to x (fromClass.register) then values additionally are
     * guaranteed to have certain value types since the TS system enforces it.
     * If a user overwrites with `as any` its not our business to convert them implicitly.
     *
     * Warning: Context is shared across types, so make sure either your assigned names are unique or generate new variable
     * name using `reserveVariable`.
     *
     * INTERNAL WARNING: Coming from `plain` to `x` the property values usually come from user input which makes
     * it necessary to check the type and convert it if necessary. This is extremely important to not
     * introduce security issues. Serializing from plain to your target format is made by calling first jsonSerializer.deserialize()
     * and then yourSerializer.serialize() with the result, deepkit/type is fast enough to buy this convenience
     * (of not having to declare too many compiler templates).
     */
    register(type, compiler) {
        this.compilers.set(type, compiler);
    }
    /**
     * Removes a compiler.
     */
    reset(type) {
        this.compilers.delete(type);
    }
    /**
     * Sets a noop compiler, basically disabling serialization for this type.
     */
    noop(type) {
        this.compilers.set(type, (property, state) => {
            state.addSetter(`${state.accessor}`);
        });
    }
    /**
     * Adds a compiler template all typed arrays (Uint8Array, ...) and ArrayBuffer.
     */
    registerForBinary(compiler) {
        for (const type of binaryTypes)
            this.register(type, compiler);
    }
    fork(serializer) {
        return new SerializerCompilers(serializer, this);
    }
    get(type) {
        const t = this.compilers.get(type);
        if (t)
            return t;
        return this.parent ? this.parent.get(type) : undefined;
    }
    has(type) {
        if (this.compilers.has(type))
            return true;
        return this.parent ? this.parent.has(type) : false;
    }
}
export class Serializer {
    constructor(name) {
        this.name = name;
        /**
         * Serializer compiler for serializing from the serializer format to the class instance. Used in .for().deserialize().
         */
        this.toClass = new SerializerCompilers(this);
        /**
         * Serializer compiler for serializing from the class instance to the serializer format. Used in .for().serialize().
         */
        this.fromClass = new SerializerCompilers(this);
        this.toClassSymbol = Symbol('toClass-' + name);
        this.fromClassSymbol = Symbol('fromClass-' + name);
        this.partialToClassSymbol = Symbol('partialToClass-' + name);
        this.partialFromClassSymbol = Symbol('partialFromClass-' + name);
    }
    fork(name) {
        const self = this;
        class Res extends Serializer {
            constructor() {
                super(name);
                this.toClass = self.toClass.fork(this);
                this.fromClass = self.fromClass.fork(this);
            }
        }
        return Res;
    }
    for(schemaOrType) {
        return new ScopedSerializer(this, getClassSchema(schemaOrType));
    }
    /**
     * Serializes given class instance value to the serializer format.
     */
    serializeProperty(property, value) {
        return getPropertyClassToXFunction(property, this)(value);
    }
    /**
     * Converts serialized value to class type.
     */
    deserializeProperty(property, value) {
        return getPropertyXtoClassFunction(property, this)(value);
    }
    /**
     * Converts given serialized data to the class instance.
     */
    deserializeMethodResult(property, value) {
        return getPropertyXtoClassFunction(property, this)(value);
    }
}
export class ScopedSerializer {
    constructor(serializer, schema) {
        this.serializer = serializer;
        this.schema = schema;
        this._serialize = undefined;
        this._deserialize = undefined;
        this._partialSerialize = undefined;
        this._partialDeserialize = undefined;
    }
    from(serializer, ...args) {
        return this.serialize(serializer.for(this.schema).deserialize(...args));
    }
    to(serializer, ...args) {
        return serializer.for(this.schema).serialize(this.deserialize(...args));
    }
    fromPartial(serializer, a, options) {
        return this.partialSerialize(serializer.for(this.schema).partialDeserialize(a, options));
    }
    toPartial(serializer, a) {
        return serializer.for(this.schema).partialSerialize(this.partialDeserialize(a));
    }
    fromPatch(serializer, a, options) {
        return this.patchSerialize(serializer.for(this.schema).patchDeserialize(a, options));
    }
    toPatch(serializer, ...args) {
        return serializer.for(this.schema).patchSerialize(this.patchDeserialize(...args));
    }
    /**
     * Serializes given class instance to the serialization format.
     * -> class to serializer.
     */
    serialize(instance, options) {
        if (!this._serialize)
            this._serialize = getClassToXFunction(this.schema, this.serializer);
        return this._serialize(instance, options);
    }
    /**
     * Same as `deserialize` but with validation after creating the class instance.
     *
     * ```typescript
     * try {
     *     const entity = jsonSerializer.for(MyEntity).validatedDeserialize({field1: 'value'});
     *     entity instanceof MyEntity; //true
     * } catch (error) {
     *     if (error instanceof ValidationFailed) {
     *         //handle that case.
     *     }
     * }
     * ```
     * @throws ValidationFailed
     */
    validatedDeserialize(data, options) {
        if (!this._deserialize)
            this._deserialize = getXToClassFunction(this.schema, this.serializer);
        const item = this._deserialize(data, options);
        const errors = validate(this.schema, item);
        if (errors.length)
            throw new ValidationFailed(errors);
        return item;
    }
    /**
     * Converts given data in form of this serialization format to the target (default JS primitive/class) type.
     * -> serializer to class.
     */
    deserialize(data, options, parents) {
        if (!this._deserialize)
            this._deserialize = getXToClassFunction(this.schema, this.serializer);
        return this._deserialize(data, options, parents);
    }
    /**
     * Serialized one property value from class instance to serialization target.
     *
     * Property name is either a property name or a deep path (e.g. config.value)
     */
    serializeProperty(name, value) {
        var _a;
        const property = (_a = this.schema.getPropertiesMap().get(name)) !== null && _a !== void 0 ? _a : resolvePropertySchema(this.schema, name);
        return getPropertyClassToXFunction(property, this.serializer)(value);
    }
    /**
     * Converts given data in form of this serialization format to the target (default JS primitive/class) type.
     *
     * Property name is either a property name or a deep path (e.g. config.value)
     */
    deserializeProperty(name, value) {
        var _a;
        const property = (_a = this.schema.getPropertiesMap().get(name)) !== null && _a !== void 0 ? _a : resolvePropertySchema(this.schema, name);
        return getPropertyXtoClassFunction(property, this.serializer)(value);
    }
    serializeMethodArgument(methodName, property, value) {
        return getPropertyClassToXFunction(this.schema.getMethodProperties(methodName)[property], this.serializer)(value);
    }
    deserializeMethodArgument(methodName, property, value) {
        return getPropertyXtoClassFunction(this.schema.getMethodProperties(methodName)[property], this.serializer)(value);
    }
    serializeMethodResult(methodName, value) {
        return getPropertyClassToXFunction(this.schema.getMethod(methodName), this.serializer)(value);
    }
    deserializeMethodResult(methodName, value) {
        return getPropertyXtoClassFunction(this.schema.getMethod(methodName), this.serializer)(value);
    }
    /**
     * Serialized a partial instance to the serialization format.
     */
    partialSerialize(data, options) {
        if (!this._partialSerialize)
            this._partialSerialize = getPartialClassToXFunction(this.schema, this.serializer);
        return this._partialSerialize(data, options);
    }
    /**
     * Converts data in form of this serialization format to the same partial target (default JS primitive/class) type.
     */
    partialDeserialize(data, options) {
        if (!this._partialDeserialize)
            this._partialDeserialize = getPartialXToClassFunction(this.schema, this.serializer);
        return this._partialDeserialize(data, options);
    }
    patchDeserialize(partial, options) {
        var _a, _b;
        const result = {};
        for (const i in partial) {
            if (!partial.hasOwnProperty(i))
                continue;
            const property = (_a = this.schema.getPropertiesMap().get(i)) !== null && _a !== void 0 ? _a : resolvePropertySchema(this.schema, i);
            result[i] = getPropertyXtoClassFunction(property, this.serializer)(partial[i], (_b = options === null || options === void 0 ? void 0 : options.parents) !== null && _b !== void 0 ? _b : [], options);
        }
        return result;
    }
    patchSerialize(partial, options) {
        var _a;
        const result = {};
        for (const i in partial) {
            if (!partial.hasOwnProperty(i))
                continue;
            const property = (_a = this.schema.getPropertiesMap().get(i)) !== null && _a !== void 0 ? _a : resolvePropertySchema(this.schema, i);
            result[i] = getPropertyClassToXFunction(property, this.serializer)(partial[i], options);
        }
        return result;
    }
}
export const emptySerializer = new class extends Serializer {
    constructor() {
        super('empty');
    }
};
//# sourceMappingURL=serializer.js.map