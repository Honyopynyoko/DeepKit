import { FlattenIfArray } from './utils';
export declare type PrimaryKey<T> = T & {
    __isPrimaryKey?: T;
};
export declare type Reference<T> = T & {
    __isReference?: T;
};
export declare type BackReference<T> = T & {
    __isBackReference?: T;
} & {
    __isReference?: T;
};
export declare type ExtractLooselyPrimaryKeys<T, R = Required<T>> = {
    [K in keyof R]: R[K] extends string | number ? K : never;
}[keyof R];
export declare type ExtractPrimaryKeys<T, R = Required<T>> = {
    [K in keyof R]: R[K] extends {
        __isPrimaryKey?: infer PKT;
    } ? K : never;
}[keyof R];
export declare type ExtractPrimaryKeyType<T> = ExtractPrimaryKeys<T> extends never ? any : ExtractPrimaryKeys<T>;
declare type _references<T> = {
    [K in keyof T]: T[K] extends {
        __isReference?: any;
    } ? K : never;
}[keyof T];
declare type isProbablyReference<T> = FlattenIfArray<T> extends number | string | Date | boolean ? false : true;
declare type _referencesFromClasses<T> = {
    [P in keyof T]: isProbablyReference<T[P]> extends true ? P : never;
}[keyof T];
declare type _referencesOrAllClassTypes<T> = _references<T> extends never ? _referencesFromClasses<T> : _references<T>;
export declare type ExtractReferences<T> = _referencesOrAllClassTypes<Required<T>>;
export declare type ExtractPrimaryKeyOrReferenceType<T> = T extends PrimaryKey<infer PT> ? PT : T extends Reference<infer RT> ? RT : T;
export declare type PrimaryKeyFields<T> = ExtractPrimaryKeyType<T> extends any ? Record<ExtractLooselyPrimaryKeys<T>, T> : Record<ExtractPrimaryKeys<T>, T>;
export declare type Types = 'objectId' | 'uuid' | 'literal' | 'class' | 'map' | 'partial' | 'patch' | 'array' | 'union' | 'date' | 'enum' | 'any' | 'string' | 'number' | 'bigint' | 'boolean' | 'Int8Array' | 'Uint8Array' | 'Uint8ClampedArray' | 'Int16Array' | 'Uint16Array' | 'Int32Array' | 'Uint32Array' | 'Float32Array' | 'Float64Array' | 'arrayBuffer';
/**
 * Type for @t.partial().
 */
export declare type PartialField<T> = {
    [P in keyof T & string]?: T[P];
} & {
    [path: string]: any;
};
/**
 * Type for @t.patch().
 * Differs to standard Partial<> in a way that it supports sub class fields using dot based paths (like mongoDB)
 */
export declare type PatchField<T> = {
    [P in keyof T & string]?: T[P];
} & {
    [path: string]: any;
};
export declare type PartialEntity<T> = {
    [name in keyof T & string]?: T[name];
};
export declare const typedArrayMap: Map<any, Types>;
export declare type TypedArrays = Uint8Array | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Uint8ClampedArray | Float32Array | Float64Array;
export declare const typedArrayNamesMap: Map<Types, any>;
export declare const binaryTypes: Types[];
export {};
