import { ClassType, CustomError } from '@deepkit/core';
import { ExtractClassType } from '@deepkit/type';
import { BaseEvent, EventDispatcher, EventToken } from '@deepkit/event';
import { InjectorContext } from '@deepkit/injector';
import { Stopwatch } from '@deepkit/stopwatch';
interface WorkflowTransition<T> {
    from: keyof T & string;
    to: keyof T & string;
    label?: string;
}
export declare class WorkflowEvent {
    stopped: boolean;
    stopPropagation(): void;
    isStopped(): boolean;
    nextState?: any;
    nextStateEvent?: any;
    clearNext(): void;
    /**
     * @see WorkflowNextEvent.next
     */
    next(nextState: string, event?: any): void;
    hasNext(): boolean;
}
export declare type WorkflowPlaces = {
    [name: string]: ClassType<WorkflowEvent>;
};
export interface WorkflowNextEvent<T extends WorkflowPlaces> {
    nextState?: keyof T & string;
    /**
     * Schedule to apply the next workflow step when all event listeners have been called.
     */
    next<S extends keyof T & string>(nextState: S, event?: ExtractClassType<T[S]>): void;
}
export declare type WorkflowDefinitionEvents<T extends WorkflowPlaces> = {
    [K in keyof T & string as `on${Capitalize<K>}`]: EventToken<BaseEvent & Omit<ExtractClassType<T[K]>, 'next' | 'nextState'> & WorkflowNextEvent<T>>;
};
export declare class WorkflowDefinition<T extends WorkflowPlaces> {
    readonly name: string;
    readonly places: T;
    transitions: WorkflowTransition<T>[];
    tokens: {
        [name in keyof T]?: EventToken<any>;
    };
    next: {
        [name in keyof T]?: (keyof T & string)[];
    };
    symbol: symbol;
    constructor(name: string, places: T, transitions?: WorkflowTransitions<T>);
    getEventToken<K extends keyof T>(name: K): EventToken<ExtractClassType<T[K]>>;
    addTransition(from: keyof T & string, to: keyof T & string, label?: string): void;
    create(state: keyof T & string, eventDispatcher: EventDispatcher, injectorContext?: InjectorContext, stopwatch?: Stopwatch): Workflow<T>;
    getTransitionsFrom(state: keyof T & string): (keyof T & string)[];
    buildApplier(eventDispatcher: EventDispatcher): Function;
}
declare type WorkflowTransitions<T extends WorkflowPlaces> = {
    [name in keyof T]?: (keyof T & string) | (keyof T & string)[];
};
export declare function createWorkflow<T extends WorkflowPlaces>(name: string, definition: T, transitions?: WorkflowTransitions<T>): WorkflowDefinition<T> & WorkflowDefinitionEvents<T>;
export interface WorkflowState<T> {
    get(): keyof T & string;
    set(v: keyof T & string): void;
}
export declare class WorkflowStateSubject<T extends WorkflowPlaces> implements WorkflowState<T> {
    value: keyof T & string;
    constructor(value: keyof T & string);
    get(): keyof T & string;
    set(v: keyof T & string): void;
}
export declare class WorkflowError extends CustomError {
}
export declare class Workflow<T extends WorkflowPlaces> {
    definition: WorkflowDefinition<T>;
    state: WorkflowState<T>;
    private eventDispatcher;
    private injectorContext;
    private stopwatch?;
    protected events: {
        [name in keyof T]?: Function;
    };
    constructor(definition: WorkflowDefinition<T>, state: WorkflowState<T>, eventDispatcher: EventDispatcher, injectorContext: InjectorContext, stopwatch?: Stopwatch | undefined);
    can(nextState: keyof T & string): boolean;
    /**
     * @throws WorkflowError when next state is not possible to apply.
     */
    apply<K extends keyof T>(nextState: K, event?: ExtractClassType<T[K]>): Promise<void>;
    isDone(): boolean;
}
export {};
