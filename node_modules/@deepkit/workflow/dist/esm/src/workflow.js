/*
 * Deepkit Framework
 * Copyright (C) 2021 Deepkit UG, Marc J. Schmidt
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the MIT License.
 *
 * You should have received a copy of the MIT License along with this program.
 */
import { capitalize, CompilerContext, CustomError, getClassName, isArray, toFastProperties } from '@deepkit/core';
import { EventToken, isEventListenerContainerEntryCallback, isEventListenerContainerEntryService } from '@deepkit/event';
export class WorkflowEvent {
    constructor() {
        this.stopped = false;
    }
    stopPropagation() {
        this.stopped = true;
    }
    isStopped() {
        return this.stopped;
    }
    clearNext() {
        this.nextState = undefined;
        this.nextStateEvent = undefined;
    }
    /**
     * @see WorkflowNextEvent.next
     */
    next(nextState, event) {
        this.nextState = nextState;
        this.nextStateEvent = event;
    }
    hasNext() {
        return this.nextState !== undefined;
    }
}
export class WorkflowDefinition {
    constructor(name, places, transitions = {}) {
        this.name = name;
        this.places = places;
        this.transitions = [];
        this.tokens = {};
        this.next = {};
        this.symbol = Symbol('workflow');
        for (const placeName in this.places) {
            if (!this.places.hasOwnProperty(placeName))
                continue;
            const token = new EventToken(name + '.' + placeName, this.places[placeName]);
            this.tokens[placeName] = token;
            this['on' + capitalize(placeName)] = token;
        }
        for (const [i, value] of Object.entries(transitions)) {
            if (isArray(value)) {
                for (const v of value)
                    this.addTransition(i, v);
            }
            else if (value !== undefined) {
                this.addTransition(i, value);
            }
        }
        toFastProperties(this.tokens);
        toFastProperties(this.next);
    }
    getEventToken(name) {
        if (!this.tokens[name])
            throw new Error(`No event token found for ${name}`);
        return this.tokens[name];
    }
    addTransition(from, to, label) {
        this.transitions.push({ from, to, label });
        if (!this.next[from])
            this.next[from] = [];
        this.next[from].push(to);
    }
    create(state, eventDispatcher, injectorContext, stopwatch) {
        return new Workflow(this, new WorkflowStateSubject(state), eventDispatcher, injectorContext || eventDispatcher.scopedContext, stopwatch);
    }
    getTransitionsFrom(state) {
        return this.next[state] || [];
    }
    buildApplier(eventDispatcher) {
        const compiler = new CompilerContext();
        compiler.context.set('WorkflowError', WorkflowError);
        compiler.context.set('WorkflowEvent', WorkflowEvent);
        compiler.context.set('getClassName', getClassName);
        const lines = [];
        const varName = new Map();
        for (const [place, eventType] of Object.entries(this.places)) {
            const stateString = JSON.stringify(place);
            const eventTypeVar = compiler.reserveVariable('eventType', eventType);
            const allowedFrom = this.transitions.filter(v => v.to === place);
            const allowedFromCondition = allowedFrom.map(v => `currentState === ${JSON.stringify(v.from)}`).join(' || ');
            const checkFrom = `if (!(${allowedFromCondition})) throw new WorkflowError(\`Can not apply state change from \${currentState}->\${nextState}. There's no transition between them or it was blocked.\`);`;
            const eventToken = this.tokens[place];
            const listeners = eventDispatcher.getListeners(eventToken);
            listeners.sort((a, b) => {
                if (a.order > b.order)
                    return +1;
                if (a.order < b.order)
                    return -1;
                return 0;
            });
            const listenerCode = [];
            for (const listener of listeners) {
                if (isEventListenerContainerEntryCallback(listener)) {
                    const fnVar = compiler.reserveVariable('fn', listener.fn);
                    listenerCode.push(`
                        if (!event.isStopped()) {
                            await ${fnVar}(event);
                        }
                    `);
                }
                else if (isEventListenerContainerEntryService(listener)) {
                    let classTypeVar = varName.get(listener.classType);
                    if (!classTypeVar) {
                        classTypeVar = compiler.reserveVariable('classType', listener.classType);
                        varName.set(listener.classType, classTypeVar);
                    }
                    const resolvedVar = classTypeVar + '_resolved';
                    listenerCode.push(`
                    //${getClassName(listener.classType)}.${listener.methodName}
                    if (!event.isStopped()) {
                        if (!${resolvedVar}) ${resolvedVar} = scopedContext.get(${classTypeVar});
                        await ${resolvedVar}.${listener.methodName}(event);
                    }
                `);
                }
            }
            const stopWatchId = this.name + '/' + place;
            lines.push(`
            case ${stateString}: {
                ${allowedFrom.length ? checkFrom : ''}
                if (!(event instanceof ${eventTypeVar})) {
                    throw new Error(\`State ${place} got the wrong event. Expected ${getClassName(eventType)}, got \${getClassName(event)}\`);
                }
                const frame = stopwatch && stopwatch.active ? stopwatch.start(${JSON.stringify(stopWatchId)}) : undefined;

                ${listenerCode.join('\n')}

                if (frame) frame.end();
                state.set(${stateString});
                break;
            }
        `);
        }
        const pre = [];
        for (const name of varName.values())
            pre.push(`let ${name}_resolved;`);
        return compiler.buildAsync(`
            ${pre.join('\n')}

            while (true) {
                const currentState = state.get();
                switch (nextState) {
                    ${lines.join('\n')}
                }

                if (event.nextState) {
                    nextState = event.nextState;
                    event = event.nextStateEvent || new WorkflowEvent();
                    continue;
                }
                return;
            }
        `, 'scopedContext', 'state', 'nextState', 'event', 'stopwatch');
    }
}
export function createWorkflow(name, definition, transitions = {}) {
    return new WorkflowDefinition(name, definition, transitions);
}
export class WorkflowStateSubject {
    constructor(value) {
        this.value = value;
    }
    get() {
        return this.value;
    }
    set(v) {
        this.value = v;
    }
}
export class WorkflowError extends CustomError {
}
export class Workflow {
    constructor(definition, state, eventDispatcher, injectorContext, stopwatch) {
        this.definition = definition;
        this.state = state;
        this.eventDispatcher = eventDispatcher;
        this.injectorContext = injectorContext;
        this.stopwatch = stopwatch;
        this.events = {};
    }
    can(nextState) {
        return this.definition.getTransitionsFrom(this.state.get()).includes(nextState);
    }
    /**
     * @throws WorkflowError when next state is not possible to apply.
     */
    apply(nextState, event) {
        let fn = this.eventDispatcher[this.definition.symbol];
        if (!fn) {
            fn = this.eventDispatcher[this.definition.symbol] = this.definition.buildApplier(this.eventDispatcher);
        }
        return fn(this.injectorContext, this.state, nextState, event || new WorkflowEvent(), this.stopwatch);
    }
    isDone() {
        return this.definition.getTransitionsFrom(this.state.get()).length === 0;
    }
}
//# sourceMappingURL=workflow.js.map